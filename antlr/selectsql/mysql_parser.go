// Code generated from D:/1_workspace/go/grzeng/antlr4-demo/antlr\MySqlParser.g4 by ANTLR 4.8. DO NOT EDIT.

package selectsql // MySqlParser

import (
	"fmt"
	"reflect"
	"strconv"

	"github.com/antlr/antlr4/runtime/Go/antlr"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = reflect.Copy
var _ = strconv.Itoa

var parserATN = []uint16{
	3, 24715, 42794, 33075, 47597, 16764, 15335, 30598, 22884, 3, 1052, 1480,
	4, 2, 9, 2, 4, 3, 9, 3, 4, 4, 9, 4, 4, 5, 9, 5, 4, 6, 9, 6, 4, 7, 9, 7,
	4, 8, 9, 8, 4, 9, 9, 9, 4, 10, 9, 10, 4, 11, 9, 11, 4, 12, 9, 12, 4, 13,
	9, 13, 4, 14, 9, 14, 4, 15, 9, 15, 4, 16, 9, 16, 4, 17, 9, 17, 4, 18, 9,
	18, 4, 19, 9, 19, 4, 20, 9, 20, 4, 21, 9, 21, 4, 22, 9, 22, 4, 23, 9, 23,
	4, 24, 9, 24, 4, 25, 9, 25, 4, 26, 9, 26, 4, 27, 9, 27, 4, 28, 9, 28, 4,
	29, 9, 29, 4, 30, 9, 30, 4, 31, 9, 31, 4, 32, 9, 32, 4, 33, 9, 33, 4, 34,
	9, 34, 4, 35, 9, 35, 4, 36, 9, 36, 4, 37, 9, 37, 4, 38, 9, 38, 4, 39, 9,
	39, 4, 40, 9, 40, 4, 41, 9, 41, 4, 42, 9, 42, 4, 43, 9, 43, 4, 44, 9, 44,
	4, 45, 9, 45, 4, 46, 9, 46, 4, 47, 9, 47, 4, 48, 9, 48, 4, 49, 9, 49, 4,
	50, 9, 50, 4, 51, 9, 51, 4, 52, 9, 52, 4, 53, 9, 53, 4, 54, 9, 54, 4, 55,
	9, 55, 4, 56, 9, 56, 4, 57, 9, 57, 4, 58, 9, 58, 4, 59, 9, 59, 4, 60, 9,
	60, 4, 61, 9, 61, 4, 62, 9, 62, 4, 63, 9, 63, 4, 64, 9, 64, 4, 65, 9, 65,
	4, 66, 9, 66, 4, 67, 9, 67, 4, 68, 9, 68, 4, 69, 9, 69, 4, 70, 9, 70, 4,
	71, 9, 71, 4, 72, 9, 72, 4, 73, 9, 73, 4, 74, 9, 74, 4, 75, 9, 75, 4, 76,
	9, 76, 4, 77, 9, 77, 4, 78, 9, 78, 4, 79, 9, 79, 4, 80, 9, 80, 4, 81, 9,
	81, 4, 82, 9, 82, 3, 2, 3, 2, 3, 3, 3, 3, 5, 3, 169, 10, 3, 3, 3, 3, 3,
	5, 3, 173, 10, 3, 3, 3, 3, 3, 6, 3, 177, 10, 3, 13, 3, 14, 3, 178, 3, 3,
	5, 3, 182, 10, 3, 3, 3, 5, 3, 185, 10, 3, 3, 3, 5, 3, 188, 10, 3, 3, 3,
	5, 3, 191, 10, 3, 3, 3, 3, 3, 6, 3, 195, 10, 3, 13, 3, 14, 3, 196, 3, 3,
	5, 3, 200, 10, 3, 3, 3, 5, 3, 203, 10, 3, 3, 3, 5, 3, 206, 10, 3, 3, 3,
	5, 3, 209, 10, 3, 5, 3, 211, 10, 3, 3, 4, 3, 4, 5, 4, 215, 10, 4, 3, 5,
	3, 5, 3, 5, 3, 5, 3, 5, 3, 5, 5, 5, 223, 10, 5, 3, 6, 3, 6, 3, 6, 3, 6,
	3, 6, 7, 6, 230, 10, 6, 12, 6, 14, 6, 233, 11, 6, 3, 7, 3, 7, 5, 7, 237,
	10, 7, 3, 8, 3, 8, 3, 8, 7, 8, 242, 10, 8, 12, 8, 14, 8, 245, 11, 8, 3,
	9, 3, 9, 7, 9, 249, 10, 9, 12, 9, 14, 9, 252, 11, 9, 3, 9, 3, 9, 3, 9,
	7, 9, 257, 10, 9, 12, 9, 14, 9, 260, 11, 9, 3, 9, 3, 9, 5, 9, 264, 10,
	9, 3, 10, 3, 10, 3, 10, 3, 10, 3, 10, 3, 10, 5, 10, 272, 10, 10, 3, 10,
	5, 10, 275, 10, 10, 3, 10, 5, 10, 278, 10, 10, 3, 10, 3, 10, 3, 10, 7,
	10, 283, 10, 10, 12, 10, 14, 10, 286, 11, 10, 5, 10, 288, 10, 10, 3, 10,
	3, 10, 3, 10, 3, 10, 3, 10, 5, 10, 295, 10, 10, 3, 10, 5, 10, 298, 10,
	10, 3, 10, 3, 10, 3, 10, 3, 10, 3, 10, 3, 10, 5, 10, 306, 10, 10, 3, 11,
	3, 11, 3, 11, 3, 11, 5, 11, 312, 10, 11, 3, 11, 3, 11, 3, 11, 3, 11, 3,
	12, 3, 12, 3, 12, 3, 12, 3, 12, 5, 12, 323, 10, 12, 3, 13, 5, 13, 326,
	10, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13,
	5, 13, 337, 10, 13, 3, 13, 3, 13, 3, 13, 3, 13, 5, 13, 343, 10, 13, 3,
	13, 3, 13, 5, 13, 347, 10, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 3, 13,
	3, 13, 3, 13, 3, 13, 5, 13, 358, 10, 13, 3, 13, 3, 13, 3, 13, 5, 13, 363,
	10, 13, 5, 13, 365, 10, 13, 3, 13, 3, 13, 5, 13, 369, 10, 13, 3, 14, 3,
	14, 3, 14, 3, 14, 3, 14, 3, 14, 3, 14, 3, 14, 5, 14, 379, 10, 14, 3, 15,
	3, 15, 3, 15, 3, 15, 3, 15, 3, 15, 3, 15, 3, 15, 5, 15, 389, 10, 15, 3,
	16, 3, 16, 7, 16, 393, 10, 16, 12, 16, 14, 16, 396, 11, 16, 3, 16, 3, 16,
	5, 16, 400, 10, 16, 3, 16, 5, 16, 403, 10, 16, 3, 16, 5, 16, 406, 10, 16,
	3, 16, 5, 16, 409, 10, 16, 3, 16, 3, 16, 7, 16, 413, 10, 16, 12, 16, 14,
	16, 416, 11, 16, 3, 16, 3, 16, 5, 16, 420, 10, 16, 3, 16, 5, 16, 423, 10,
	16, 3, 16, 5, 16, 426, 10, 16, 3, 16, 5, 16, 429, 10, 16, 5, 16, 431, 10,
	16, 3, 17, 3, 17, 7, 17, 435, 10, 17, 12, 17, 14, 17, 438, 11, 17, 3, 17,
	3, 17, 5, 17, 442, 10, 17, 3, 17, 5, 17, 445, 10, 17, 3, 17, 5, 17, 448,
	10, 17, 3, 18, 3, 18, 5, 18, 452, 10, 18, 3, 18, 3, 18, 3, 19, 3, 19, 5,
	19, 458, 10, 19, 3, 19, 3, 19, 5, 19, 462, 10, 19, 3, 20, 3, 20, 5, 20,
	466, 10, 20, 3, 20, 3, 20, 5, 20, 470, 10, 20, 3, 21, 3, 21, 5, 21, 474,
	10, 21, 3, 21, 3, 21, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22, 3, 22,
	3, 22, 5, 22, 486, 10, 22, 3, 23, 3, 23, 5, 23, 490, 10, 23, 3, 23, 3,
	23, 7, 23, 494, 10, 23, 12, 23, 14, 23, 497, 11, 23, 3, 24, 3, 24, 3, 24,
	3, 24, 3, 24, 3, 24, 5, 24, 505, 10, 24, 3, 24, 5, 24, 508, 10, 24, 3,
	24, 3, 24, 5, 24, 512, 10, 24, 3, 24, 5, 24, 515, 10, 24, 3, 24, 3, 24,
	5, 24, 519, 10, 24, 3, 24, 3, 24, 5, 24, 523, 10, 24, 3, 24, 5, 24, 526,
	10, 24, 5, 24, 528, 10, 24, 3, 25, 3, 25, 3, 25, 3, 25, 7, 25, 534, 10,
	25, 12, 25, 14, 25, 537, 11, 25, 3, 25, 3, 25, 3, 25, 3, 25, 3, 25, 3,
	25, 3, 25, 3, 25, 3, 25, 5, 25, 548, 10, 25, 3, 25, 3, 25, 6, 25, 552,
	10, 25, 13, 25, 14, 25, 553, 5, 25, 556, 10, 25, 3, 25, 3, 25, 6, 25, 560,
	10, 25, 13, 25, 14, 25, 561, 5, 25, 564, 10, 25, 5, 25, 566, 10, 25, 3,
	26, 3, 26, 3, 26, 3, 26, 5, 26, 572, 10, 26, 3, 26, 3, 26, 3, 26, 3, 26,
	3, 26, 3, 26, 5, 26, 580, 10, 26, 3, 27, 3, 27, 3, 27, 3, 27, 3, 27, 3,
	27, 5, 27, 588, 10, 27, 3, 28, 3, 28, 3, 28, 3, 28, 5, 28, 594, 10, 28,
	3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 7, 28, 601, 10, 28, 12, 28, 14, 28,
	604, 11, 28, 3, 28, 3, 28, 5, 28, 608, 10, 28, 5, 28, 610, 10, 28, 3, 28,
	3, 28, 5, 28, 614, 10, 28, 3, 29, 3, 29, 5, 29, 618, 10, 29, 3, 30, 3,
	30, 3, 30, 3, 30, 5, 30, 624, 10, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30,
	5, 30, 631, 10, 30, 3, 31, 3, 31, 5, 31, 635, 10, 31, 3, 32, 3, 32, 3,
	32, 3, 32, 5, 32, 641, 10, 32, 3, 33, 3, 33, 3, 34, 3, 34, 3, 34, 5, 34,
	648, 10, 34, 5, 34, 650, 10, 34, 3, 35, 3, 35, 3, 36, 3, 36, 3, 36, 3,
	36, 5, 36, 658, 10, 36, 3, 37, 3, 37, 3, 37, 5, 37, 663, 10, 37, 3, 38,
	3, 38, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 5,
	39, 676, 10, 39, 3, 40, 3, 40, 3, 40, 5, 40, 681, 10, 40, 3, 41, 3, 41,
	5, 41, 685, 10, 41, 3, 42, 3, 42, 3, 43, 5, 43, 690, 10, 43, 3, 43, 3,
	43, 5, 43, 694, 10, 43, 3, 43, 6, 43, 697, 10, 43, 13, 43, 14, 43, 698,
	3, 43, 5, 43, 702, 10, 43, 3, 43, 3, 43, 5, 43, 706, 10, 43, 3, 43, 3,
	43, 5, 43, 710, 10, 43, 5, 43, 712, 10, 43, 3, 44, 5, 44, 715, 10, 44,
	3, 44, 3, 44, 3, 45, 3, 45, 3, 46, 5, 46, 722, 10, 46, 3, 46, 3, 46, 3,
	47, 3, 47, 3, 47, 3, 47, 3, 47, 3, 47, 3, 47, 3, 47, 3, 47, 5, 47, 735,
	10, 47, 3, 48, 3, 48, 5, 48, 739, 10, 48, 3, 48, 5, 48, 742, 10, 48, 3,
	48, 3, 48, 3, 48, 5, 48, 747, 10, 48, 3, 48, 5, 48, 750, 10, 48, 3, 48,
	3, 48, 5, 48, 754, 10, 48, 3, 48, 3, 48, 3, 48, 5, 48, 759, 10, 48, 3,
	48, 5, 48, 762, 10, 48, 3, 48, 3, 48, 3, 48, 5, 48, 767, 10, 48, 3, 48,
	5, 48, 770, 10, 48, 3, 48, 3, 48, 3, 48, 3, 48, 5, 48, 776, 10, 48, 3,
	48, 5, 48, 779, 10, 48, 3, 48, 3, 48, 5, 48, 783, 10, 48, 3, 48, 5, 48,
	786, 10, 48, 3, 48, 5, 48, 789, 10, 48, 3, 48, 3, 48, 5, 48, 793, 10, 48,
	3, 48, 5, 48, 796, 10, 48, 3, 48, 5, 48, 799, 10, 48, 3, 48, 3, 48, 5,
	48, 803, 10, 48, 3, 48, 5, 48, 806, 10, 48, 3, 48, 5, 48, 809, 10, 48,
	3, 48, 5, 48, 812, 10, 48, 3, 48, 3, 48, 5, 48, 816, 10, 48, 3, 48, 5,
	48, 819, 10, 48, 3, 48, 5, 48, 822, 10, 48, 3, 48, 3, 48, 3, 48, 5, 48,
	827, 10, 48, 3, 48, 3, 48, 3, 48, 5, 48, 832, 10, 48, 3, 48, 3, 48, 3,
	48, 5, 48, 837, 10, 48, 3, 48, 5, 48, 840, 10, 48, 3, 48, 3, 48, 3, 48,
	5, 48, 845, 10, 48, 3, 48, 5, 48, 848, 10, 48, 3, 48, 3, 48, 3, 48, 5,
	48, 853, 10, 48, 3, 48, 5, 48, 856, 10, 48, 3, 48, 3, 48, 5, 48, 860, 10,
	48, 3, 48, 3, 48, 5, 48, 864, 10, 48, 3, 49, 3, 49, 3, 49, 3, 49, 7, 49,
	870, 10, 49, 12, 49, 14, 49, 873, 11, 49, 3, 49, 3, 49, 3, 50, 3, 50, 5,
	50, 879, 10, 50, 3, 50, 3, 50, 5, 50, 883, 10, 50, 3, 50, 3, 50, 3, 50,
	5, 50, 888, 10, 50, 3, 50, 5, 50, 891, 10, 50, 3, 50, 3, 50, 3, 50, 5,
	50, 896, 10, 50, 3, 50, 3, 50, 5, 50, 900, 10, 50, 5, 50, 902, 10, 50,
	3, 51, 3, 51, 3, 51, 3, 51, 3, 52, 3, 52, 3, 52, 3, 52, 3, 52, 3, 52, 3,
	53, 3, 53, 3, 53, 3, 53, 5, 53, 918, 10, 53, 3, 53, 3, 53, 3, 54, 3, 54,
	3, 54, 7, 54, 925, 10, 54, 12, 54, 14, 54, 928, 11, 54, 3, 55, 3, 55, 3,
	55, 7, 55, 933, 10, 55, 12, 55, 14, 55, 936, 11, 55, 3, 56, 3, 56, 3, 56,
	3, 56, 3, 56, 3, 56, 3, 56, 3, 56, 3, 56, 3, 56, 3, 56, 3, 56, 3, 56, 5,
	56, 951, 10, 56, 3, 57, 3, 57, 3, 57, 3, 57, 3, 57, 5, 57, 958, 10, 57,
	3, 57, 3, 57, 3, 57, 3, 57, 3, 57, 5, 57, 965, 10, 57, 3, 57, 3, 57, 3,
	57, 5, 57, 970, 10, 57, 3, 58, 3, 58, 3, 58, 3, 58, 3, 58, 3, 58, 3, 58,
	3, 58, 3, 58, 3, 58, 3, 58, 3, 58, 3, 58, 3, 58, 3, 58, 3, 58, 3, 58, 3,
	58, 3, 58, 3, 58, 3, 58, 3, 58, 3, 58, 3, 58, 3, 58, 3, 58, 3, 58, 3, 58,
	3, 58, 3, 58, 6, 58, 1002, 10, 58, 13, 58, 14, 58, 1003, 3, 58, 3, 58,
	5, 58, 1008, 10, 58, 3, 58, 3, 58, 3, 58, 3, 58, 6, 58, 1014, 10, 58, 13,
	58, 14, 58, 1015, 3, 58, 3, 58, 5, 58, 1020, 10, 58, 3, 58, 3, 58, 3, 58,
	3, 58, 3, 58, 3, 58, 3, 58, 5, 58, 1029, 10, 58, 3, 58, 3, 58, 3, 58, 3,
	58, 3, 58, 3, 58, 5, 58, 1037, 10, 58, 3, 58, 3, 58, 3, 58, 5, 58, 1042,
	10, 58, 3, 58, 3, 58, 3, 58, 3, 58, 3, 58, 3, 58, 5, 58, 1050, 10, 58,
	3, 58, 3, 58, 3, 58, 5, 58, 1055, 10, 58, 3, 58, 3, 58, 3, 58, 5, 58, 1060,
	10, 58, 5, 58, 1062, 10, 58, 3, 58, 3, 58, 3, 58, 3, 58, 3, 58, 3, 58,
	3, 58, 5, 58, 1071, 10, 58, 3, 58, 3, 58, 3, 58, 5, 58, 1076, 10, 58, 3,
	58, 3, 58, 3, 58, 3, 58, 3, 58, 3, 58, 5, 58, 1084, 10, 58, 3, 58, 3, 58,
	3, 58, 5, 58, 1089, 10, 58, 3, 58, 3, 58, 3, 58, 3, 58, 3, 58, 3, 58, 5,
	58, 1097, 10, 58, 3, 58, 3, 58, 3, 58, 3, 58, 3, 58, 3, 58, 5, 58, 1105,
	10, 58, 3, 58, 5, 58, 1108, 10, 58, 3, 58, 3, 58, 3, 58, 3, 58, 3, 58,
	3, 58, 3, 58, 3, 58, 5, 58, 1118, 10, 58, 3, 58, 3, 58, 3, 58, 3, 58, 3,
	58, 3, 58, 3, 58, 3, 58, 3, 58, 5, 58, 1129, 10, 58, 3, 59, 3, 59, 3, 59,
	3, 59, 3, 59, 3, 60, 3, 60, 3, 60, 3, 60, 7, 60, 1140, 10, 60, 12, 60,
	14, 60, 1143, 11, 60, 3, 60, 3, 60, 3, 60, 3, 60, 3, 60, 5, 60, 1150, 10,
	60, 3, 61, 3, 61, 5, 61, 1154, 10, 61, 3, 62, 3, 62, 3, 62, 5, 62, 1159,
	10, 62, 3, 62, 3, 62, 3, 62, 3, 62, 3, 62, 3, 62, 3, 62, 5, 62, 1168, 10,
	62, 3, 62, 5, 62, 1171, 10, 62, 3, 62, 3, 62, 3, 62, 3, 62, 3, 62, 3, 62,
	3, 62, 3, 62, 3, 62, 3, 62, 5, 62, 1183, 10, 62, 3, 62, 3, 62, 3, 62, 3,
	62, 3, 62, 3, 62, 5, 62, 1191, 10, 62, 3, 62, 3, 62, 3, 62, 3, 62, 3, 62,
	3, 62, 7, 62, 1199, 10, 62, 12, 62, 14, 62, 1202, 11, 62, 5, 62, 1204,
	10, 62, 3, 62, 3, 62, 5, 62, 1208, 10, 62, 3, 62, 3, 62, 5, 62, 1212, 10,
	62, 3, 63, 3, 63, 3, 63, 3, 63, 3, 63, 3, 63, 3, 63, 3, 63, 3, 63, 3, 63,
	3, 63, 3, 63, 3, 63, 3, 63, 3, 63, 3, 63, 3, 63, 3, 63, 3, 63, 3, 63, 3,
	63, 3, 63, 3, 63, 5, 63, 1237, 10, 63, 3, 64, 3, 64, 3, 64, 3, 64, 3, 64,
	3, 65, 3, 65, 3, 65, 7, 65, 1247, 10, 65, 12, 65, 14, 65, 1250, 11, 65,
	3, 66, 3, 66, 3, 66, 3, 66, 5, 66, 1256, 10, 66, 3, 67, 3, 67, 3, 67, 3,
	67, 3, 67, 3, 67, 5, 67, 1264, 10, 67, 3, 67, 3, 67, 3, 67, 5, 67, 1269,
	10, 67, 3, 67, 3, 67, 3, 67, 3, 67, 7, 67, 1275, 10, 67, 12, 67, 14, 67,
	1278, 11, 67, 3, 68, 3, 68, 3, 68, 5, 68, 1283, 10, 68, 3, 68, 3, 68, 3,
	68, 3, 68, 3, 68, 3, 68, 3, 68, 3, 68, 5, 68, 1293, 10, 68, 3, 68, 3, 68,
	3, 68, 3, 68, 3, 68, 3, 68, 3, 68, 3, 68, 3, 68, 3, 68, 3, 68, 5, 68, 1306,
	10, 68, 3, 68, 3, 68, 3, 68, 3, 68, 5, 68, 1312, 10, 68, 3, 68, 3, 68,
	3, 68, 3, 68, 5, 68, 1318, 10, 68, 3, 68, 3, 68, 3, 68, 3, 68, 3, 68, 3,
	68, 3, 68, 3, 68, 3, 68, 3, 68, 3, 68, 3, 68, 3, 68, 3, 68, 5, 68, 1334,
	10, 68, 3, 68, 3, 68, 3, 68, 3, 68, 5, 68, 1340, 10, 68, 3, 68, 3, 68,
	3, 68, 3, 68, 3, 68, 3, 68, 3, 68, 7, 68, 1349, 10, 68, 12, 68, 14, 68,
	1352, 11, 68, 3, 69, 3, 69, 3, 69, 3, 69, 3, 69, 3, 69, 3, 69, 3, 69, 3,
	69, 3, 69, 3, 69, 3, 69, 3, 69, 3, 69, 7, 69, 1368, 10, 69, 12, 69, 14,
	69, 1371, 11, 69, 3, 69, 3, 69, 3, 69, 3, 69, 3, 69, 3, 69, 3, 69, 6, 69,
	1380, 10, 69, 13, 69, 14, 69, 1381, 3, 69, 3, 69, 3, 69, 3, 69, 3, 69,
	3, 69, 3, 69, 3, 69, 3, 69, 3, 69, 3, 69, 3, 69, 3, 69, 3, 69, 3, 69, 5,
	69, 1399, 10, 69, 3, 69, 3, 69, 3, 69, 3, 69, 3, 69, 3, 69, 3, 69, 3, 69,
	3, 69, 3, 69, 3, 69, 3, 69, 3, 69, 3, 69, 3, 69, 7, 69, 1416, 10, 69, 12,
	69, 14, 69, 1419, 11, 69, 3, 70, 3, 70, 3, 71, 3, 71, 3, 71, 3, 71, 3,
	71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71, 5, 71,
	1437, 10, 71, 3, 72, 3, 72, 3, 72, 3, 72, 3, 72, 3, 72, 3, 72, 5, 72, 1446,
	10, 72, 3, 73, 3, 73, 3, 73, 3, 73, 3, 73, 3, 73, 3, 73, 5, 73, 1455, 10,
	73, 3, 74, 3, 74, 3, 75, 3, 75, 3, 75, 3, 75, 3, 75, 5, 75, 1464, 10, 75,
	3, 76, 3, 76, 3, 77, 3, 77, 3, 78, 3, 78, 3, 79, 3, 79, 3, 80, 3, 80, 3,
	81, 3, 81, 3, 82, 3, 82, 3, 82, 2, 5, 132, 134, 136, 83, 2, 4, 6, 8, 10,
	12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46,
	48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82,
	84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114,
	116, 118, 120, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 142, 144,
	146, 148, 150, 152, 154, 156, 158, 160, 162, 2, 50, 4, 2, 14, 14, 43, 43,
	5, 2, 61, 61, 72, 72, 170, 170, 4, 2, 74, 74, 84, 84, 4, 2, 33, 33, 76,
	76, 4, 2, 89, 89, 135, 135, 4, 2, 8, 8, 47, 47, 4, 2, 8, 8, 47, 48, 3,
	2, 539, 540, 4, 2, 304, 304, 361, 361, 3, 2, 1050, 1051, 5, 2, 681, 692,
	1039, 1039, 1047, 1048, 4, 2, 1029, 1031, 1040, 1040, 4, 2, 106, 106, 1043,
	1043, 4, 2, 58, 58, 162, 162, 7, 2, 24, 24, 206, 208, 215, 215, 217, 220,
	448, 448, 4, 2, 24, 24, 207, 207, 4, 2, 24, 24, 206, 206, 3, 2, 180, 191,
	4, 2, 167, 167, 525, 525, 4, 2, 195, 200, 365, 365, 7, 2, 201, 201, 212,
	214, 216, 216, 223, 223, 288, 289, 5, 2, 202, 205, 210, 211, 286, 286,
	4, 2, 140, 140, 221, 221, 4, 2, 396, 396, 697, 705, 4, 2, 210, 210, 448,
	448, 5, 2, 201, 202, 204, 204, 396, 396, 4, 2, 35, 35, 253, 256, 3, 2,
	265, 266, 5, 2, 17, 17, 87, 87, 160, 160, 4, 2, 206, 206, 210, 210, 4,
	2, 201, 202, 204, 204, 5, 2, 14, 14, 43, 43, 886, 886, 5, 2, 237, 237,
	243, 244, 249, 249, 5, 2, 238, 240, 245, 248, 250, 252, 4, 2, 458, 458,
	472, 472, 4, 2, 104, 104, 1018, 1018, 5, 2, 58, 58, 162, 162, 573, 573,
	4, 2, 125, 125, 136, 136, 5, 2, 8, 8, 277, 277, 531, 531, 6, 2, 104, 104,
	1010, 1010, 1012, 1012, 1018, 1019, 3, 2, 1007, 1014, 3, 2, 641, 680, 3,
	2, 693, 696, 3, 2, 606, 614, 3, 2, 598, 605, 5, 2, 201, 205, 218, 218,
	221, 221, 16, 2, 34, 34, 46, 46, 107, 107, 153, 153, 223, 223, 272, 388,
	390, 549, 551, 582, 585, 592, 597, 597, 616, 640, 686, 686, 730, 730, 896,
	896, 18, 2, 37, 37, 89, 89, 135, 135, 201, 203, 205, 205, 235, 236, 241,
	241, 264, 264, 389, 389, 584, 584, 598, 605, 634, 634, 697, 697, 700, 729,
	731, 895, 897, 997, 2, 1747, 2, 164, 3, 2, 2, 2, 4, 210, 3, 2, 2, 2, 6,
	214, 3, 2, 2, 2, 8, 222, 3, 2, 2, 2, 10, 224, 3, 2, 2, 2, 12, 234, 3, 2,
	2, 2, 14, 238, 3, 2, 2, 2, 16, 263, 3, 2, 2, 2, 18, 305, 3, 2, 2, 2, 20,
	307, 3, 2, 2, 2, 22, 322, 3, 2, 2, 2, 24, 368, 3, 2, 2, 2, 26, 378, 3,
	2, 2, 2, 28, 388, 3, 2, 2, 2, 30, 430, 3, 2, 2, 2, 32, 432, 3, 2, 2, 2,
	34, 449, 3, 2, 2, 2, 36, 455, 3, 2, 2, 2, 38, 463, 3, 2, 2, 2, 40, 471,
	3, 2, 2, 2, 42, 485, 3, 2, 2, 2, 44, 489, 3, 2, 2, 2, 46, 527, 3, 2, 2,
	2, 48, 565, 3, 2, 2, 2, 50, 579, 3, 2, 2, 2, 52, 587, 3, 2, 2, 2, 54, 589,
	3, 2, 2, 2, 56, 615, 3, 2, 2, 2, 58, 619, 3, 2, 2, 2, 60, 634, 3, 2, 2,
	2, 62, 636, 3, 2, 2, 2, 64, 642, 3, 2, 2, 2, 66, 644, 3, 2, 2, 2, 68, 651,
	3, 2, 2, 2, 70, 657, 3, 2, 2, 2, 72, 662, 3, 2, 2, 2, 74, 664, 3, 2, 2,
	2, 76, 675, 3, 2, 2, 2, 78, 680, 3, 2, 2, 2, 80, 684, 3, 2, 2, 2, 82, 686,
	3, 2, 2, 2, 84, 711, 3, 2, 2, 2, 86, 714, 3, 2, 2, 2, 88, 718, 3, 2, 2,
	2, 90, 721, 3, 2, 2, 2, 92, 734, 3, 2, 2, 2, 94, 863, 3, 2, 2, 2, 96, 865,
	3, 2, 2, 2, 98, 901, 3, 2, 2, 2, 100, 903, 3, 2, 2, 2, 102, 907, 3, 2,
	2, 2, 104, 913, 3, 2, 2, 2, 106, 921, 3, 2, 2, 2, 108, 929, 3, 2, 2, 2,
	110, 950, 3, 2, 2, 2, 112, 969, 3, 2, 2, 2, 114, 1128, 3, 2, 2, 2, 116,
	1130, 3, 2, 2, 2, 118, 1149, 3, 2, 2, 2, 120, 1151, 3, 2, 2, 2, 122, 1211,
	3, 2, 2, 2, 124, 1236, 3, 2, 2, 2, 126, 1238, 3, 2, 2, 2, 128, 1243, 3,
	2, 2, 2, 130, 1255, 3, 2, 2, 2, 132, 1268, 3, 2, 2, 2, 134, 1279, 3, 2,
	2, 2, 136, 1398, 3, 2, 2, 2, 138, 1420, 3, 2, 2, 2, 140, 1436, 3, 2, 2,
	2, 142, 1445, 3, 2, 2, 2, 144, 1454, 3, 2, 2, 2, 146, 1456, 3, 2, 2, 2,
	148, 1463, 3, 2, 2, 2, 150, 1465, 3, 2, 2, 2, 152, 1467, 3, 2, 2, 2, 154,
	1469, 3, 2, 2, 2, 156, 1471, 3, 2, 2, 2, 158, 1473, 3, 2, 2, 2, 160, 1475,
	3, 2, 2, 2, 162, 1477, 3, 2, 2, 2, 164, 165, 5, 4, 3, 2, 165, 3, 3, 2,
	2, 2, 166, 168, 5, 30, 16, 2, 167, 169, 5, 8, 5, 2, 168, 167, 3, 2, 2,
	2, 168, 169, 3, 2, 2, 2, 169, 211, 3, 2, 2, 2, 170, 172, 5, 26, 14, 2,
	171, 173, 5, 8, 5, 2, 172, 171, 3, 2, 2, 2, 172, 173, 3, 2, 2, 2, 173,
	211, 3, 2, 2, 2, 174, 176, 5, 32, 17, 2, 175, 177, 5, 36, 19, 2, 176, 175,
	3, 2, 2, 2, 177, 178, 3, 2, 2, 2, 178, 176, 3, 2, 2, 2, 178, 179, 3, 2,
	2, 2, 179, 181, 3, 2, 2, 2, 180, 182, 5, 38, 20, 2, 181, 180, 3, 2, 2,
	2, 181, 182, 3, 2, 2, 2, 182, 184, 3, 2, 2, 2, 183, 185, 5, 10, 6, 2, 184,
	183, 3, 2, 2, 2, 184, 185, 3, 2, 2, 2, 185, 187, 3, 2, 2, 2, 186, 188,
	5, 58, 30, 2, 187, 186, 3, 2, 2, 2, 187, 188, 3, 2, 2, 2, 188, 190, 3,
	2, 2, 2, 189, 191, 5, 8, 5, 2, 190, 189, 3, 2, 2, 2, 190, 191, 3, 2, 2,
	2, 191, 211, 3, 2, 2, 2, 192, 194, 5, 28, 15, 2, 193, 195, 5, 34, 18, 2,
	194, 193, 3, 2, 2, 2, 195, 196, 3, 2, 2, 2, 196, 194, 3, 2, 2, 2, 196,
	197, 3, 2, 2, 2, 197, 199, 3, 2, 2, 2, 198, 200, 5, 40, 21, 2, 199, 198,
	3, 2, 2, 2, 199, 200, 3, 2, 2, 2, 200, 202, 3, 2, 2, 2, 201, 203, 5, 10,
	6, 2, 202, 201, 3, 2, 2, 2, 202, 203, 3, 2, 2, 2, 203, 205, 3, 2, 2, 2,
	204, 206, 5, 58, 30, 2, 205, 204, 3, 2, 2, 2, 205, 206, 3, 2, 2, 2, 206,
	208, 3, 2, 2, 2, 207, 209, 5, 8, 5, 2, 208, 207, 3, 2, 2, 2, 208, 209,
	3, 2, 2, 2, 209, 211, 3, 2, 2, 2, 210, 166, 3, 2, 2, 2, 210, 170, 3, 2,
	2, 2, 210, 174, 3, 2, 2, 2, 210, 192, 3, 2, 2, 2, 211, 5, 3, 2, 2, 2, 212,
	215, 5, 72, 37, 2, 213, 215, 7, 1050, 2, 2, 214, 212, 3, 2, 2, 2, 214,
	213, 3, 2, 2, 2, 215, 7, 3, 2, 2, 2, 216, 217, 7, 60, 2, 2, 217, 223, 7,
	168, 2, 2, 218, 219, 7, 95, 2, 2, 219, 220, 7, 73, 2, 2, 220, 221, 7, 523,
	2, 2, 221, 223, 7, 441, 2, 2, 222, 216, 3, 2, 2, 2, 222, 218, 3, 2, 2,
	2, 223, 9, 3, 2, 2, 2, 224, 225, 7, 113, 2, 2, 225, 226, 7, 18, 2, 2, 226,
	231, 5, 12, 7, 2, 227, 228, 7, 1026, 2, 2, 228, 230, 5, 12, 7, 2, 229,
	227, 3, 2, 2, 2, 230, 233, 3, 2, 2, 2, 231, 229, 3, 2, 2, 2, 231, 232,
	3, 2, 2, 2, 232, 11, 3, 2, 2, 2, 233, 231, 3, 2, 2, 2, 234, 236, 5, 132,
	67, 2, 235, 237, 9, 2, 2, 2, 236, 235, 3, 2, 2, 2, 236, 237, 3, 2, 2, 2,
	237, 13, 3, 2, 2, 2, 238, 243, 5, 16, 9, 2, 239, 240, 7, 1026, 2, 2, 240,
	242, 5, 16, 9, 2, 241, 239, 3, 2, 2, 2, 242, 245, 3, 2, 2, 2, 243, 241,
	3, 2, 2, 2, 243, 244, 3, 2, 2, 2, 244, 15, 3, 2, 2, 2, 245, 243, 3, 2,
	2, 2, 246, 250, 5, 18, 10, 2, 247, 249, 5, 24, 13, 2, 248, 247, 3, 2, 2,
	2, 249, 252, 3, 2, 2, 2, 250, 248, 3, 2, 2, 2, 250, 251, 3, 2, 2, 2, 251,
	264, 3, 2, 2, 2, 252, 250, 3, 2, 2, 2, 253, 254, 7, 1024, 2, 2, 254, 258,
	5, 18, 10, 2, 255, 257, 5, 24, 13, 2, 256, 255, 3, 2, 2, 2, 257, 260, 3,
	2, 2, 2, 258, 256, 3, 2, 2, 2, 258, 259, 3, 2, 2, 2, 259, 261, 3, 2, 2,
	2, 260, 258, 3, 2, 2, 2, 261, 262, 7, 1025, 2, 2, 262, 264, 3, 2, 2, 2,
	263, 246, 3, 2, 2, 2, 263, 253, 3, 2, 2, 2, 264, 17, 3, 2, 2, 2, 265, 271,
	5, 64, 33, 2, 266, 267, 7, 117, 2, 2, 267, 268, 7, 1024, 2, 2, 268, 269,
	5, 106, 54, 2, 269, 270, 7, 1025, 2, 2, 270, 272, 3, 2, 2, 2, 271, 266,
	3, 2, 2, 2, 271, 272, 3, 2, 2, 2, 272, 277, 3, 2, 2, 2, 273, 275, 7, 13,
	2, 2, 274, 273, 3, 2, 2, 2, 274, 275, 3, 2, 2, 2, 275, 276, 3, 2, 2, 2,
	276, 278, 5, 72, 37, 2, 277, 274, 3, 2, 2, 2, 277, 278, 3, 2, 2, 2, 278,
	287, 3, 2, 2, 2, 279, 284, 5, 20, 11, 2, 280, 281, 7, 1026, 2, 2, 281,
	283, 5, 20, 11, 2, 282, 280, 3, 2, 2, 2, 283, 286, 3, 2, 2, 2, 284, 282,
	3, 2, 2, 2, 284, 285, 3, 2, 2, 2, 285, 288, 3, 2, 2, 2, 286, 284, 3, 2,
	2, 2, 287, 279, 3, 2, 2, 2, 287, 288, 3, 2, 2, 2, 288, 306, 3, 2, 2, 2,
	289, 295, 5, 4, 3, 2, 290, 291, 7, 1024, 2, 2, 291, 292, 5, 4, 3, 2, 292,
	293, 7, 1025, 2, 2, 293, 295, 3, 2, 2, 2, 294, 289, 3, 2, 2, 2, 294, 290,
	3, 2, 2, 2, 295, 297, 3, 2, 2, 2, 296, 298, 7, 13, 2, 2, 297, 296, 3, 2,
	2, 2, 297, 298, 3, 2, 2, 2, 298, 299, 3, 2, 2, 2, 299, 300, 5, 72, 37,
	2, 300, 306, 3, 2, 2, 2, 301, 302, 7, 1024, 2, 2, 302, 303, 5, 14, 8, 2,
	303, 304, 7, 1025, 2, 2, 304, 306, 3, 2, 2, 2, 305, 265, 3, 2, 2, 2, 305,
	294, 3, 2, 2, 2, 305, 301, 3, 2, 2, 2, 306, 19, 3, 2, 2, 2, 307, 308, 9,
	3, 2, 2, 308, 311, 9, 4, 2, 2, 309, 310, 7, 60, 2, 2, 310, 312, 5, 22,
	12, 2, 311, 309, 3, 2, 2, 2, 311, 312, 3, 2, 2, 2, 312, 313, 3, 2, 2, 2,
	313, 314, 7, 1024, 2, 2, 314, 315, 5, 106, 54, 2, 315, 316, 7, 1025, 2,
	2, 316, 21, 3, 2, 2, 2, 317, 323, 7, 83, 2, 2, 318, 319, 7, 113, 2, 2,
	319, 323, 7, 18, 2, 2, 320, 321, 7, 68, 2, 2, 321, 323, 7, 18, 2, 2, 322,
	317, 3, 2, 2, 2, 322, 318, 3, 2, 2, 2, 322, 320, 3, 2, 2, 2, 323, 23, 3,
	2, 2, 2, 324, 326, 9, 5, 2, 2, 325, 324, 3, 2, 2, 2, 325, 326, 3, 2, 2,
	2, 326, 327, 3, 2, 2, 2, 327, 328, 7, 83, 2, 2, 328, 336, 5, 18, 10, 2,
	329, 330, 7, 108, 2, 2, 330, 337, 5, 132, 67, 2, 331, 332, 7, 171, 2, 2,
	332, 333, 7, 1024, 2, 2, 333, 334, 5, 106, 54, 2, 334, 335, 7, 1025, 2,
	2, 335, 337, 3, 2, 2, 2, 336, 329, 3, 2, 2, 2, 336, 331, 3, 2, 2, 2, 336,
	337, 3, 2, 2, 2, 337, 369, 3, 2, 2, 2, 338, 339, 7, 155, 2, 2, 339, 342,
	5, 18, 10, 2, 340, 341, 7, 108, 2, 2, 341, 343, 5, 132, 67, 2, 342, 340,
	3, 2, 2, 2, 342, 343, 3, 2, 2, 2, 343, 369, 3, 2, 2, 2, 344, 346, 9, 6,
	2, 2, 345, 347, 7, 115, 2, 2, 346, 345, 3, 2, 2, 2, 346, 347, 3, 2, 2,
	2, 347, 348, 3, 2, 2, 2, 348, 349, 7, 83, 2, 2, 349, 357, 5, 18, 10, 2,
	350, 351, 7, 108, 2, 2, 351, 358, 5, 132, 67, 2, 352, 353, 7, 171, 2, 2,
	353, 354, 7, 1024, 2, 2, 354, 355, 5, 106, 54, 2, 355, 356, 7, 1025, 2,
	2, 356, 358, 3, 2, 2, 2, 357, 350, 3, 2, 2, 2, 357, 352, 3, 2, 2, 2, 358,
	369, 3, 2, 2, 2, 359, 364, 7, 103, 2, 2, 360, 362, 9, 6, 2, 2, 361, 363,
	7, 115, 2, 2, 362, 361, 3, 2, 2, 2, 362, 363, 3, 2, 2, 2, 363, 365, 3,
	2, 2, 2, 364, 360, 3, 2, 2, 2, 364, 365, 3, 2, 2, 2, 365, 366, 3, 2, 2,
	2, 366, 367, 7, 83, 2, 2, 367, 369, 5, 18, 10, 2, 368, 325, 3, 2, 2, 2,
	368, 338, 3, 2, 2, 2, 368, 344, 3, 2, 2, 2, 368, 359, 3, 2, 2, 2, 369,
	25, 3, 2, 2, 2, 370, 371, 7, 1024, 2, 2, 371, 372, 5, 30, 16, 2, 372, 373,
	7, 1025, 2, 2, 373, 379, 3, 2, 2, 2, 374, 375, 7, 1024, 2, 2, 375, 376,
	5, 26, 14, 2, 376, 377, 7, 1025, 2, 2, 377, 379, 3, 2, 2, 2, 378, 370,
	3, 2, 2, 2, 378, 374, 3, 2, 2, 2, 379, 27, 3, 2, 2, 2, 380, 381, 7, 1024,
	2, 2, 381, 382, 5, 32, 17, 2, 382, 383, 7, 1025, 2, 2, 383, 389, 3, 2,
	2, 2, 384, 385, 7, 1024, 2, 2, 385, 386, 5, 28, 15, 2, 386, 387, 7, 1025,
	2, 2, 387, 389, 3, 2, 2, 2, 388, 380, 3, 2, 2, 2, 388, 384, 3, 2, 2, 2,
	389, 29, 3, 2, 2, 2, 390, 394, 7, 139, 2, 2, 391, 393, 5, 42, 22, 2, 392,
	391, 3, 2, 2, 2, 393, 396, 3, 2, 2, 2, 394, 392, 3, 2, 2, 2, 394, 395,
	3, 2, 2, 2, 395, 397, 3, 2, 2, 2, 396, 394, 3, 2, 2, 2, 397, 399, 5, 44,
	23, 2, 398, 400, 5, 48, 25, 2, 399, 398, 3, 2, 2, 2, 399, 400, 3, 2, 2,
	2, 400, 402, 3, 2, 2, 2, 401, 403, 5, 54, 28, 2, 402, 401, 3, 2, 2, 2,
	402, 403, 3, 2, 2, 2, 403, 405, 3, 2, 2, 2, 404, 406, 5, 10, 6, 2, 405,
	404, 3, 2, 2, 2, 405, 406, 3, 2, 2, 2, 406, 408, 3, 2, 2, 2, 407, 409,
	5, 58, 30, 2, 408, 407, 3, 2, 2, 2, 408, 409, 3, 2, 2, 2, 409, 431, 3,
	2, 2, 2, 410, 414, 7, 139, 2, 2, 411, 413, 5, 42, 22, 2, 412, 411, 3, 2,
	2, 2, 413, 416, 3, 2, 2, 2, 414, 412, 3, 2, 2, 2, 414, 415, 3, 2, 2, 2,
	415, 417, 3, 2, 2, 2, 416, 414, 3, 2, 2, 2, 417, 419, 5, 44, 23, 2, 418,
	420, 5, 54, 28, 2, 419, 418, 3, 2, 2, 2, 419, 420, 3, 2, 2, 2, 420, 422,
	3, 2, 2, 2, 421, 423, 5, 10, 6, 2, 422, 421, 3, 2, 2, 2, 422, 423, 3, 2,
	2, 2, 423, 425, 3, 2, 2, 2, 424, 426, 5, 58, 30, 2, 425, 424, 3, 2, 2,
	2, 425, 426, 3, 2, 2, 2, 426, 428, 3, 2, 2, 2, 427, 429, 5, 48, 25, 2,
	428, 427, 3, 2, 2, 2, 428, 429, 3, 2, 2, 2, 429, 431, 3, 2, 2, 2, 430,
	390, 3, 2, 2, 2, 430, 410, 3, 2, 2, 2, 431, 31, 3, 2, 2, 2, 432, 436, 7,
	139, 2, 2, 433, 435, 5, 42, 22, 2, 434, 433, 3, 2, 2, 2, 435, 438, 3, 2,
	2, 2, 436, 434, 3, 2, 2, 2, 436, 437, 3, 2, 2, 2, 437, 439, 3, 2, 2, 2,
	438, 436, 3, 2, 2, 2, 439, 441, 5, 44, 23, 2, 440, 442, 5, 54, 28, 2, 441,
	440, 3, 2, 2, 2, 441, 442, 3, 2, 2, 2, 442, 444, 3, 2, 2, 2, 443, 445,
	5, 10, 6, 2, 444, 443, 3, 2, 2, 2, 444, 445, 3, 2, 2, 2, 445, 447, 3, 2,
	2, 2, 446, 448, 5, 58, 30, 2, 447, 446, 3, 2, 2, 2, 447, 448, 3, 2, 2,
	2, 448, 33, 3, 2, 2, 2, 449, 451, 7, 164, 2, 2, 450, 452, 9, 7, 2, 2, 451,
	450, 3, 2, 2, 2, 451, 452, 3, 2, 2, 2, 452, 453, 3, 2, 2, 2, 453, 454,
	5, 28, 15, 2, 454, 35, 3, 2, 2, 2, 455, 457, 7, 164, 2, 2, 456, 458, 9,
	7, 2, 2, 457, 456, 3, 2, 2, 2, 457, 458, 3, 2, 2, 2, 458, 461, 3, 2, 2,
	2, 459, 462, 5, 32, 17, 2, 460, 462, 5, 28, 15, 2, 461, 459, 3, 2, 2, 2,
	461, 460, 3, 2, 2, 2, 462, 37, 3, 2, 2, 2, 463, 465, 7, 164, 2, 2, 464,
	466, 9, 7, 2, 2, 465, 464, 3, 2, 2, 2, 465, 466, 3, 2, 2, 2, 466, 469,
	3, 2, 2, 2, 467, 470, 5, 30, 16, 2, 468, 470, 5, 26, 14, 2, 469, 467, 3,
	2, 2, 2, 469, 468, 3, 2, 2, 2, 470, 39, 3, 2, 2, 2, 471, 473, 7, 164, 2,
	2, 472, 474, 9, 7, 2, 2, 473, 472, 3, 2, 2, 2, 473, 474, 3, 2, 2, 2, 474,
	475, 3, 2, 2, 2, 475, 476, 5, 26, 14, 2, 476, 41, 3, 2, 2, 2, 477, 486,
	9, 8, 2, 2, 478, 486, 7, 70, 2, 2, 479, 486, 7, 155, 2, 2, 480, 486, 7,
	151, 2, 2, 481, 486, 7, 149, 2, 2, 482, 486, 7, 538, 2, 2, 483, 486, 9,
	9, 2, 2, 484, 486, 7, 150, 2, 2, 485, 477, 3, 2, 2, 2, 485, 478, 3, 2,
	2, 2, 485, 479, 3, 2, 2, 2, 485, 480, 3, 2, 2, 2, 485, 481, 3, 2, 2, 2,
	485, 482, 3, 2, 2, 2, 485, 483, 3, 2, 2, 2, 485, 484, 3, 2, 2, 2, 486,
	43, 3, 2, 2, 2, 487, 490, 7, 1007, 2, 2, 488, 490, 5, 46, 24, 2, 489, 487,
	3, 2, 2, 2, 489, 488, 3, 2, 2, 2, 490, 495, 3, 2, 2, 2, 491, 492, 7, 1026,
	2, 2, 492, 494, 5, 46, 24, 2, 493, 491, 3, 2, 2, 2, 494, 497, 3, 2, 2,
	2, 495, 493, 3, 2, 2, 2, 495, 496, 3, 2, 2, 2, 496, 45, 3, 2, 2, 2, 497,
	495, 3, 2, 2, 2, 498, 499, 5, 62, 32, 2, 499, 500, 7, 1023, 2, 2, 500,
	501, 7, 1007, 2, 2, 501, 528, 3, 2, 2, 2, 502, 507, 5, 66, 34, 2, 503,
	505, 7, 13, 2, 2, 504, 503, 3, 2, 2, 2, 504, 505, 3, 2, 2, 2, 505, 506,
	3, 2, 2, 2, 506, 508, 5, 72, 37, 2, 507, 504, 3, 2, 2, 2, 507, 508, 3,
	2, 2, 2, 508, 528, 3, 2, 2, 2, 509, 514, 5, 112, 57, 2, 510, 512, 7, 13,
	2, 2, 511, 510, 3, 2, 2, 2, 511, 512, 3, 2, 2, 2, 512, 513, 3, 2, 2, 2,
	513, 515, 5, 72, 37, 2, 514, 511, 3, 2, 2, 2, 514, 515, 3, 2, 2, 2, 515,
	528, 3, 2, 2, 2, 516, 517, 7, 1050, 2, 2, 517, 519, 7, 998, 2, 2, 518,
	516, 3, 2, 2, 2, 518, 519, 3, 2, 2, 2, 519, 520, 3, 2, 2, 2, 520, 525,
	5, 132, 67, 2, 521, 523, 7, 13, 2, 2, 522, 521, 3, 2, 2, 2, 522, 523, 3,
	2, 2, 2, 523, 524, 3, 2, 2, 2, 524, 526, 5, 72, 37, 2, 525, 522, 3, 2,
	2, 2, 525, 526, 3, 2, 2, 2, 526, 528, 3, 2, 2, 2, 527, 498, 3, 2, 2, 2,
	527, 502, 3, 2, 2, 2, 527, 509, 3, 2, 2, 2, 527, 518, 3, 2, 2, 2, 528,
	47, 3, 2, 2, 2, 529, 530, 7, 80, 2, 2, 530, 535, 5, 6, 4, 2, 531, 532,
	7, 1026, 2, 2, 532, 534, 5, 6, 4, 2, 533, 531, 3, 2, 2, 2, 534, 537, 3,
	2, 2, 2, 535, 533, 3, 2, 2, 2, 535, 536, 3, 2, 2, 2, 536, 566, 3, 2, 2,
	2, 537, 535, 3, 2, 2, 2, 538, 539, 7, 80, 2, 2, 539, 540, 7, 337, 2, 2,
	540, 566, 7, 1039, 2, 2, 541, 542, 7, 80, 2, 2, 542, 543, 7, 116, 2, 2,
	543, 547, 7, 1039, 2, 2, 544, 545, 7, 24, 2, 2, 545, 546, 7, 140, 2, 2,
	546, 548, 5, 70, 36, 2, 547, 544, 3, 2, 2, 2, 547, 548, 3, 2, 2, 2, 548,
	555, 3, 2, 2, 2, 549, 551, 9, 10, 2, 2, 550, 552, 5, 50, 26, 2, 551, 550,
	3, 2, 2, 2, 552, 553, 3, 2, 2, 2, 553, 551, 3, 2, 2, 2, 553, 554, 3, 2,
	2, 2, 554, 556, 3, 2, 2, 2, 555, 549, 3, 2, 2, 2, 555, 556, 3, 2, 2, 2,
	556, 563, 3, 2, 2, 2, 557, 559, 7, 93, 2, 2, 558, 560, 5, 52, 27, 2, 559,
	558, 3, 2, 2, 2, 560, 561, 3, 2, 2, 2, 561, 559, 3, 2, 2, 2, 561, 562,
	3, 2, 2, 2, 562, 564, 3, 2, 2, 2, 563, 557, 3, 2, 2, 2, 563, 564, 3, 2,
	2, 2, 564, 566, 3, 2, 2, 2, 565, 529, 3, 2, 2, 2, 565, 538, 3, 2, 2, 2,
	565, 541, 3, 2, 2, 2, 566, 49, 3, 2, 2, 2, 567, 568, 7, 157, 2, 2, 568,
	569, 7, 18, 2, 2, 569, 580, 7, 1039, 2, 2, 570, 572, 7, 111, 2, 2, 571,
	570, 3, 2, 2, 2, 571, 572, 3, 2, 2, 2, 572, 573, 3, 2, 2, 2, 573, 574,
	7, 53, 2, 2, 574, 575, 7, 18, 2, 2, 575, 580, 7, 1039, 2, 2, 576, 577,
	7, 54, 2, 2, 577, 578, 7, 18, 2, 2, 578, 580, 7, 1039, 2, 2, 579, 567,
	3, 2, 2, 2, 579, 571, 3, 2, 2, 2, 579, 576, 3, 2, 2, 2, 580, 51, 3, 2,
	2, 2, 581, 582, 7, 154, 2, 2, 582, 583, 7, 18, 2, 2, 583, 588, 7, 1039,
	2, 2, 584, 585, 7, 157, 2, 2, 585, 586, 7, 18, 2, 2, 586, 588, 7, 1039,
	2, 2, 587, 581, 3, 2, 2, 2, 587, 584, 3, 2, 2, 2, 588, 53, 3, 2, 2, 2,
	589, 590, 7, 63, 2, 2, 590, 593, 5, 14, 8, 2, 591, 592, 7, 174, 2, 2, 592,
	594, 5, 132, 67, 2, 593, 591, 3, 2, 2, 2, 593, 594, 3, 2, 2, 2, 594, 609,
	3, 2, 2, 2, 595, 596, 7, 68, 2, 2, 596, 597, 7, 18, 2, 2, 597, 602, 5,
	56, 29, 2, 598, 599, 7, 1026, 2, 2, 599, 601, 5, 56, 29, 2, 600, 598, 3,
	2, 2, 2, 601, 604, 3, 2, 2, 2, 602, 600, 3, 2, 2, 2, 602, 603, 3, 2, 2,
	2, 603, 607, 3, 2, 2, 2, 604, 602, 3, 2, 2, 2, 605, 606, 7, 176, 2, 2,
	606, 608, 7, 513, 2, 2, 607, 605, 3, 2, 2, 2, 607, 608, 3, 2, 2, 2, 608,
	610, 3, 2, 2, 2, 609, 595, 3, 2, 2, 2, 609, 610, 3, 2, 2, 2, 610, 613,
	3, 2, 2, 2, 611, 612, 7, 69, 2, 2, 612, 614, 5, 132, 67, 2, 613, 611, 3,
	2, 2, 2, 613, 614, 3, 2, 2, 2, 614, 55, 3, 2, 2, 2, 615, 617, 5, 132, 67,
	2, 616, 618, 9, 2, 2, 2, 617, 616, 3, 2, 2, 2, 617, 618, 3, 2, 2, 2, 618,
	57, 3, 2, 2, 2, 619, 630, 7, 91, 2, 2, 620, 621, 5, 60, 31, 2, 621, 622,
	7, 1026, 2, 2, 622, 624, 3, 2, 2, 2, 623, 620, 3, 2, 2, 2, 623, 624, 3,
	2, 2, 2, 624, 625, 3, 2, 2, 2, 625, 631, 5, 60, 31, 2, 626, 627, 5, 60,
	31, 2, 627, 628, 7, 455, 2, 2, 628, 629, 5, 60, 31, 2, 629, 631, 3, 2,
	2, 2, 630, 623, 3, 2, 2, 2, 630, 626, 3, 2, 2, 2, 631, 59, 3, 2, 2, 2,
	632, 635, 5, 82, 42, 2, 633, 635, 5, 68, 35, 2, 634, 632, 3, 2, 2, 2, 634,
	633, 3, 2, 2, 2, 635, 61, 3, 2, 2, 2, 636, 640, 5, 72, 37, 2, 637, 641,
	7, 1046, 2, 2, 638, 639, 7, 1023, 2, 2, 639, 641, 5, 72, 37, 2, 640, 637,
	3, 2, 2, 2, 640, 638, 3, 2, 2, 2, 640, 641, 3, 2, 2, 2, 641, 63, 3, 2,
	2, 2, 642, 643, 5, 62, 32, 2, 643, 65, 3, 2, 2, 2, 644, 649, 5, 72, 37,
	2, 645, 647, 5, 78, 40, 2, 646, 648, 5, 78, 40, 2, 647, 646, 3, 2, 2, 2,
	647, 648, 3, 2, 2, 2, 648, 650, 3, 2, 2, 2, 649, 645, 3, 2, 2, 2, 649,
	650, 3, 2, 2, 2, 650, 67, 3, 2, 2, 2, 651, 652, 9, 11, 2, 2, 652, 69, 3,
	2, 2, 2, 653, 658, 7, 210, 2, 2, 654, 658, 5, 150, 76, 2, 655, 658, 7,
	1039, 2, 2, 656, 658, 7, 1036, 2, 2, 657, 653, 3, 2, 2, 2, 657, 654, 3,
	2, 2, 2, 657, 655, 3, 2, 2, 2, 657, 656, 3, 2, 2, 2, 658, 71, 3, 2, 2,
	2, 659, 663, 5, 76, 39, 2, 660, 663, 7, 1048, 2, 2, 661, 663, 7, 1036,
	2, 2, 662, 659, 3, 2, 2, 2, 662, 660, 3, 2, 2, 2, 662, 661, 3, 2, 2, 2,
	663, 73, 3, 2, 2, 2, 664, 665, 9, 12, 2, 2, 665, 75, 3, 2, 2, 2, 666, 676,
	7, 1047, 2, 2, 667, 676, 5, 150, 76, 2, 668, 676, 5, 152, 77, 2, 669, 676,
	5, 74, 38, 2, 670, 676, 5, 154, 78, 2, 671, 676, 5, 156, 79, 2, 672, 676,
	5, 158, 80, 2, 673, 676, 5, 160, 81, 2, 674, 676, 5, 162, 82, 2, 675, 666,
	3, 2, 2, 2, 675, 667, 3, 2, 2, 2, 675, 668, 3, 2, 2, 2, 675, 669, 3, 2,
	2, 2, 675, 670, 3, 2, 2, 2, 675, 671, 3, 2, 2, 2, 675, 672, 3, 2, 2, 2,
	675, 673, 3, 2, 2, 2, 675, 674, 3, 2, 2, 2, 676, 77, 3, 2, 2, 2, 677, 681,
	7, 1046, 2, 2, 678, 679, 7, 1023, 2, 2, 679, 681, 5, 72, 37, 2, 680, 677,
	3, 2, 2, 2, 680, 678, 3, 2, 2, 2, 681, 79, 3, 2, 2, 2, 682, 685, 5, 72,
	37, 2, 683, 685, 7, 1039, 2, 2, 684, 682, 3, 2, 2, 2, 684, 683, 3, 2, 2,
	2, 685, 81, 3, 2, 2, 2, 686, 687, 9, 13, 2, 2, 687, 83, 3, 2, 2, 2, 688,
	690, 7, 1045, 2, 2, 689, 688, 3, 2, 2, 2, 689, 690, 3, 2, 2, 2, 690, 691,
	3, 2, 2, 2, 691, 694, 7, 1039, 2, 2, 692, 694, 7, 1038, 2, 2, 693, 689,
	3, 2, 2, 2, 693, 692, 3, 2, 2, 2, 694, 696, 3, 2, 2, 2, 695, 697, 7, 1039,
	2, 2, 696, 695, 3, 2, 2, 2, 697, 698, 3, 2, 2, 2, 698, 696, 3, 2, 2, 2,
	698, 699, 3, 2, 2, 2, 699, 712, 3, 2, 2, 2, 700, 702, 7, 1045, 2, 2, 701,
	700, 3, 2, 2, 2, 701, 702, 3, 2, 2, 2, 702, 703, 3, 2, 2, 2, 703, 706,
	7, 1039, 2, 2, 704, 706, 7, 1038, 2, 2, 705, 701, 3, 2, 2, 2, 705, 704,
	3, 2, 2, 2, 706, 709, 3, 2, 2, 2, 707, 708, 7, 26, 2, 2, 708, 710, 5, 80,
	41, 2, 709, 707, 3, 2, 2, 2, 709, 710, 3, 2, 2, 2, 710, 712, 3, 2, 2, 2,
	711, 693, 3, 2, 2, 2, 711, 705, 3, 2, 2, 2, 712, 85, 3, 2, 2, 2, 713, 715,
	7, 104, 2, 2, 714, 713, 3, 2, 2, 2, 714, 715, 3, 2, 2, 2, 715, 716, 3,
	2, 2, 2, 716, 717, 9, 14, 2, 2, 717, 87, 3, 2, 2, 2, 718, 719, 9, 15, 2,
	2, 719, 89, 3, 2, 2, 2, 720, 722, 7, 1045, 2, 2, 721, 720, 3, 2, 2, 2,
	721, 722, 3, 2, 2, 2, 722, 723, 3, 2, 2, 2, 723, 724, 7, 1041, 2, 2, 724,
	91, 3, 2, 2, 2, 725, 735, 5, 84, 43, 2, 726, 735, 5, 82, 42, 2, 727, 728,
	7, 1012, 2, 2, 728, 735, 5, 82, 42, 2, 729, 735, 5, 90, 46, 2, 730, 735,
	5, 88, 45, 2, 731, 735, 7, 1042, 2, 2, 732, 735, 7, 1044, 2, 2, 733, 735,
	5, 86, 44, 2, 734, 725, 3, 2, 2, 2, 734, 726, 3, 2, 2, 2, 734, 727, 3,
	2, 2, 2, 734, 729, 3, 2, 2, 2, 734, 730, 3, 2, 2, 2, 734, 731, 3, 2, 2,
	2, 734, 732, 3, 2, 2, 2, 734, 733, 3, 2, 2, 2, 735, 93, 3, 2, 2, 2, 736,
	738, 9, 16, 2, 2, 737, 739, 5, 100, 51, 2, 738, 737, 3, 2, 2, 2, 738, 739,
	3, 2, 2, 2, 739, 741, 3, 2, 2, 2, 740, 742, 7, 210, 2, 2, 741, 740, 3,
	2, 2, 2, 741, 742, 3, 2, 2, 2, 742, 749, 3, 2, 2, 2, 743, 744, 7, 24, 2,
	2, 744, 747, 7, 140, 2, 2, 745, 747, 7, 735, 2, 2, 746, 743, 3, 2, 2, 2,
	746, 745, 3, 2, 2, 2, 747, 748, 3, 2, 2, 2, 748, 750, 5, 70, 36, 2, 749,
	746, 3, 2, 2, 2, 749, 750, 3, 2, 2, 2, 750, 753, 3, 2, 2, 2, 751, 752,
	7, 26, 2, 2, 752, 754, 5, 80, 41, 2, 753, 751, 3, 2, 2, 2, 753, 754, 3,
	2, 2, 2, 754, 864, 3, 2, 2, 2, 755, 756, 7, 209, 2, 2, 756, 758, 9, 17,
	2, 2, 757, 759, 5, 100, 51, 2, 758, 757, 3, 2, 2, 2, 758, 759, 3, 2, 2,
	2, 759, 761, 3, 2, 2, 2, 760, 762, 7, 210, 2, 2, 761, 760, 3, 2, 2, 2,
	761, 762, 3, 2, 2, 2, 762, 864, 3, 2, 2, 2, 763, 764, 7, 448, 2, 2, 764,
	766, 7, 207, 2, 2, 765, 767, 5, 100, 51, 2, 766, 765, 3, 2, 2, 2, 766,
	767, 3, 2, 2, 2, 767, 769, 3, 2, 2, 2, 768, 770, 7, 210, 2, 2, 769, 768,
	3, 2, 2, 2, 769, 770, 3, 2, 2, 2, 770, 864, 3, 2, 2, 2, 771, 772, 7, 209,
	2, 2, 772, 773, 9, 18, 2, 2, 773, 775, 7, 222, 2, 2, 774, 776, 5, 100,
	51, 2, 775, 774, 3, 2, 2, 2, 775, 776, 3, 2, 2, 2, 776, 778, 3, 2, 2, 2,
	777, 779, 7, 210, 2, 2, 778, 777, 3, 2, 2, 2, 778, 779, 3, 2, 2, 2, 779,
	864, 3, 2, 2, 2, 780, 782, 9, 19, 2, 2, 781, 783, 5, 100, 51, 2, 782, 781,
	3, 2, 2, 2, 782, 783, 3, 2, 2, 2, 783, 785, 3, 2, 2, 2, 784, 786, 9, 20,
	2, 2, 785, 784, 3, 2, 2, 2, 785, 786, 3, 2, 2, 2, 786, 788, 3, 2, 2, 2,
	787, 789, 7, 179, 2, 2, 788, 787, 3, 2, 2, 2, 788, 789, 3, 2, 2, 2, 789,
	864, 3, 2, 2, 2, 790, 792, 7, 192, 2, 2, 791, 793, 5, 102, 52, 2, 792,
	791, 3, 2, 2, 2, 792, 793, 3, 2, 2, 2, 793, 795, 3, 2, 2, 2, 794, 796,
	9, 20, 2, 2, 795, 794, 3, 2, 2, 2, 795, 796, 3, 2, 2, 2, 796, 798, 3, 2,
	2, 2, 797, 799, 7, 179, 2, 2, 798, 797, 3, 2, 2, 2, 798, 799, 3, 2, 2,
	2, 799, 864, 3, 2, 2, 2, 800, 802, 7, 193, 2, 2, 801, 803, 7, 194, 2, 2,
	802, 801, 3, 2, 2, 2, 802, 803, 3, 2, 2, 2, 803, 805, 3, 2, 2, 2, 804,
	806, 5, 102, 52, 2, 805, 804, 3, 2, 2, 2, 805, 806, 3, 2, 2, 2, 806, 808,
	3, 2, 2, 2, 807, 809, 9, 20, 2, 2, 808, 807, 3, 2, 2, 2, 808, 809, 3, 2,
	2, 2, 809, 811, 3, 2, 2, 2, 810, 812, 7, 179, 2, 2, 811, 810, 3, 2, 2,
	2, 811, 812, 3, 2, 2, 2, 812, 864, 3, 2, 2, 2, 813, 815, 9, 21, 2, 2, 814,
	816, 5, 104, 53, 2, 815, 814, 3, 2, 2, 2, 815, 816, 3, 2, 2, 2, 816, 818,
	3, 2, 2, 2, 817, 819, 9, 20, 2, 2, 818, 817, 3, 2, 2, 2, 818, 819, 3, 2,
	2, 2, 819, 821, 3, 2, 2, 2, 820, 822, 7, 179, 2, 2, 821, 820, 3, 2, 2,
	2, 821, 822, 3, 2, 2, 2, 822, 864, 3, 2, 2, 2, 823, 864, 9, 22, 2, 2, 824,
	826, 9, 23, 2, 2, 825, 827, 5, 100, 51, 2, 826, 825, 3, 2, 2, 2, 826, 827,
	3, 2, 2, 2, 827, 864, 3, 2, 2, 2, 828, 829, 9, 24, 2, 2, 829, 831, 5, 96,
	49, 2, 830, 832, 7, 210, 2, 2, 831, 830, 3, 2, 2, 2, 831, 832, 3, 2, 2,
	2, 832, 839, 3, 2, 2, 2, 833, 834, 7, 24, 2, 2, 834, 837, 7, 140, 2, 2,
	835, 837, 7, 735, 2, 2, 836, 833, 3, 2, 2, 2, 836, 835, 3, 2, 2, 2, 837,
	838, 3, 2, 2, 2, 838, 840, 5, 70, 36, 2, 839, 836, 3, 2, 2, 2, 839, 840,
	3, 2, 2, 2, 840, 864, 3, 2, 2, 2, 841, 864, 9, 25, 2, 2, 842, 844, 7, 215,
	2, 2, 843, 845, 7, 207, 2, 2, 844, 843, 3, 2, 2, 2, 844, 845, 3, 2, 2,
	2, 845, 847, 3, 2, 2, 2, 846, 848, 7, 210, 2, 2, 847, 846, 3, 2, 2, 2,
	847, 848, 3, 2, 2, 2, 848, 855, 3, 2, 2, 2, 849, 850, 7, 24, 2, 2, 850,
	853, 7, 140, 2, 2, 851, 853, 7, 735, 2, 2, 852, 849, 3, 2, 2, 2, 852, 851,
	3, 2, 2, 2, 853, 854, 3, 2, 2, 2, 854, 856, 5, 70, 36, 2, 855, 852, 3,
	2, 2, 2, 855, 856, 3, 2, 2, 2, 856, 859, 3, 2, 2, 2, 857, 858, 7, 26, 2,
	2, 858, 860, 5, 80, 41, 2, 859, 857, 3, 2, 2, 2, 859, 860, 3, 2, 2, 2,
	860, 864, 3, 2, 2, 2, 861, 862, 7, 215, 2, 2, 862, 864, 7, 211, 2, 2, 863,
	736, 3, 2, 2, 2, 863, 755, 3, 2, 2, 2, 863, 763, 3, 2, 2, 2, 863, 771,
	3, 2, 2, 2, 863, 780, 3, 2, 2, 2, 863, 790, 3, 2, 2, 2, 863, 800, 3, 2,
	2, 2, 863, 813, 3, 2, 2, 2, 863, 823, 3, 2, 2, 2, 863, 824, 3, 2, 2, 2,
	863, 828, 3, 2, 2, 2, 863, 841, 3, 2, 2, 2, 863, 842, 3, 2, 2, 2, 863,
	861, 3, 2, 2, 2, 864, 95, 3, 2, 2, 2, 865, 866, 7, 1024, 2, 2, 866, 871,
	7, 1039, 2, 2, 867, 868, 7, 1026, 2, 2, 868, 870, 7, 1039, 2, 2, 869, 867,
	3, 2, 2, 2, 870, 873, 3, 2, 2, 2, 871, 869, 3, 2, 2, 2, 871, 872, 3, 2,
	2, 2, 872, 874, 3, 2, 2, 2, 873, 871, 3, 2, 2, 2, 874, 875, 7, 1025, 2,
	2, 875, 97, 3, 2, 2, 2, 876, 878, 9, 26, 2, 2, 877, 879, 5, 100, 51, 2,
	878, 877, 3, 2, 2, 2, 878, 879, 3, 2, 2, 2, 879, 902, 3, 2, 2, 2, 880,
	882, 7, 206, 2, 2, 881, 883, 5, 100, 51, 2, 882, 881, 3, 2, 2, 2, 882,
	883, 3, 2, 2, 2, 883, 890, 3, 2, 2, 2, 884, 885, 7, 24, 2, 2, 885, 888,
	7, 140, 2, 2, 886, 888, 7, 735, 2, 2, 887, 884, 3, 2, 2, 2, 887, 886, 3,
	2, 2, 2, 888, 889, 3, 2, 2, 2, 889, 891, 5, 70, 36, 2, 890, 887, 3, 2,
	2, 2, 890, 891, 3, 2, 2, 2, 891, 902, 3, 2, 2, 2, 892, 902, 9, 27, 2, 2,
	893, 895, 7, 198, 2, 2, 894, 896, 5, 102, 52, 2, 895, 894, 3, 2, 2, 2,
	895, 896, 3, 2, 2, 2, 896, 902, 3, 2, 2, 2, 897, 899, 9, 20, 2, 2, 898,
	900, 7, 190, 2, 2, 899, 898, 3, 2, 2, 2, 899, 900, 3, 2, 2, 2, 900, 902,
	3, 2, 2, 2, 901, 876, 3, 2, 2, 2, 901, 880, 3, 2, 2, 2, 901, 892, 3, 2,
	2, 2, 901, 893, 3, 2, 2, 2, 901, 897, 3, 2, 2, 2, 902, 99, 3, 2, 2, 2,
	903, 904, 7, 1024, 2, 2, 904, 905, 5, 82, 42, 2, 905, 906, 7, 1025, 2,
	2, 906, 101, 3, 2, 2, 2, 907, 908, 7, 1024, 2, 2, 908, 909, 5, 82, 42,
	2, 909, 910, 7, 1026, 2, 2, 910, 911, 5, 82, 42, 2, 911, 912, 7, 1025,
	2, 2, 912, 103, 3, 2, 2, 2, 913, 914, 7, 1024, 2, 2, 914, 917, 5, 82, 42,
	2, 915, 916, 7, 1026, 2, 2, 916, 918, 5, 82, 42, 2, 917, 915, 3, 2, 2,
	2, 917, 918, 3, 2, 2, 2, 918, 919, 3, 2, 2, 2, 919, 920, 7, 1025, 2, 2,
	920, 105, 3, 2, 2, 2, 921, 926, 5, 72, 37, 2, 922, 923, 7, 1026, 2, 2,
	923, 925, 5, 72, 37, 2, 924, 922, 3, 2, 2, 2, 925, 928, 3, 2, 2, 2, 926,
	924, 3, 2, 2, 2, 926, 927, 3, 2, 2, 2, 927, 107, 3, 2, 2, 2, 928, 926,
	3, 2, 2, 2, 929, 934, 5, 132, 67, 2, 930, 931, 7, 1026, 2, 2, 931, 933,
	5, 132, 67, 2, 932, 930, 3, 2, 2, 2, 933, 936, 3, 2, 2, 2, 934, 932, 3,
	2, 2, 2, 934, 935, 3, 2, 2, 2, 935, 109, 3, 2, 2, 2, 936, 934, 3, 2, 2,
	2, 937, 951, 5, 156, 79, 2, 938, 951, 7, 205, 2, 2, 939, 951, 7, 224, 2,
	2, 940, 951, 7, 225, 2, 2, 941, 951, 7, 226, 2, 2, 942, 951, 7, 227, 2,
	2, 943, 951, 7, 228, 2, 2, 944, 951, 7, 229, 2, 2, 945, 951, 7, 230, 2,
	2, 946, 951, 7, 231, 2, 2, 947, 951, 7, 232, 2, 2, 948, 951, 7, 233, 2,
	2, 949, 951, 7, 234, 2, 2, 950, 937, 3, 2, 2, 2, 950, 938, 3, 2, 2, 2,
	950, 939, 3, 2, 2, 2, 950, 940, 3, 2, 2, 2, 950, 941, 3, 2, 2, 2, 950,
	942, 3, 2, 2, 2, 950, 943, 3, 2, 2, 2, 950, 944, 3, 2, 2, 2, 950, 945,
	3, 2, 2, 2, 950, 946, 3, 2, 2, 2, 950, 947, 3, 2, 2, 2, 950, 948, 3, 2,
	2, 2, 950, 949, 3, 2, 2, 2, 951, 111, 3, 2, 2, 2, 952, 970, 5, 114, 58,
	2, 953, 970, 5, 122, 62, 2, 954, 955, 5, 124, 63, 2, 955, 957, 7, 1024,
	2, 2, 956, 958, 5, 128, 65, 2, 957, 956, 3, 2, 2, 2, 957, 958, 3, 2, 2,
	2, 958, 959, 3, 2, 2, 2, 959, 960, 7, 1025, 2, 2, 960, 970, 3, 2, 2, 2,
	961, 962, 5, 62, 32, 2, 962, 964, 7, 1024, 2, 2, 963, 965, 5, 128, 65,
	2, 964, 963, 3, 2, 2, 2, 964, 965, 3, 2, 2, 2, 965, 966, 3, 2, 2, 2, 966,
	967, 7, 1025, 2, 2, 967, 970, 3, 2, 2, 2, 968, 970, 5, 126, 64, 2, 969,
	952, 3, 2, 2, 2, 969, 953, 3, 2, 2, 2, 969, 954, 3, 2, 2, 2, 969, 961,
	3, 2, 2, 2, 969, 968, 3, 2, 2, 2, 970, 113, 3, 2, 2, 2, 971, 1129, 9, 28,
	2, 2, 972, 973, 7, 31, 2, 2, 973, 974, 7, 1024, 2, 2, 974, 975, 5, 132,
	67, 2, 975, 976, 7, 1026, 2, 2, 976, 977, 5, 98, 50, 2, 977, 978, 7, 1025,
	2, 2, 978, 1129, 3, 2, 2, 2, 979, 980, 7, 31, 2, 2, 980, 981, 7, 1024,
	2, 2, 981, 982, 5, 132, 67, 2, 982, 983, 7, 171, 2, 2, 983, 984, 5, 70,
	36, 2, 984, 985, 7, 1025, 2, 2, 985, 1129, 3, 2, 2, 2, 986, 987, 7, 22,
	2, 2, 987, 988, 7, 1024, 2, 2, 988, 989, 5, 132, 67, 2, 989, 990, 7, 13,
	2, 2, 990, 991, 5, 98, 50, 2, 991, 992, 7, 1025, 2, 2, 992, 1129, 3, 2,
	2, 2, 993, 994, 7, 172, 2, 2, 994, 995, 7, 1024, 2, 2, 995, 996, 5, 66,
	34, 2, 996, 997, 7, 1025, 2, 2, 997, 1129, 3, 2, 2, 2, 998, 999, 7, 21,
	2, 2, 999, 1001, 5, 132, 67, 2, 1000, 1002, 5, 116, 59, 2, 1001, 1000,
	3, 2, 2, 2, 1002, 1003, 3, 2, 2, 2, 1003, 1001, 3, 2, 2, 2, 1003, 1004,
	3, 2, 2, 2, 1004, 1007, 3, 2, 2, 2, 1005, 1006, 7, 51, 2, 2, 1006, 1008,
	5, 130, 66, 2, 1007, 1005, 3, 2, 2, 2, 1007, 1008, 3, 2, 2, 2, 1008, 1009,
	3, 2, 2, 2, 1009, 1010, 7, 342, 2, 2, 1010, 1129, 3, 2, 2, 2, 1011, 1013,
	7, 21, 2, 2, 1012, 1014, 5, 116, 59, 2, 1013, 1012, 3, 2, 2, 2, 1014, 1015,
	3, 2, 2, 2, 1015, 1013, 3, 2, 2, 2, 1015, 1016, 3, 2, 2, 2, 1016, 1019,
	3, 2, 2, 2, 1017, 1018, 7, 51, 2, 2, 1018, 1020, 5, 130, 66, 2, 1019, 1017,
	3, 2, 2, 2, 1019, 1020, 3, 2, 2, 2, 1020, 1021, 3, 2, 2, 2, 1021, 1022,
	7, 342, 2, 2, 1022, 1129, 3, 2, 2, 2, 1023, 1024, 7, 206, 2, 2, 1024, 1025,
	7, 1024, 2, 2, 1025, 1028, 5, 128, 65, 2, 1026, 1027, 7, 171, 2, 2, 1027,
	1029, 5, 70, 36, 2, 1028, 1026, 3, 2, 2, 2, 1028, 1029, 3, 2, 2, 2, 1029,
	1030, 3, 2, 2, 2, 1030, 1031, 7, 1025, 2, 2, 1031, 1129, 3, 2, 2, 2, 1032,
	1033, 7, 264, 2, 2, 1033, 1036, 7, 1024, 2, 2, 1034, 1037, 5, 84, 43, 2,
	1035, 1037, 5, 132, 67, 2, 1036, 1034, 3, 2, 2, 2, 1036, 1035, 3, 2, 2,
	2, 1037, 1038, 3, 2, 2, 2, 1038, 1041, 7, 73, 2, 2, 1039, 1042, 5, 84,
	43, 2, 1040, 1042, 5, 132, 67, 2, 1041, 1039, 3, 2, 2, 2, 1041, 1040, 3,
	2, 2, 2, 1042, 1043, 3, 2, 2, 2, 1043, 1044, 7, 1025, 2, 2, 1044, 1129,
	3, 2, 2, 2, 1045, 1046, 9, 29, 2, 2, 1046, 1049, 7, 1024, 2, 2, 1047, 1050,
	5, 84, 43, 2, 1048, 1050, 5, 132, 67, 2, 1049, 1047, 3, 2, 2, 2, 1049,
	1048, 3, 2, 2, 2, 1050, 1051, 3, 2, 2, 2, 1051, 1054, 7, 63, 2, 2, 1052,
	1055, 5, 82, 42, 2, 1053, 1055, 5, 132, 67, 2, 1054, 1052, 3, 2, 2, 2,
	1054, 1053, 3, 2, 2, 2, 1055, 1061, 3, 2, 2, 2, 1056, 1059, 7, 60, 2, 2,
	1057, 1060, 5, 82, 42, 2, 1058, 1060, 5, 132, 67, 2, 1059, 1057, 3, 2,
	2, 2, 1059, 1058, 3, 2, 2, 2, 1060, 1062, 3, 2, 2, 2, 1061, 1056, 3, 2,
	2, 2, 1061, 1062, 3, 2, 2, 2, 1062, 1063, 3, 2, 2, 2, 1063, 1064, 7, 1025,
	2, 2, 1064, 1129, 3, 2, 2, 2, 1065, 1066, 7, 268, 2, 2, 1066, 1067, 7,
	1024, 2, 2, 1067, 1070, 9, 30, 2, 2, 1068, 1071, 5, 84, 43, 2, 1069, 1071,
	5, 132, 67, 2, 1070, 1068, 3, 2, 2, 2, 1070, 1069, 3, 2, 2, 2, 1070, 1071,
	3, 2, 2, 2, 1071, 1072, 3, 2, 2, 2, 1072, 1075, 7, 63, 2, 2, 1073, 1076,
	5, 84, 43, 2, 1074, 1076, 5, 132, 67, 2, 1075, 1073, 3, 2, 2, 2, 1075,
	1074, 3, 2, 2, 2, 1076, 1077, 3, 2, 2, 2, 1077, 1078, 7, 1025, 2, 2, 1078,
	1129, 3, 2, 2, 2, 1079, 1080, 7, 268, 2, 2, 1080, 1083, 7, 1024, 2, 2,
	1081, 1084, 5, 84, 43, 2, 1082, 1084, 5, 132, 67, 2, 1083, 1081, 3, 2,
	2, 2, 1083, 1082, 3, 2, 2, 2, 1084, 1085, 3, 2, 2, 2, 1085, 1088, 7, 63,
	2, 2, 1086, 1089, 5, 84, 43, 2, 1087, 1089, 5, 132, 67, 2, 1088, 1086,
	3, 2, 2, 2, 1088, 1087, 3, 2, 2, 2, 1089, 1090, 3, 2, 2, 2, 1090, 1091,
	7, 1025, 2, 2, 1091, 1129, 3, 2, 2, 2, 1092, 1093, 7, 993, 2, 2, 1093,
	1096, 7, 1024, 2, 2, 1094, 1097, 5, 84, 43, 2, 1095, 1097, 5, 132, 67,
	2, 1096, 1094, 3, 2, 2, 2, 1096, 1095, 3, 2, 2, 2, 1097, 1104, 3, 2, 2,
	2, 1098, 1099, 7, 13, 2, 2, 1099, 1100, 9, 31, 2, 2, 1100, 1101, 7, 1024,
	2, 2, 1101, 1102, 5, 82, 42, 2, 1102, 1103, 7, 1025, 2, 2, 1103, 1105,
	3, 2, 2, 2, 1104, 1098, 3, 2, 2, 2, 1104, 1105, 3, 2, 2, 2, 1105, 1107,
	3, 2, 2, 2, 1106, 1108, 5, 118, 60, 2, 1107, 1106, 3, 2, 2, 2, 1107, 1108,
	3, 2, 2, 2, 1108, 1109, 3, 2, 2, 2, 1109, 1110, 7, 1025, 2, 2, 1110, 1129,
	3, 2, 2, 2, 1111, 1112, 7, 261, 2, 2, 1112, 1113, 7, 1024, 2, 2, 1113,
	1114, 5, 110, 56, 2, 1114, 1117, 7, 63, 2, 2, 1115, 1118, 5, 84, 43, 2,
	1116, 1118, 5, 132, 67, 2, 1117, 1115, 3, 2, 2, 2, 1117, 1116, 3, 2, 2,
	2, 1118, 1119, 3, 2, 2, 2, 1119, 1120, 7, 1025, 2, 2, 1120, 1129, 3, 2,
	2, 2, 1121, 1122, 7, 793, 2, 2, 1122, 1123, 7, 1024, 2, 2, 1123, 1124,
	9, 32, 2, 2, 1124, 1125, 7, 1026, 2, 2, 1125, 1126, 5, 84, 43, 2, 1126,
	1127, 7, 1025, 2, 2, 1127, 1129, 3, 2, 2, 2, 1128, 971, 3, 2, 2, 2, 1128,
	972, 3, 2, 2, 2, 1128, 979, 3, 2, 2, 2, 1128, 986, 3, 2, 2, 2, 1128, 993,
	3, 2, 2, 2, 1128, 998, 3, 2, 2, 2, 1128, 1011, 3, 2, 2, 2, 1128, 1023,
	3, 2, 2, 2, 1128, 1032, 3, 2, 2, 2, 1128, 1045, 3, 2, 2, 2, 1128, 1065,
	3, 2, 2, 2, 1128, 1079, 3, 2, 2, 2, 1128, 1092, 3, 2, 2, 2, 1128, 1111,
	3, 2, 2, 2, 1128, 1121, 3, 2, 2, 2, 1129, 115, 3, 2, 2, 2, 1130, 1131,
	7, 173, 2, 2, 1131, 1132, 5, 130, 66, 2, 1132, 1133, 7, 158, 2, 2, 1133,
	1134, 5, 130, 66, 2, 1134, 117, 3, 2, 2, 2, 1135, 1136, 7, 402, 2, 2, 1136,
	1141, 5, 120, 61, 2, 1137, 1138, 7, 1026, 2, 2, 1138, 1140, 5, 120, 61,
	2, 1139, 1137, 3, 2, 2, 2, 1140, 1143, 3, 2, 2, 2, 1141, 1139, 3, 2, 2,
	2, 1141, 1142, 3, 2, 2, 2, 1142, 1150, 3, 2, 2, 2, 1143, 1141, 3, 2, 2,
	2, 1144, 1145, 7, 402, 2, 2, 1145, 1146, 5, 82, 42, 2, 1146, 1147, 7, 1012,
	2, 2, 1147, 1148, 5, 82, 42, 2, 1148, 1150, 3, 2, 2, 2, 1149, 1135, 3,
	2, 2, 2, 1149, 1144, 3, 2, 2, 2, 1150, 119, 3, 2, 2, 2, 1151, 1153, 5,
	82, 42, 2, 1152, 1154, 9, 33, 2, 2, 1153, 1152, 3, 2, 2, 2, 1153, 1154,
	3, 2, 2, 2, 1154, 121, 3, 2, 2, 2, 1155, 1156, 9, 34, 2, 2, 1156, 1158,
	7, 1024, 2, 2, 1157, 1159, 9, 7, 2, 2, 1158, 1157, 3, 2, 2, 2, 1158, 1159,
	3, 2, 2, 2, 1159, 1160, 3, 2, 2, 2, 1160, 1161, 5, 130, 66, 2, 1161, 1162,
	7, 1025, 2, 2, 1162, 1212, 3, 2, 2, 2, 1163, 1164, 7, 241, 2, 2, 1164,
	1170, 7, 1024, 2, 2, 1165, 1171, 7, 1007, 2, 2, 1166, 1168, 7, 8, 2, 2,
	1167, 1166, 3, 2, 2, 2, 1167, 1168, 3, 2, 2, 2, 1168, 1169, 3, 2, 2, 2,
	1169, 1171, 5, 130, 66, 2, 1170, 1165, 3, 2, 2, 2, 1170, 1167, 3, 2, 2,
	2, 1171, 1172, 3, 2, 2, 2, 1172, 1212, 7, 1025, 2, 2, 1173, 1174, 7, 241,
	2, 2, 1174, 1175, 7, 1024, 2, 2, 1175, 1176, 7, 47, 2, 2, 1176, 1177, 5,
	128, 65, 2, 1177, 1178, 7, 1025, 2, 2, 1178, 1212, 3, 2, 2, 2, 1179, 1180,
	9, 35, 2, 2, 1180, 1182, 7, 1024, 2, 2, 1181, 1183, 7, 8, 2, 2, 1182, 1181,
	3, 2, 2, 2, 1182, 1183, 3, 2, 2, 2, 1183, 1184, 3, 2, 2, 2, 1184, 1185,
	5, 130, 66, 2, 1185, 1186, 7, 1025, 2, 2, 1186, 1212, 3, 2, 2, 2, 1187,
	1188, 7, 242, 2, 2, 1188, 1190, 7, 1024, 2, 2, 1189, 1191, 7, 47, 2, 2,
	1190, 1189, 3, 2, 2, 2, 1190, 1191, 3, 2, 2, 2, 1191, 1192, 3, 2, 2, 2,
	1192, 1203, 5, 128, 65, 2, 1193, 1194, 7, 113, 2, 2, 1194, 1195, 7, 18,
	2, 2, 1195, 1200, 5, 12, 7, 2, 1196, 1197, 7, 1026, 2, 2, 1197, 1199, 5,
	12, 7, 2, 1198, 1196, 3, 2, 2, 2, 1199, 1202, 3, 2, 2, 2, 1200, 1198, 3,
	2, 2, 2, 1200, 1201, 3, 2, 2, 2, 1201, 1204, 3, 2, 2, 2, 1202, 1200, 3,
	2, 2, 2, 1203, 1193, 3, 2, 2, 2, 1203, 1204, 3, 2, 2, 2, 1204, 1207, 3,
	2, 2, 2, 1205, 1206, 7, 141, 2, 2, 1206, 1208, 7, 1039, 2, 2, 1207, 1205,
	3, 2, 2, 2, 1207, 1208, 3, 2, 2, 2, 1208, 1209, 3, 2, 2, 2, 1209, 1210,
	7, 1025, 2, 2, 1210, 1212, 3, 2, 2, 2, 1211, 1155, 3, 2, 2, 2, 1211, 1163,
	3, 2, 2, 2, 1211, 1173, 3, 2, 2, 2, 1211, 1179, 3, 2, 2, 2, 1211, 1187,
	3, 2, 2, 2, 1212, 123, 3, 2, 2, 2, 1213, 1237, 5, 162, 82, 2, 1214, 1237,
	7, 642, 2, 2, 1215, 1237, 7, 257, 2, 2, 1216, 1237, 7, 253, 2, 2, 1217,
	1237, 7, 254, 2, 2, 1218, 1237, 7, 255, 2, 2, 1219, 1237, 7, 258, 2, 2,
	1220, 1237, 7, 259, 2, 2, 1221, 1237, 7, 260, 2, 2, 1222, 1237, 7, 71,
	2, 2, 1223, 1237, 7, 78, 2, 2, 1224, 1237, 7, 256, 2, 2, 1225, 1237, 7,
	262, 2, 2, 1226, 1237, 7, 438, 2, 2, 1227, 1237, 7, 263, 2, 2, 1228, 1237,
	7, 129, 2, 2, 1229, 1237, 7, 265, 2, 2, 1230, 1237, 7, 266, 2, 2, 1231,
	1237, 7, 267, 2, 2, 1232, 1237, 7, 268, 2, 2, 1233, 1237, 7, 269, 2, 2,
	1234, 1237, 7, 270, 2, 2, 1235, 1237, 7, 271, 2, 2, 1236, 1213, 3, 2, 2,
	2, 1236, 1214, 3, 2, 2, 2, 1236, 1215, 3, 2, 2, 2, 1236, 1216, 3, 2, 2,
	2, 1236, 1217, 3, 2, 2, 2, 1236, 1218, 3, 2, 2, 2, 1236, 1219, 3, 2, 2,
	2, 1236, 1220, 3, 2, 2, 2, 1236, 1221, 3, 2, 2, 2, 1236, 1222, 3, 2, 2,
	2, 1236, 1223, 3, 2, 2, 2, 1236, 1224, 3, 2, 2, 2, 1236, 1225, 3, 2, 2,
	2, 1236, 1226, 3, 2, 2, 2, 1236, 1227, 3, 2, 2, 2, 1236, 1228, 3, 2, 2,
	2, 1236, 1229, 3, 2, 2, 2, 1236, 1230, 3, 2, 2, 2, 1236, 1231, 3, 2, 2,
	2, 1236, 1232, 3, 2, 2, 2, 1236, 1233, 3, 2, 2, 2, 1236, 1234, 3, 2, 2,
	2, 1236, 1235, 3, 2, 2, 2, 1237, 125, 3, 2, 2, 2, 1238, 1239, 9, 36, 2,
	2, 1239, 1240, 7, 1024, 2, 2, 1240, 1241, 5, 130, 66, 2, 1241, 1242, 7,
	1025, 2, 2, 1242, 127, 3, 2, 2, 2, 1243, 1248, 5, 130, 66, 2, 1244, 1245,
	7, 1026, 2, 2, 1245, 1247, 5, 130, 66, 2, 1246, 1244, 3, 2, 2, 2, 1247,
	1250, 3, 2, 2, 2, 1248, 1246, 3, 2, 2, 2, 1248, 1249, 3, 2, 2, 2, 1249,
	129, 3, 2, 2, 2, 1250, 1248, 3, 2, 2, 2, 1251, 1256, 5, 92, 47, 2, 1252,
	1256, 5, 66, 34, 2, 1253, 1256, 5, 112, 57, 2, 1254, 1256, 5, 132, 67,
	2, 1255, 1251, 3, 2, 2, 2, 1255, 1252, 3, 2, 2, 2, 1255, 1253, 3, 2, 2,
	2, 1255, 1254, 3, 2, 2, 2, 1256, 131, 3, 2, 2, 2, 1257, 1258, 8, 67, 1,
	2, 1258, 1259, 9, 37, 2, 2, 1259, 1269, 5, 132, 67, 6, 1260, 1261, 5, 134,
	68, 2, 1261, 1263, 7, 81, 2, 2, 1262, 1264, 7, 104, 2, 2, 1263, 1262, 3,
	2, 2, 2, 1263, 1264, 3, 2, 2, 2, 1264, 1265, 3, 2, 2, 2, 1265, 1266, 9,
	38, 2, 2, 1266, 1269, 3, 2, 2, 2, 1267, 1269, 5, 134, 68, 2, 1268, 1257,
	3, 2, 2, 2, 1268, 1260, 3, 2, 2, 2, 1268, 1267, 3, 2, 2, 2, 1269, 1276,
	3, 2, 2, 2, 1270, 1271, 12, 5, 2, 2, 1271, 1272, 5, 142, 72, 2, 1272, 1273,
	5, 132, 67, 6, 1273, 1275, 3, 2, 2, 2, 1274, 1270, 3, 2, 2, 2, 1275, 1278,
	3, 2, 2, 2, 1276, 1274, 3, 2, 2, 2, 1276, 1277, 3, 2, 2, 2, 1277, 133,
	3, 2, 2, 2, 1278, 1276, 3, 2, 2, 2, 1279, 1282, 8, 68, 1, 2, 1280, 1281,
	7, 1050, 2, 2, 1281, 1283, 7, 998, 2, 2, 1282, 1280, 3, 2, 2, 2, 1282,
	1283, 3, 2, 2, 2, 1283, 1284, 3, 2, 2, 2, 1284, 1285, 5, 136, 69, 2, 1285,
	1350, 3, 2, 2, 2, 1286, 1287, 12, 10, 2, 2, 1287, 1288, 5, 140, 71, 2,
	1288, 1289, 5, 134, 68, 11, 1289, 1349, 3, 2, 2, 2, 1290, 1292, 12, 8,
	2, 2, 1291, 1293, 7, 104, 2, 2, 1292, 1291, 3, 2, 2, 2, 1292, 1293, 3,
	2, 2, 2, 1293, 1294, 3, 2, 2, 2, 1294, 1295, 7, 16, 2, 2, 1295, 1296, 5,
	134, 68, 2, 1296, 1297, 7, 12, 2, 2, 1297, 1298, 5, 134, 68, 9, 1298, 1349,
	3, 2, 2, 2, 1299, 1300, 12, 7, 2, 2, 1300, 1301, 7, 533, 2, 2, 1301, 1302,
	7, 90, 2, 2, 1302, 1349, 5, 134, 68, 8, 1303, 1305, 12, 5, 2, 2, 1304,
	1306, 7, 104, 2, 2, 1305, 1304, 3, 2, 2, 2, 1305, 1306, 3, 2, 2, 2, 1306,
	1307, 3, 2, 2, 2, 1307, 1308, 9, 39, 2, 2, 1308, 1349, 5, 134, 68, 6, 1309,
	1311, 12, 12, 2, 2, 1310, 1312, 7, 104, 2, 2, 1311, 1310, 3, 2, 2, 2, 1311,
	1312, 3, 2, 2, 2, 1312, 1313, 3, 2, 2, 2, 1313, 1314, 7, 73, 2, 2, 1314,
	1317, 7, 1024, 2, 2, 1315, 1318, 5, 4, 3, 2, 1316, 1318, 5, 108, 55, 2,
	1317, 1315, 3, 2, 2, 2, 1317, 1316, 3, 2, 2, 2, 1318, 1319, 3, 2, 2, 2,
	1319, 1320, 7, 1025, 2, 2, 1320, 1349, 3, 2, 2, 2, 1321, 1322, 12, 11,
	2, 2, 1322, 1323, 7, 81, 2, 2, 1323, 1349, 5, 86, 44, 2, 1324, 1325, 12,
	9, 2, 2, 1325, 1326, 5, 140, 71, 2, 1326, 1327, 9, 40, 2, 2, 1327, 1328,
	7, 1024, 2, 2, 1328, 1329, 5, 4, 3, 2, 1329, 1330, 7, 1025, 2, 2, 1330,
	1349, 3, 2, 2, 2, 1331, 1333, 12, 6, 2, 2, 1332, 1334, 7, 104, 2, 2, 1333,
	1332, 3, 2, 2, 2, 1333, 1334, 3, 2, 2, 2, 1334, 1335, 3, 2, 2, 2, 1335,
	1336, 7, 90, 2, 2, 1336, 1339, 5, 134, 68, 2, 1337, 1338, 7, 348, 2, 2,
	1338, 1340, 7, 1039, 2, 2, 1339, 1337, 3, 2, 2, 2, 1339, 1340, 3, 2, 2,
	2, 1340, 1349, 3, 2, 2, 2, 1341, 1342, 12, 3, 2, 2, 1342, 1343, 7, 435,
	2, 2, 1343, 1344, 7, 456, 2, 2, 1344, 1345, 7, 1024, 2, 2, 1345, 1346,
	5, 134, 68, 2, 1346, 1347, 7, 1025, 2, 2, 1347, 1349, 3, 2, 2, 2, 1348,
	1286, 3, 2, 2, 2, 1348, 1290, 3, 2, 2, 2, 1348, 1299, 3, 2, 2, 2, 1348,
	1303, 3, 2, 2, 2, 1348, 1309, 3, 2, 2, 2, 1348, 1321, 3, 2, 2, 2, 1348,
	1324, 3, 2, 2, 2, 1348, 1331, 3, 2, 2, 2, 1348, 1341, 3, 2, 2, 2, 1349,
	1352, 3, 2, 2, 2, 1350, 1348, 3, 2, 2, 2, 1350, 1351, 3, 2, 2, 2, 1351,
	135, 3, 2, 2, 2, 1352, 1350, 3, 2, 2, 2, 1353, 1354, 8, 69, 1, 2, 1354,
	1399, 5, 92, 47, 2, 1355, 1399, 5, 66, 34, 2, 1356, 1399, 5, 112, 57, 2,
	1357, 1399, 5, 68, 35, 2, 1358, 1359, 5, 138, 70, 2, 1359, 1360, 5, 136,
	69, 12, 1360, 1399, 3, 2, 2, 2, 1361, 1362, 7, 210, 2, 2, 1362, 1399, 5,
	136, 69, 11, 1363, 1364, 7, 1024, 2, 2, 1364, 1369, 5, 132, 67, 2, 1365,
	1366, 7, 1026, 2, 2, 1366, 1368, 5, 132, 67, 2, 1367, 1365, 3, 2, 2, 2,
	1368, 1371, 3, 2, 2, 2, 1369, 1367, 3, 2, 2, 2, 1369, 1370, 3, 2, 2, 2,
	1370, 1372, 3, 2, 2, 2, 1371, 1369, 3, 2, 2, 2, 1372, 1373, 7, 1025, 2,
	2, 1373, 1399, 3, 2, 2, 2, 1374, 1375, 7, 515, 2, 2, 1375, 1376, 7, 1024,
	2, 2, 1376, 1379, 5, 132, 67, 2, 1377, 1378, 7, 1026, 2, 2, 1378, 1380,
	5, 132, 67, 2, 1379, 1377, 3, 2, 2, 2, 1380, 1381, 3, 2, 2, 2, 1381, 1379,
	3, 2, 2, 2, 1381, 1382, 3, 2, 2, 2, 1382, 1383, 3, 2, 2, 2, 1383, 1384,
	7, 1025, 2, 2, 1384, 1399, 3, 2, 2, 2, 1385, 1386, 7, 55, 2, 2, 1386, 1387,
	7, 1024, 2, 2, 1387, 1388, 5, 4, 3, 2, 1388, 1389, 7, 1025, 2, 2, 1389,
	1399, 3, 2, 2, 2, 1390, 1391, 7, 1024, 2, 2, 1391, 1392, 5, 4, 3, 2, 1392,
	1393, 7, 1025, 2, 2, 1393, 1399, 3, 2, 2, 2, 1394, 1395, 7, 79, 2, 2, 1395,
	1396, 5, 132, 67, 2, 1396, 1397, 5, 110, 56, 2, 1397, 1399, 3, 2, 2, 2,
	1398, 1353, 3, 2, 2, 2, 1398, 1355, 3, 2, 2, 2, 1398, 1356, 3, 2, 2, 2,
	1398, 1357, 3, 2, 2, 2, 1398, 1358, 3, 2, 2, 2, 1398, 1361, 3, 2, 2, 2,
	1398, 1363, 3, 2, 2, 2, 1398, 1374, 3, 2, 2, 2, 1398, 1385, 3, 2, 2, 2,
	1398, 1390, 3, 2, 2, 2, 1398, 1394, 3, 2, 2, 2, 1399, 1417, 3, 2, 2, 2,
	1400, 1401, 12, 5, 2, 2, 1401, 1402, 5, 144, 73, 2, 1402, 1403, 5, 136,
	69, 6, 1403, 1416, 3, 2, 2, 2, 1404, 1405, 12, 4, 2, 2, 1405, 1406, 5,
	146, 74, 2, 1406, 1407, 5, 136, 69, 5, 1407, 1416, 3, 2, 2, 2, 1408, 1409,
	12, 3, 2, 2, 1409, 1410, 5, 148, 75, 2, 1410, 1411, 5, 136, 69, 4, 1411,
	1416, 3, 2, 2, 2, 1412, 1413, 12, 14, 2, 2, 1413, 1414, 7, 26, 2, 2, 1414,
	1416, 5, 80, 41, 2, 1415, 1400, 3, 2, 2, 2, 1415, 1404, 3, 2, 2, 2, 1415,
	1408, 3, 2, 2, 2, 1415, 1412, 3, 2, 2, 2, 1416, 1419, 3, 2, 2, 2, 1417,
	1415, 3, 2, 2, 2, 1417, 1418, 3, 2, 2, 2, 1418, 137, 3, 2, 2, 2, 1419,
	1417, 3, 2, 2, 2, 1420, 1421, 9, 41, 2, 2, 1421, 139, 3, 2, 2, 2, 1422,
	1437, 7, 1015, 2, 2, 1423, 1437, 7, 1016, 2, 2, 1424, 1437, 7, 1017, 2,
	2, 1425, 1426, 7, 1017, 2, 2, 1426, 1437, 7, 1015, 2, 2, 1427, 1428, 7,
	1016, 2, 2, 1428, 1437, 7, 1015, 2, 2, 1429, 1430, 7, 1017, 2, 2, 1430,
	1437, 7, 1016, 2, 2, 1431, 1432, 7, 1018, 2, 2, 1432, 1437, 7, 1015, 2,
	2, 1433, 1434, 7, 1017, 2, 2, 1434, 1435, 7, 1015, 2, 2, 1435, 1437, 7,
	1016, 2, 2, 1436, 1422, 3, 2, 2, 2, 1436, 1423, 3, 2, 2, 2, 1436, 1424,
	3, 2, 2, 2, 1436, 1425, 3, 2, 2, 2, 1436, 1427, 3, 2, 2, 2, 1436, 1429,
	3, 2, 2, 2, 1436, 1431, 3, 2, 2, 2, 1436, 1433, 3, 2, 2, 2, 1437, 141,
	3, 2, 2, 2, 1438, 1446, 7, 12, 2, 2, 1439, 1440, 7, 1021, 2, 2, 1440, 1446,
	7, 1021, 2, 2, 1441, 1446, 7, 178, 2, 2, 1442, 1446, 7, 112, 2, 2, 1443,
	1444, 7, 1020, 2, 2, 1444, 1446, 7, 1020, 2, 2, 1445, 1438, 3, 2, 2, 2,
	1445, 1439, 3, 2, 2, 2, 1445, 1441, 3, 2, 2, 2, 1445, 1442, 3, 2, 2, 2,
	1445, 1443, 3, 2, 2, 2, 1446, 143, 3, 2, 2, 2, 1447, 1448, 7, 1017, 2,
	2, 1448, 1455, 7, 1017, 2, 2, 1449, 1450, 7, 1016, 2, 2, 1450, 1455, 7,
	1016, 2, 2, 1451, 1455, 7, 1021, 2, 2, 1452, 1455, 7, 1022, 2, 2, 1453,
	1455, 7, 1020, 2, 2, 1454, 1447, 3, 2, 2, 2, 1454, 1449, 3, 2, 2, 2, 1454,
	1451, 3, 2, 2, 2, 1454, 1452, 3, 2, 2, 2, 1454, 1453, 3, 2, 2, 2, 1455,
	145, 3, 2, 2, 2, 1456, 1457, 9, 42, 2, 2, 1457, 147, 3, 2, 2, 2, 1458,
	1459, 7, 1012, 2, 2, 1459, 1464, 7, 1016, 2, 2, 1460, 1461, 7, 1012, 2,
	2, 1461, 1462, 7, 1016, 2, 2, 1462, 1464, 7, 1016, 2, 2, 1463, 1458, 3,
	2, 2, 2, 1463, 1460, 3, 2, 2, 2, 1464, 149, 3, 2, 2, 2, 1465, 1466, 9,
	43, 2, 2, 1466, 151, 3, 2, 2, 2, 1467, 1468, 9, 44, 2, 2, 1468, 153, 3,
	2, 2, 2, 1469, 1470, 9, 45, 2, 2, 1470, 155, 3, 2, 2, 2, 1471, 1472, 9,
	46, 2, 2, 1472, 157, 3, 2, 2, 2, 1473, 1474, 9, 47, 2, 2, 1474, 159, 3,
	2, 2, 2, 1475, 1476, 9, 48, 2, 2, 1476, 161, 3, 2, 2, 2, 1477, 1478, 9,
	49, 2, 2, 1478, 163, 3, 2, 2, 2, 217, 168, 172, 178, 181, 184, 187, 190,
	196, 199, 202, 205, 208, 210, 214, 222, 231, 236, 243, 250, 258, 263, 271,
	274, 277, 284, 287, 294, 297, 305, 311, 322, 325, 336, 342, 346, 357, 362,
	364, 368, 378, 388, 394, 399, 402, 405, 408, 414, 419, 422, 425, 428, 430,
	436, 441, 444, 447, 451, 457, 461, 465, 469, 473, 485, 489, 495, 504, 507,
	511, 514, 518, 522, 525, 527, 535, 547, 553, 555, 561, 563, 565, 571, 579,
	587, 593, 602, 607, 609, 613, 617, 623, 630, 634, 640, 647, 649, 657, 662,
	675, 680, 684, 689, 693, 698, 701, 705, 709, 711, 714, 721, 734, 738, 741,
	746, 749, 753, 758, 761, 766, 769, 775, 778, 782, 785, 788, 792, 795, 798,
	802, 805, 808, 811, 815, 818, 821, 826, 831, 836, 839, 844, 847, 852, 855,
	859, 863, 871, 878, 882, 887, 890, 895, 899, 901, 917, 926, 934, 950, 957,
	964, 969, 1003, 1007, 1015, 1019, 1028, 1036, 1041, 1049, 1054, 1059, 1061,
	1070, 1075, 1083, 1088, 1096, 1104, 1107, 1117, 1128, 1141, 1149, 1153,
	1158, 1167, 1170, 1182, 1190, 1200, 1203, 1207, 1211, 1236, 1248, 1255,
	1263, 1268, 1276, 1282, 1292, 1305, 1311, 1317, 1333, 1339, 1348, 1350,
	1369, 1381, 1398, 1415, 1417, 1436, 1445, 1454, 1463,
}
var deserializer = antlr.NewATNDeserializer(nil)
var deserializedATN = deserializer.DeserializeFromUInt16(parserATN)

var literalNames = []string{
	"", "", "", "", "", "'ADD'", "'ALL'", "'ALTER'", "'ALWAYS'", "'ANALYZE'",
	"'AND'", "'AS'", "'ASC'", "'BEFORE'", "'BETWEEN'", "'BOTH'", "'BY'", "'CALL'",
	"'CASCADE'", "'CASE'", "'CAST'", "'CHANGE'", "'CHARACTER'", "'CHECK'",
	"'COLLATE'", "'COLUMN'", "'CONDITION'", "'CONSTRAINT'", "'CONTINUE'", "'CONVERT'",
	"'CREATE'", "'CROSS'", "'CURRENT'", "'CURRENT_USER'", "'CURSOR'", "'DATABASE'",
	"'DATABASES'", "'DECLARE'", "'DEFAULT'", "'DELAYED'", "'DELETE'", "'DESC'",
	"'DESCRIBE'", "'DETERMINISTIC'", "'DIAGNOSTICS'", "'DISTINCT'", "'DISTINCTROW'",
	"'DROP'", "'EACH'", "'ELSE'", "'ELSEIF'", "'ENCLOSED'", "'ESCAPED'", "'EXISTS'",
	"'EXIT'", "'EXPLAIN'", "'FALSE'", "'FETCH'", "'FOR'", "'FORCE'", "'FOREIGN'",
	"'FROM'", "'FULLTEXT'", "'GENERATED'", "'GET'", "'GRANT'", "'GROUP'", "'HAVING'",
	"'HIGH_PRIORITY'", "'IF'", "'IGNORE'", "'IN'", "'INDEX'", "'INFILE'", "'INNER'",
	"'INOUT'", "'INSERT'", "'INTERVAL'", "'INTO'", "'IS'", "'ITERATE'", "'JOIN'",
	"'KEY'", "'KEYS'", "'KILL'", "'LEADING'", "'LEAVE'", "'LEFT'", "'LIKE'",
	"'LIMIT'", "'LINEAR'", "'LINES'", "'LOAD'", "'LOCK'", "'LOOP'", "'LOW_PRIORITY'",
	"'MASTER_BIND'", "'MASTER_SSL_VERIFY_SERVER_CERT'", "'MATCH'", "'MAXVALUE'",
	"'MODIFIES'", "'NATURAL'", "'NOT'", "'NO_WRITE_TO_BINLOG'", "'NULL'", "'NUMBER'",
	"'ON'", "'OPTIMIZE'", "'OPTION'", "'OPTIONALLY'", "'OR'", "'ORDER'", "'OUT'",
	"'OUTER'", "'OUTFILE'", "'PARTITION'", "'PRIMARY'", "'PROCEDURE'", "'PURGE'",
	"'RANGE'", "'READ'", "'READS'", "'REFERENCES'", "'REGEXP'", "'RELEASE'",
	"'RENAME'", "'REPEAT'", "'REPLACE'", "'REQUIRE'", "'RESIGNAL'", "'RESTRICT'",
	"'RETURN'", "'REVOKE'", "'RIGHT'", "'RLIKE'", "'SCHEMA'", "'SCHEMAS'",
	"'SELECT'", "'SET'", "'SEPARATOR'", "'SHOW'", "'SIGNAL'", "'SPATIAL'",
	"'SQL'", "'SQLEXCEPTION'", "'SQLSTATE'", "'SQLWARNING'", "'SQL_BIG_RESULT'",
	"'SQL_CALC_FOUND_ROWS'", "'SQL_SMALL_RESULT'", "'SSL'", "'STACKED'", "'STARTING'",
	"'STRAIGHT_JOIN'", "'TABLE'", "'TERMINATED'", "'THEN'", "'TO'", "'TRAILING'",
	"'TRIGGER'", "'TRUE'", "'UNDO'", "'UNION'", "'UNIQUE'", "'UNLOCK'", "'UNSIGNED'",
	"'UPDATE'", "'USAGE'", "'USE'", "'USING'", "'VALUES'", "'WHEN'", "'WHERE'",
	"'WHILE'", "'WITH'", "'WRITE'", "'XOR'", "'ZEROFILL'", "'TINYINT'", "'SMALLINT'",
	"'MEDIUMINT'", "'MIDDLEINT'", "'INT'", "'INT1'", "'INT2'", "'INT3'", "'INT4'",
	"'INT8'", "'INTEGER'", "'BIGINT'", "'REAL'", "'DOUBLE'", "'PRECISION'",
	"'FLOAT'", "'FLOAT4'", "'FLOAT8'", "'DECIMAL'", "'DEC'", "'NUMERIC'", "'DATE'",
	"'TIME'", "'TIMESTAMP'", "'DATETIME'", "'YEAR'", "'CHAR'", "'VARCHAR'",
	"'NVARCHAR'", "'NATIONAL'", "'BINARY'", "'VARBINARY'", "'TINYBLOB'", "'BLOB'",
	"'MEDIUMBLOB'", "'LONG'", "'LONGBLOB'", "'TINYTEXT'", "'TEXT'", "'MEDIUMTEXT'",
	"'LONGTEXT'", "'ENUM'", "'VARYING'", "'SERIAL'", "'YEAR_MONTH'", "'DAY_HOUR'",
	"'DAY_MINUTE'", "'DAY_SECOND'", "'HOUR_MINUTE'", "'HOUR_SECOND'", "'MINUTE_SECOND'",
	"'SECOND_MICROSECOND'", "'MINUTE_MICROSECOND'", "'HOUR_MICROSECOND'", "'DAY_MICROSECOND'",
	"'JSON_VALID'", "'JSON_SCHEMA_VALID'", "'AVG'", "'BIT_AND'", "'BIT_OR'",
	"'BIT_XOR'", "'COUNT'", "'GROUP_CONCAT'", "'MAX'", "'MIN'", "'STD'", "'STDDEV'",
	"'STDDEV_POP'", "'STDDEV_SAMP'", "'SUM'", "'VAR_POP'", "'VAR_SAMP'", "'VARIANCE'",
	"'CURRENT_DATE'", "'CURRENT_TIME'", "'CURRENT_TIMESTAMP'", "'LOCALTIME'",
	"'CURDATE'", "'CURTIME'", "'DATE_ADD'", "'DATE_SUB'", "'EXTRACT'", "'LOCALTIMESTAMP'",
	"'NOW'", "'POSITION'", "'SUBSTR'", "'SUBSTRING'", "'SYSDATE'", "'TRIM'",
	"'UTC_DATE'", "'UTC_TIME'", "'UTC_TIMESTAMP'", "'ACCOUNT'", "'ACTION'",
	"'AFTER'", "'AGGREGATE'", "'ALGORITHM'", "'ANY'", "'AT'", "'AUTHORS'",
	"'AUTOCOMMIT'", "'AUTOEXTEND_SIZE'", "'AUTO_INCREMENT'", "'AVG_ROW_LENGTH'",
	"'BEGIN'", "'BINLOG'", "'BIT'", "'BLOCK'", "'BOOL'", "'BOOLEAN'", "'BTREE'",
	"'CACHE'", "'CASCADED'", "'CHAIN'", "'CHANGED'", "'CHANNEL'", "'CHECKSUM'",
	"'PAGE_CHECKSUM'", "'CIPHER'", "'CLASS_ORIGIN'", "'CLIENT'", "'CLOSE'",
	"'COALESCE'", "'CODE'", "'COLUMNS'", "'COLUMN_FORMAT'", "'COLUMN_NAME'",
	"'COMMENT'", "'COMMIT'", "'COMPACT'", "'COMPLETION'", "'COMPRESSED'", "'COMPRESSION'",
	"'CONCURRENT'", "'CONNECTION'", "'CONSISTENT'", "'CONSTRAINT_CATALOG'",
	"'CONSTRAINT_SCHEMA'", "'CONSTRAINT_NAME'", "'CONTAINS'", "'CONTEXT'",
	"'CONTRIBUTORS'", "'COPY'", "'CPU'", "'CURSOR_NAME'", "'DATA'", "'DATAFILE'",
	"'DEALLOCATE'", "'DEFAULT_AUTH'", "'DEFINER'", "'DELAY_KEY_WRITE'", "'DES_KEY_FILE'",
	"'DIRECTORY'", "'DISABLE'", "'DISCARD'", "'DISK'", "'DO'", "'DUMPFILE'",
	"'DUPLICATE'", "'DYNAMIC'", "'ENABLE'", "'ENCRYPTION'", "'END'", "'ENDS'",
	"'ENGINE'", "'ENGINES'", "'ERROR'", "'ERRORS'", "'ESCAPE'", "'EVEN'", "'EVENT'",
	"'EVENTS'", "'EVERY'", "'EXCHANGE'", "'EXCLUSIVE'", "'EXPIRE'", "'EXPORT'",
	"'EXTENDED'", "'EXTENT_SIZE'", "'FAST'", "'FAULTS'", "'FIELDS'", "'FILE_BLOCK_SIZE'",
	"'FILTER'", "'FIRST'", "'FIXED'", "'FLUSH'", "'FOLLOWS'", "'FOUND'", "'FULL'",
	"'FUNCTION'", "'GENERAL'", "'GLOBAL'", "'GRANTS'", "'GROUP_REPLICATION'",
	"'HANDLER'", "'HASH'", "'HELP'", "'HOST'", "'HOSTS'", "'IDENTIFIED'", "'IGNORE_SERVER_IDS'",
	"'IMPORT'", "'INDEXES'", "'INITIAL_SIZE'", "'INPLACE'", "'INSERT_METHOD'",
	"'INSTALL'", "'INSTANCE'", "'INVISIBLE'", "'INVOKER'", "'IO'", "'IO_THREAD'",
	"'IPC'", "'ISOLATION'", "'ISSUER'", "'JSON'", "'KEY_BLOCK_SIZE'", "'LANGUAGE'",
	"'LAST'", "'LEAVES'", "'LESS'", "'LEVEL'", "'LIST'", "'LOCAL'", "'LOGFILE'",
	"'LOGS'", "'MASTER'", "'MASTER_AUTO_POSITION'", "'MASTER_CONNECT_RETRY'",
	"'MASTER_DELAY'", "'MASTER_HEARTBEAT_PERIOD'", "'MASTER_HOST'", "'MASTER_LOG_FILE'",
	"'MASTER_LOG_POS'", "'MASTER_PASSWORD'", "'MASTER_PORT'", "'MASTER_RETRY_COUNT'",
	"'MASTER_SSL'", "'MASTER_SSL_CA'", "'MASTER_SSL_CAPATH'", "'MASTER_SSL_CERT'",
	"'MASTER_SSL_CIPHER'", "'MASTER_SSL_CRL'", "'MASTER_SSL_CRLPATH'", "'MASTER_SSL_KEY'",
	"'MASTER_TLS_VERSION'", "'MASTER_USER'", "'MAX_CONNECTIONS_PER_HOUR'",
	"'MAX_QUERIES_PER_HOUR'", "'MAX_ROWS'", "'MAX_SIZE'", "'MAX_UPDATES_PER_HOUR'",
	"'MAX_USER_CONNECTIONS'", "'MEDIUM'", "'MEMBER'", "'MERGE'", "'MESSAGE_TEXT'",
	"'MID'", "'MIGRATE'", "'MIN_ROWS'", "'MODE'", "'MODIFY'", "'MUTEX'", "'MYSQL'",
	"'MYSQL_ERRNO'", "'NAME'", "'NAMES'", "'NCHAR'", "'NEVER'", "'NEXT'", "'NO'",
	"'NODEGROUP'", "'NONE'", "'OFFLINE'", "'OFFSET'", "'OF'", "'OJ'", "'OLD_PASSWORD'",
	"'ONE'", "'ONLINE'", "'ONLY'", "'OPEN'", "'OPTIMIZER_COSTS'", "'OPTIONS'",
	"'OWNER'", "'PACK_KEYS'", "'PAGE'", "'PARSER'", "'PARTIAL'", "'PARTITIONING'",
	"'PARTITIONS'", "'PASSWORD'", "'PHASE'", "'PLUGIN'", "'PLUGIN_DIR'", "'PLUGINS'",
	"'PORT'", "'PRECEDES'", "'PREPARE'", "'PRESERVE'", "'PREV'", "'PROCESSLIST'",
	"'PROFILE'", "'PROFILES'", "'PROXY'", "'QUERY'", "'QUICK'", "'REBUILD'",
	"'RECOVER'", "'REDO_BUFFER_SIZE'", "'REDUNDANT'", "'RELAY'", "'RELAY_LOG_FILE'",
	"'RELAY_LOG_POS'", "'RELAYLOG'", "'REMOVE'", "'REORGANIZE'", "'REPAIR'",
	"'REPLICATE_DO_DB'", "'REPLICATE_DO_TABLE'", "'REPLICATE_IGNORE_DB'", "'REPLICATE_IGNORE_TABLE'",
	"'REPLICATE_REWRITE_DB'", "'REPLICATE_WILD_DO_TABLE'", "'REPLICATE_WILD_IGNORE_TABLE'",
	"'REPLICATION'", "'RESET'", "'RESUME'", "'RETURNED_SQLSTATE'", "'RETURNS'",
	"'ROLE'", "'ROLLBACK'", "'ROLLUP'", "'ROTATE'", "'ROW'", "'ROWS'", "'ROW_FORMAT'",
	"'SAVEPOINT'", "'SCHEDULE'", "'SECURITY'", "'SERVER'", "'SESSION'", "'SHARE'",
	"'SHARED'", "'SIGNED'", "'SIMPLE'", "'SLAVE'", "'SLOW'", "'SNAPSHOT'",
	"'SOCKET'", "'SOME'", "'SONAME'", "'SOUNDS'", "'SOURCE'", "'SQL_AFTER_GTIDS'",
	"'SQL_AFTER_MTS_GAPS'", "'SQL_BEFORE_GTIDS'", "'SQL_BUFFER_RESULT'", "'SQL_CACHE'",
	"'SQL_NO_CACHE'", "'SQL_THREAD'", "'START'", "'STARTS'", "'STATS_AUTO_RECALC'",
	"'STATS_PERSISTENT'", "'STATS_SAMPLE_PAGES'", "'STATUS'", "'STOP'", "'STORAGE'",
	"'STORED'", "'STRING'", "'SUBCLASS_ORIGIN'", "'SUBJECT'", "'SUBPARTITION'",
	"'SUBPARTITIONS'", "'SUSPEND'", "'SWAPS'", "'SWITCHES'", "'TABLE_NAME'",
	"'TABLESPACE'", "'TEMPORARY'", "'TEMPTABLE'", "'THAN'", "'TRADITIONAL'",
	"'TRANSACTION'", "'TRANSACTIONAL'", "'TRIGGERS'", "'TRUNCATE'", "'UNDEFINED'",
	"'UNDOFILE'", "'UNDO_BUFFER_SIZE'", "'UNINSTALL'", "'UNKNOWN'", "'UNTIL'",
	"'UPGRADE'", "'USER'", "'USE_FRM'", "'USER_RESOURCES'", "'VALIDATION'",
	"'VALUE'", "'VARIABLES'", "'VIEW'", "'VIRTUAL'", "'VISIBLE'", "'WAIT'",
	"'WARNINGS'", "'WITHOUT'", "'WORK'", "'WRAPPER'", "'X509'", "'XA'", "'XML'",
	"'EUR'", "'USA'", "'JIS'", "'ISO'", "'INTERNAL'", "'QUARTER'", "'MONTH'",
	"'DAY'", "'HOUR'", "'MINUTE'", "'WEEK'", "'SECOND'", "'MICROSECOND'", "'TABLES'",
	"'ROUTINE'", "'EXECUTE'", "'FILE'", "'PROCESS'", "'RELOAD'", "'SHUTDOWN'",
	"'SUPER'", "'PRIVILEGES'", "'APPLICATION_PASSWORD_ADMIN'", "'AUDIT_ADMIN'",
	"'BACKUP_ADMIN'", "'BINLOG_ADMIN'", "'BINLOG_ENCRYPTION_ADMIN'", "'CLONE_ADMIN'",
	"'CONNECTION_ADMIN'", "'ENCRYPTION_KEY_ADMIN'", "'FIREWALL_ADMIN'", "'FIREWALL_USER'",
	"'GROUP_REPLICATION_ADMIN'", "'INNODB_REDO_LOG_ARCHIVE'", "'NDB_STORED_USER'",
	"'PERSIST_RO_VARIABLES_ADMIN'", "'REPLICATION_APPLIER'", "'REPLICATION_SLAVE_ADMIN'",
	"'RESOURCE_GROUP_ADMIN'", "'RESOURCE_GROUP_USER'", "'ROLE_ADMIN'", "",
	"'SET_USER_ID'", "'SHOW_ROUTINE'", "'SYSTEM_VARIABLES_ADMIN'", "'TABLE_ENCRYPTION_ADMIN'",
	"'VERSION_TOKEN_ADMIN'", "'XA_RECOVER_ADMIN'", "'ARMSCII8'", "'ASCII'",
	"'BIG5'", "'CP1250'", "'CP1251'", "'CP1256'", "'CP1257'", "'CP850'", "'CP852'",
	"'CP866'", "'CP932'", "'DEC8'", "'EUCJPMS'", "'EUCKR'", "'GB2312'", "'GBK'",
	"'GEOSTD8'", "'GREEK'", "'HEBREW'", "'HP8'", "'KEYBCS2'", "'KOI8R'", "'KOI8U'",
	"'LATIN1'", "'LATIN2'", "'LATIN5'", "'LATIN7'", "'MACCE'", "'MACROMAN'",
	"'SJIS'", "'SWE7'", "'TIS620'", "'UCS2'", "'UJIS'", "'UTF16'", "'UTF16LE'",
	"'UTF32'", "'UTF8'", "'UTF8MB3'", "'UTF8MB4'", "'ARCHIVE'", "'BLACKHOLE'",
	"'CSV'", "'FEDERATED'", "'INNODB'", "'MEMORY'", "'MRG_MYISAM'", "'MYISAM'",
	"'NDB'", "'NDBCLUSTER'", "'PERFORMANCE_SCHEMA'", "'TOKUDB'", "'REPEATABLE'",
	"'COMMITTED'", "'UNCOMMITTED'", "'SERIALIZABLE'", "'GEOMETRYCOLLECTION'",
	"'GEOMCOLLECTION'", "'GEOMETRY'", "'LINESTRING'", "'MULTILINESTRING'",
	"'MULTIPOINT'", "'MULTIPOLYGON'", "'POINT'", "'POLYGON'", "'ABS'", "'ACOS'",
	"'ADDDATE'", "'ADDTIME'", "'AES_DECRYPT'", "'AES_ENCRYPT'", "'AREA'", "'ASBINARY'",
	"'ASIN'", "'ASTEXT'", "'ASWKB'", "'ASWKT'", "'ASYMMETRIC_DECRYPT'", "'ASYMMETRIC_DERIVE'",
	"'ASYMMETRIC_ENCRYPT'", "'ASYMMETRIC_SIGN'", "'ASYMMETRIC_VERIFY'", "'ATAN'",
	"'ATAN2'", "'BENCHMARK'", "'BIN'", "'BIT_COUNT'", "'BIT_LENGTH'", "'BUFFER'",
	"'CATALOG_NAME'", "'CEIL'", "'CEILING'", "'CENTROID'", "'CHARACTER_LENGTH'",
	"'CHARSET'", "'CHAR_LENGTH'", "'COERCIBILITY'", "'COLLATION'", "'COMPRESS'",
	"'CONCAT'", "'CONCAT_WS'", "'CONNECTION_ID'", "'CONV'", "'CONVERT_TZ'",
	"'COS'", "'COT'", "'CRC32'", "'CREATE_ASYMMETRIC_PRIV_KEY'", "'CREATE_ASYMMETRIC_PUB_KEY'",
	"'CREATE_DH_PARAMETERS'", "'CREATE_DIGEST'", "'CROSSES'", "'DATEDIFF'",
	"'DATE_FORMAT'", "'DAYNAME'", "'DAYOFMONTH'", "'DAYOFWEEK'", "'DAYOFYEAR'",
	"'DECODE'", "'DEGREES'", "'DES_DECRYPT'", "'DES_ENCRYPT'", "'DIMENSION'",
	"'DISJOINT'", "'ELT'", "'ENCODE'", "'ENCRYPT'", "'ENDPOINT'", "'ENVELOPE'",
	"'EQUALS'", "'EXP'", "'EXPORT_SET'", "'EXTERIORRING'", "'EXTRACTVALUE'",
	"'FIELD'", "'FIND_IN_SET'", "'FLOOR'", "'FORMAT'", "'FOUND_ROWS'", "'FROM_BASE64'",
	"'FROM_DAYS'", "'FROM_UNIXTIME'", "'GEOMCOLLFROMTEXT'", "'GEOMCOLLFROMWKB'",
	"'GEOMETRYCOLLECTIONFROMTEXT'", "'GEOMETRYCOLLECTIONFROMWKB'", "'GEOMETRYFROMTEXT'",
	"'GEOMETRYFROMWKB'", "'GEOMETRYN'", "'GEOMETRYTYPE'", "'GEOMFROMTEXT'",
	"'GEOMFROMWKB'", "'GET_FORMAT'", "'GET_LOCK'", "'GLENGTH'", "'GREATEST'",
	"'GTID_SUBSET'", "'GTID_SUBTRACT'", "'HEX'", "'IFNULL'", "'INET6_ATON'",
	"'INET6_NTOA'", "'INET_ATON'", "'INET_NTOA'", "'INSTR'", "'INTERIORRINGN'",
	"'INTERSECTS'", "'ISCLOSED'", "'ISEMPTY'", "'ISNULL'", "'ISSIMPLE'", "'IS_FREE_LOCK'",
	"'IS_IPV4'", "'IS_IPV4_COMPAT'", "'IS_IPV4_MAPPED'", "'IS_IPV6'", "'IS_USED_LOCK'",
	"'LAST_INSERT_ID'", "'LCASE'", "'LEAST'", "'LENGTH'", "'LINEFROMTEXT'",
	"'LINEFROMWKB'", "'LINESTRINGFROMTEXT'", "'LINESTRINGFROMWKB'", "'LN'",
	"'LOAD_FILE'", "'LOCATE'", "'LOG'", "'LOG10'", "'LOG2'", "'LOWER'", "'LPAD'",
	"'LTRIM'", "'MAKEDATE'", "'MAKETIME'", "'MAKE_SET'", "'MASTER_POS_WAIT'",
	"'MBRCONTAINS'", "'MBRDISJOINT'", "'MBREQUAL'", "'MBRINTERSECTS'", "'MBROVERLAPS'",
	"'MBRTOUCHES'", "'MBRWITHIN'", "'MD5'", "'MLINEFROMTEXT'", "'MLINEFROMWKB'",
	"'MONTHNAME'", "'MPOINTFROMTEXT'", "'MPOINTFROMWKB'", "'MPOLYFROMTEXT'",
	"'MPOLYFROMWKB'", "'MULTILINESTRINGFROMTEXT'", "'MULTILINESTRINGFROMWKB'",
	"'MULTIPOINTFROMTEXT'", "'MULTIPOINTFROMWKB'", "'MULTIPOLYGONFROMTEXT'",
	"'MULTIPOLYGONFROMWKB'", "'NAME_CONST'", "'NULLIF'", "'NUMGEOMETRIES'",
	"'NUMINTERIORRINGS'", "'NUMPOINTS'", "'OCT'", "'OCTET_LENGTH'", "'ORD'",
	"'OVERLAPS'", "'PERIOD_ADD'", "'PERIOD_DIFF'", "'PI'", "'POINTFROMTEXT'",
	"'POINTFROMWKB'", "'POINTN'", "'POLYFROMTEXT'", "'POLYFROMWKB'", "'POLYGONFROMTEXT'",
	"'POLYGONFROMWKB'", "'POW'", "'POWER'", "'QUOTE'", "'RADIANS'", "'RAND'",
	"'RANDOM_BYTES'", "'RELEASE_LOCK'", "'REVERSE'", "'ROUND'", "'ROW_COUNT'",
	"'RPAD'", "'RTRIM'", "'SEC_TO_TIME'", "'SESSION_USER'", "'SHA'", "'SHA1'",
	"'SHA2'", "'SCHEMA_NAME'", "'SIGN'", "'SIN'", "'SLEEP'", "'SOUNDEX'", "'SQL_THREAD_WAIT_AFTER_GTIDS'",
	"'SQRT'", "'SRID'", "'STARTPOINT'", "'STRCMP'", "'STR_TO_DATE'", "'ST_AREA'",
	"'ST_ASBINARY'", "'ST_ASTEXT'", "'ST_ASWKB'", "'ST_ASWKT'", "'ST_BUFFER'",
	"'ST_CENTROID'", "'ST_CONTAINS'", "'ST_CROSSES'", "'ST_DIFFERENCE'", "'ST_DIMENSION'",
	"'ST_DISJOINT'", "'ST_DISTANCE'", "'ST_ENDPOINT'", "'ST_ENVELOPE'", "'ST_EQUALS'",
	"'ST_EXTERIORRING'", "'ST_GEOMCOLLFROMTEXT'", "'ST_GEOMCOLLFROMTXT'", "'ST_GEOMCOLLFROMWKB'",
	"'ST_GEOMETRYCOLLECTIONFROMTEXT'", "'ST_GEOMETRYCOLLECTIONFROMWKB'", "'ST_GEOMETRYFROMTEXT'",
	"'ST_GEOMETRYFROMWKB'", "'ST_GEOMETRYN'", "'ST_GEOMETRYTYPE'", "'ST_GEOMFROMTEXT'",
	"'ST_GEOMFROMWKB'", "'ST_INTERIORRINGN'", "'ST_INTERSECTION'", "'ST_INTERSECTS'",
	"'ST_ISCLOSED'", "'ST_ISEMPTY'", "'ST_ISSIMPLE'", "'ST_LINEFROMTEXT'",
	"'ST_LINEFROMWKB'", "'ST_LINESTRINGFROMTEXT'", "'ST_LINESTRINGFROMWKB'",
	"'ST_NUMGEOMETRIES'", "'ST_NUMINTERIORRING'", "'ST_NUMINTERIORRINGS'",
	"'ST_NUMPOINTS'", "'ST_OVERLAPS'", "'ST_POINTFROMTEXT'", "'ST_POINTFROMWKB'",
	"'ST_POINTN'", "'ST_POLYFROMTEXT'", "'ST_POLYFROMWKB'", "'ST_POLYGONFROMTEXT'",
	"'ST_POLYGONFROMWKB'", "'ST_SRID'", "'ST_STARTPOINT'", "'ST_SYMDIFFERENCE'",
	"'ST_TOUCHES'", "'ST_UNION'", "'ST_WITHIN'", "'ST_X'", "'ST_Y'", "'SUBDATE'",
	"'SUBSTRING_INDEX'", "'SUBTIME'", "'SYSTEM_USER'", "'TAN'", "'TIMEDIFF'",
	"'TIMESTAMPADD'", "'TIMESTAMPDIFF'", "'TIME_FORMAT'", "'TIME_TO_SEC'",
	"'TOUCHES'", "'TO_BASE64'", "'TO_DAYS'", "'TO_SECONDS'", "'UCASE'", "'UNCOMPRESS'",
	"'UNCOMPRESSED_LENGTH'", "'UNHEX'", "'UNIX_TIMESTAMP'", "'UPDATEXML'",
	"'UPPER'", "'UUID'", "'UUID_SHORT'", "'VALIDATE_PASSWORD_STRENGTH'", "'VERSION'",
	"'WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS'", "'WEEKDAY'", "'WEEKOFYEAR'", "'WEIGHT_STRING'",
	"'WITHIN'", "'YEARWEEK'", "'Y'", "'X'", "':='", "'+='", "'-='", "'*='",
	"'/='", "'%='", "'&='", "'^='", "'|='", "'*'", "'/'", "'%'", "'+'", "'--'",
	"'-'", "'DIV'", "'MOD'", "'='", "'>'", "'<'", "'!'", "'~'", "'|'", "'&'",
	"'^'", "'.'", "'('", "')'", "','", "';'", "'@'", "'0'", "'1'", "'2'", "'''",
	"'\"'", "'`'", "':'",
}
var symbolicNames = []string{
	"", "SPACE", "SPEC_MYSQL_COMMENT", "COMMENT_INPUT", "LINE_COMMENT", "ADD",
	"ALL", "ALTER", "ALWAYS", "ANALYZE", "AND", "AS", "ASC", "BEFORE", "BETWEEN",
	"BOTH", "BY", "CALL", "CASCADE", "CASE", "CAST", "CHANGE", "CHARACTER",
	"CHECK", "COLLATE", "COLUMN", "CONDITION", "CONSTRAINT", "CONTINUE", "CONVERT",
	"CREATE", "CROSS", "CURRENT", "CURRENT_USER", "CURSOR", "DATABASE", "DATABASES",
	"DECLARE", "DEFAULT", "DELAYED", "DELETE", "DESC", "DESCRIBE", "DETERMINISTIC",
	"DIAGNOSTICS", "DISTINCT", "DISTINCTROW", "DROP", "EACH", "ELSE", "ELSEIF",
	"ENCLOSED", "ESCAPED", "EXISTS", "EXIT", "EXPLAIN", "FALSE", "FETCH", "FOR",
	"FORCE", "FOREIGN", "FROM", "FULLTEXT", "GENERATED", "GET", "GRANT", "GROUP",
	"HAVING", "HIGH_PRIORITY", "IF", "IGNORE", "IN", "INDEX", "INFILE", "INNER",
	"INOUT", "INSERT", "INTERVAL", "INTO", "IS", "ITERATE", "JOIN", "KEY",
	"KEYS", "KILL", "LEADING", "LEAVE", "LEFT", "LIKE", "LIMIT", "LINEAR",
	"LINES", "LOAD", "LOCK", "LOOP", "LOW_PRIORITY", "MASTER_BIND", "MASTER_SSL_VERIFY_SERVER_CERT",
	"MATCH", "MAXVALUE", "MODIFIES", "NATURAL", "NOT", "NO_WRITE_TO_BINLOG",
	"NULL_LITERAL", "NUMBER", "ON", "OPTIMIZE", "OPTION", "OPTIONALLY", "OR",
	"ORDER", "OUT", "OUTER", "OUTFILE", "PARTITION", "PRIMARY", "PROCEDURE",
	"PURGE", "RANGE", "READ", "READS", "REFERENCES", "REGEXP", "RELEASE", "RENAME",
	"REPEAT", "REPLACE", "REQUIRE", "RESIGNAL", "RESTRICT", "RETURN", "REVOKE",
	"RIGHT", "RLIKE", "SCHEMA", "SCHEMAS", "SELECT", "SET", "SEPARATOR", "SHOW",
	"SIGNAL", "SPATIAL", "SQL", "SQLEXCEPTION", "SQLSTATE", "SQLWARNING", "SQL_BIG_RESULT",
	"SQL_CALC_FOUND_ROWS", "SQL_SMALL_RESULT", "SSL", "STACKED", "STARTING",
	"STRAIGHT_JOIN", "TABLE", "TERMINATED", "THEN", "TO", "TRAILING", "TRIGGER",
	"TRUE", "UNDO", "UNION", "UNIQUE", "UNLOCK", "UNSIGNED", "UPDATE", "USAGE",
	"USE", "USING", "VALUES", "WHEN", "WHERE", "WHILE", "WITH", "WRITE", "XOR",
	"ZEROFILL", "TINYINT", "SMALLINT", "MEDIUMINT", "MIDDLEINT", "INT", "INT1",
	"INT2", "INT3", "INT4", "INT8", "INTEGER", "BIGINT", "REAL", "DOUBLE",
	"PRECISION", "FLOAT", "FLOAT4", "FLOAT8", "DECIMAL", "DEC", "NUMERIC",
	"DATE", "TIME", "TIMESTAMP", "DATETIME", "YEAR", "CHAR", "VARCHAR", "NVARCHAR",
	"NATIONAL", "BINARY", "VARBINARY", "TINYBLOB", "BLOB", "MEDIUMBLOB", "LONG",
	"LONGBLOB", "TINYTEXT", "TEXT", "MEDIUMTEXT", "LONGTEXT", "ENUM", "VARYING",
	"SERIAL", "YEAR_MONTH", "DAY_HOUR", "DAY_MINUTE", "DAY_SECOND", "HOUR_MINUTE",
	"HOUR_SECOND", "MINUTE_SECOND", "SECOND_MICROSECOND", "MINUTE_MICROSECOND",
	"HOUR_MICROSECOND", "DAY_MICROSECOND", "JSON_VALID", "JSON_SCHEMA_VALID",
	"AVG", "BIT_AND", "BIT_OR", "BIT_XOR", "COUNT", "GROUP_CONCAT", "MAX",
	"MIN", "STD", "STDDEV", "STDDEV_POP", "STDDEV_SAMP", "SUM", "VAR_POP",
	"VAR_SAMP", "VARIANCE", "CURRENT_DATE", "CURRENT_TIME", "CURRENT_TIMESTAMP",
	"LOCALTIME", "CURDATE", "CURTIME", "DATE_ADD", "DATE_SUB", "EXTRACT", "LOCALTIMESTAMP",
	"NOW", "POSITION", "SUBSTR", "SUBSTRING", "SYSDATE", "TRIM", "UTC_DATE",
	"UTC_TIME", "UTC_TIMESTAMP", "ACCOUNT", "ACTION", "AFTER", "AGGREGATE",
	"ALGORITHM", "ANY", "AT", "AUTHORS", "AUTOCOMMIT", "AUTOEXTEND_SIZE", "AUTO_INCREMENT",
	"AVG_ROW_LENGTH", "BEGIN", "BINLOG", "BIT", "BLOCK", "BOOL", "BOOLEAN",
	"BTREE", "CACHE", "CASCADED", "CHAIN", "CHANGED", "CHANNEL", "CHECKSUM",
	"PAGE_CHECKSUM", "CIPHER", "CLASS_ORIGIN", "CLIENT", "CLOSE", "COALESCE",
	"CODE", "COLUMNS", "COLUMN_FORMAT", "COLUMN_NAME", "COMMENT", "COMMIT",
	"COMPACT", "COMPLETION", "COMPRESSED", "COMPRESSION", "CONCURRENT", "CONNECTION",
	"CONSISTENT", "CONSTRAINT_CATALOG", "CONSTRAINT_SCHEMA", "CONSTRAINT_NAME",
	"CONTAINS", "CONTEXT", "CONTRIBUTORS", "COPY", "CPU", "CURSOR_NAME", "DATA",
	"DATAFILE", "DEALLOCATE", "DEFAULT_AUTH", "DEFINER", "DELAY_KEY_WRITE",
	"DES_KEY_FILE", "DIRECTORY", "DISABLE", "DISCARD", "DISK", "DO", "DUMPFILE",
	"DUPLICATE", "DYNAMIC", "ENABLE", "ENCRYPTION", "END", "ENDS", "ENGINE",
	"ENGINES", "ERROR", "ERRORS", "ESCAPE", "EVEN", "EVENT", "EVENTS", "EVERY",
	"EXCHANGE", "EXCLUSIVE", "EXPIRE", "EXPORT", "EXTENDED", "EXTENT_SIZE",
	"FAST", "FAULTS", "FIELDS", "FILE_BLOCK_SIZE", "FILTER", "FIRST", "FIXED",
	"FLUSH", "FOLLOWS", "FOUND", "FULL", "FUNCTION", "GENERAL", "GLOBAL", "GRANTS",
	"GROUP_REPLICATION", "HANDLER", "HASH", "HELP", "HOST", "HOSTS", "IDENTIFIED",
	"IGNORE_SERVER_IDS", "IMPORT", "INDEXES", "INITIAL_SIZE", "INPLACE", "INSERT_METHOD",
	"INSTALL", "INSTANCE", "INVISIBLE", "INVOKER", "IO", "IO_THREAD", "IPC",
	"ISOLATION", "ISSUER", "JSON", "KEY_BLOCK_SIZE", "LANGUAGE", "LAST", "LEAVES",
	"LESS", "LEVEL", "LIST", "LOCAL", "LOGFILE", "LOGS", "MASTER", "MASTER_AUTO_POSITION",
	"MASTER_CONNECT_RETRY", "MASTER_DELAY", "MASTER_HEARTBEAT_PERIOD", "MASTER_HOST",
	"MASTER_LOG_FILE", "MASTER_LOG_POS", "MASTER_PASSWORD", "MASTER_PORT",
	"MASTER_RETRY_COUNT", "MASTER_SSL", "MASTER_SSL_CA", "MASTER_SSL_CAPATH",
	"MASTER_SSL_CERT", "MASTER_SSL_CIPHER", "MASTER_SSL_CRL", "MASTER_SSL_CRLPATH",
	"MASTER_SSL_KEY", "MASTER_TLS_VERSION", "MASTER_USER", "MAX_CONNECTIONS_PER_HOUR",
	"MAX_QUERIES_PER_HOUR", "MAX_ROWS", "MAX_SIZE", "MAX_UPDATES_PER_HOUR",
	"MAX_USER_CONNECTIONS", "MEDIUM", "MEMBER", "MERGE", "MESSAGE_TEXT", "MID",
	"MIGRATE", "MIN_ROWS", "MODE", "MODIFY", "MUTEX", "MYSQL", "MYSQL_ERRNO",
	"NAME", "NAMES", "NCHAR", "NEVER", "NEXT", "NO", "NODEGROUP", "NONE", "OFFLINE",
	"OFFSET", "OF", "OJ", "OLD_PASSWORD", "ONE", "ONLINE", "ONLY", "OPEN",
	"OPTIMIZER_COSTS", "OPTIONS", "OWNER", "PACK_KEYS", "PAGE", "PARSER", "PARTIAL",
	"PARTITIONING", "PARTITIONS", "PASSWORD", "PHASE", "PLUGIN", "PLUGIN_DIR",
	"PLUGINS", "PORT", "PRECEDES", "PREPARE", "PRESERVE", "PREV", "PROCESSLIST",
	"PROFILE", "PROFILES", "PROXY", "QUERY", "QUICK", "REBUILD", "RECOVER",
	"REDO_BUFFER_SIZE", "REDUNDANT", "RELAY", "RELAY_LOG_FILE", "RELAY_LOG_POS",
	"RELAYLOG", "REMOVE", "REORGANIZE", "REPAIR", "REPLICATE_DO_DB", "REPLICATE_DO_TABLE",
	"REPLICATE_IGNORE_DB", "REPLICATE_IGNORE_TABLE", "REPLICATE_REWRITE_DB",
	"REPLICATE_WILD_DO_TABLE", "REPLICATE_WILD_IGNORE_TABLE", "REPLICATION",
	"RESET", "RESUME", "RETURNED_SQLSTATE", "RETURNS", "ROLE", "ROLLBACK",
	"ROLLUP", "ROTATE", "ROW", "ROWS", "ROW_FORMAT", "SAVEPOINT", "SCHEDULE",
	"SECURITY", "SERVER", "SESSION", "SHARE", "SHARED", "SIGNED", "SIMPLE",
	"SLAVE", "SLOW", "SNAPSHOT", "SOCKET", "SOME", "SONAME", "SOUNDS", "SOURCE",
	"SQL_AFTER_GTIDS", "SQL_AFTER_MTS_GAPS", "SQL_BEFORE_GTIDS", "SQL_BUFFER_RESULT",
	"SQL_CACHE", "SQL_NO_CACHE", "SQL_THREAD", "START", "STARTS", "STATS_AUTO_RECALC",
	"STATS_PERSISTENT", "STATS_SAMPLE_PAGES", "STATUS", "STOP", "STORAGE",
	"STORED", "STRING", "SUBCLASS_ORIGIN", "SUBJECT", "SUBPARTITION", "SUBPARTITIONS",
	"SUSPEND", "SWAPS", "SWITCHES", "TABLE_NAME", "TABLESPACE", "TEMPORARY",
	"TEMPTABLE", "THAN", "TRADITIONAL", "TRANSACTION", "TRANSACTIONAL", "TRIGGERS",
	"TRUNCATE", "UNDEFINED", "UNDOFILE", "UNDO_BUFFER_SIZE", "UNINSTALL", "UNKNOWN",
	"UNTIL", "UPGRADE", "USER", "USE_FRM", "USER_RESOURCES", "VALIDATION",
	"VALUE", "VARIABLES", "VIEW", "VIRTUAL", "VISIBLE", "WAIT", "WARNINGS",
	"WITHOUT", "WORK", "WRAPPER", "X509", "XA", "XML", "EUR", "USA", "JIS",
	"ISO", "INTERNAL", "QUARTER", "MONTH", "DAY", "HOUR", "MINUTE", "WEEK",
	"SECOND", "MICROSECOND", "TABLES", "ROUTINE", "EXECUTE", "FILE", "PROCESS",
	"RELOAD", "SHUTDOWN", "SUPER", "PRIVILEGES", "APPLICATION_PASSWORD_ADMIN",
	"AUDIT_ADMIN", "BACKUP_ADMIN", "BINLOG_ADMIN", "BINLOG_ENCRYPTION_ADMIN",
	"CLONE_ADMIN", "CONNECTION_ADMIN", "ENCRYPTION_KEY_ADMIN", "FIREWALL_ADMIN",
	"FIREWALL_USER", "GROUP_REPLICATION_ADMIN", "INNODB_REDO_LOG_ARCHIVE",
	"NDB_STORED_USER", "PERSIST_RO_VARIABLES_ADMIN", "REPLICATION_APPLIER",
	"REPLICATION_SLAVE_ADMIN", "RESOURCE_GROUP_ADMIN", "RESOURCE_GROUP_USER",
	"ROLE_ADMIN", "SESSION_VARIABLES_ADMIN", "SET_USER_ID", "SHOW_ROUTINE",
	"SYSTEM_VARIABLES_ADMIN", "TABLE_ENCRYPTION_ADMIN", "VERSION_TOKEN_ADMIN",
	"XA_RECOVER_ADMIN", "ARMSCII8", "ASCII", "BIG5", "CP1250", "CP1251", "CP1256",
	"CP1257", "CP850", "CP852", "CP866", "CP932", "DEC8", "EUCJPMS", "EUCKR",
	"GB2312", "GBK", "GEOSTD8", "GREEK", "HEBREW", "HP8", "KEYBCS2", "KOI8R",
	"KOI8U", "LATIN1", "LATIN2", "LATIN5", "LATIN7", "MACCE", "MACROMAN", "SJIS",
	"SWE7", "TIS620", "UCS2", "UJIS", "UTF16", "UTF16LE", "UTF32", "UTF8",
	"UTF8MB3", "UTF8MB4", "ARCHIVE", "BLACKHOLE", "CSV", "FEDERATED", "INNODB",
	"MEMORY", "MRG_MYISAM", "MYISAM", "NDB", "NDBCLUSTER", "PERFORMANCE_SCHEMA",
	"TOKUDB", "REPEATABLE", "COMMITTED", "UNCOMMITTED", "SERIALIZABLE", "GEOMETRYCOLLECTION",
	"GEOMCOLLECTION", "GEOMETRY", "LINESTRING", "MULTILINESTRING", "MULTIPOINT",
	"MULTIPOLYGON", "POINT", "POLYGON", "ABS", "ACOS", "ADDDATE", "ADDTIME",
	"AES_DECRYPT", "AES_ENCRYPT", "AREA", "ASBINARY", "ASIN", "ASTEXT", "ASWKB",
	"ASWKT", "ASYMMETRIC_DECRYPT", "ASYMMETRIC_DERIVE", "ASYMMETRIC_ENCRYPT",
	"ASYMMETRIC_SIGN", "ASYMMETRIC_VERIFY", "ATAN", "ATAN2", "BENCHMARK", "BIN",
	"BIT_COUNT", "BIT_LENGTH", "BUFFER", "CATALOG_NAME", "CEIL", "CEILING",
	"CENTROID", "CHARACTER_LENGTH", "CHARSET", "CHAR_LENGTH", "COERCIBILITY",
	"COLLATION", "COMPRESS", "CONCAT", "CONCAT_WS", "CONNECTION_ID", "CONV",
	"CONVERT_TZ", "COS", "COT", "CRC32", "CREATE_ASYMMETRIC_PRIV_KEY", "CREATE_ASYMMETRIC_PUB_KEY",
	"CREATE_DH_PARAMETERS", "CREATE_DIGEST", "CROSSES", "DATEDIFF", "DATE_FORMAT",
	"DAYNAME", "DAYOFMONTH", "DAYOFWEEK", "DAYOFYEAR", "DECODE", "DEGREES",
	"DES_DECRYPT", "DES_ENCRYPT", "DIMENSION", "DISJOINT", "ELT", "ENCODE",
	"ENCRYPT", "ENDPOINT", "ENVELOPE", "EQUALS", "EXP", "EXPORT_SET", "EXTERIORRING",
	"EXTRACTVALUE", "FIELD", "FIND_IN_SET", "FLOOR", "FORMAT", "FOUND_ROWS",
	"FROM_BASE64", "FROM_DAYS", "FROM_UNIXTIME", "GEOMCOLLFROMTEXT", "GEOMCOLLFROMWKB",
	"GEOMETRYCOLLECTIONFROMTEXT", "GEOMETRYCOLLECTIONFROMWKB", "GEOMETRYFROMTEXT",
	"GEOMETRYFROMWKB", "GEOMETRYN", "GEOMETRYTYPE", "GEOMFROMTEXT", "GEOMFROMWKB",
	"GET_FORMAT", "GET_LOCK", "GLENGTH", "GREATEST", "GTID_SUBSET", "GTID_SUBTRACT",
	"HEX", "IFNULL", "INET6_ATON", "INET6_NTOA", "INET_ATON", "INET_NTOA",
	"INSTR", "INTERIORRINGN", "INTERSECTS", "ISCLOSED", "ISEMPTY", "ISNULL",
	"ISSIMPLE", "IS_FREE_LOCK", "IS_IPV4", "IS_IPV4_COMPAT", "IS_IPV4_MAPPED",
	"IS_IPV6", "IS_USED_LOCK", "LAST_INSERT_ID", "LCASE", "LEAST", "LENGTH",
	"LINEFROMTEXT", "LINEFROMWKB", "LINESTRINGFROMTEXT", "LINESTRINGFROMWKB",
	"LN", "LOAD_FILE", "LOCATE", "LOG", "LOG10", "LOG2", "LOWER", "LPAD", "LTRIM",
	"MAKEDATE", "MAKETIME", "MAKE_SET", "MASTER_POS_WAIT", "MBRCONTAINS", "MBRDISJOINT",
	"MBREQUAL", "MBRINTERSECTS", "MBROVERLAPS", "MBRTOUCHES", "MBRWITHIN",
	"MD5", "MLINEFROMTEXT", "MLINEFROMWKB", "MONTHNAME", "MPOINTFROMTEXT",
	"MPOINTFROMWKB", "MPOLYFROMTEXT", "MPOLYFROMWKB", "MULTILINESTRINGFROMTEXT",
	"MULTILINESTRINGFROMWKB", "MULTIPOINTFROMTEXT", "MULTIPOINTFROMWKB", "MULTIPOLYGONFROMTEXT",
	"MULTIPOLYGONFROMWKB", "NAME_CONST", "NULLIF", "NUMGEOMETRIES", "NUMINTERIORRINGS",
	"NUMPOINTS", "OCT", "OCTET_LENGTH", "ORD", "OVERLAPS", "PERIOD_ADD", "PERIOD_DIFF",
	"PI", "POINTFROMTEXT", "POINTFROMWKB", "POINTN", "POLYFROMTEXT", "POLYFROMWKB",
	"POLYGONFROMTEXT", "POLYGONFROMWKB", "POW", "POWER", "QUOTE", "RADIANS",
	"RAND", "RANDOM_BYTES", "RELEASE_LOCK", "REVERSE", "ROUND", "ROW_COUNT",
	"RPAD", "RTRIM", "SEC_TO_TIME", "SESSION_USER", "SHA", "SHA1", "SHA2",
	"SCHEMA_NAME", "SIGN", "SIN", "SLEEP", "SOUNDEX", "SQL_THREAD_WAIT_AFTER_GTIDS",
	"SQRT", "SRID", "STARTPOINT", "STRCMP", "STR_TO_DATE", "ST_AREA", "ST_ASBINARY",
	"ST_ASTEXT", "ST_ASWKB", "ST_ASWKT", "ST_BUFFER", "ST_CENTROID", "ST_CONTAINS",
	"ST_CROSSES", "ST_DIFFERENCE", "ST_DIMENSION", "ST_DISJOINT", "ST_DISTANCE",
	"ST_ENDPOINT", "ST_ENVELOPE", "ST_EQUALS", "ST_EXTERIORRING", "ST_GEOMCOLLFROMTEXT",
	"ST_GEOMCOLLFROMTXT", "ST_GEOMCOLLFROMWKB", "ST_GEOMETRYCOLLECTIONFROMTEXT",
	"ST_GEOMETRYCOLLECTIONFROMWKB", "ST_GEOMETRYFROMTEXT", "ST_GEOMETRYFROMWKB",
	"ST_GEOMETRYN", "ST_GEOMETRYTYPE", "ST_GEOMFROMTEXT", "ST_GEOMFROMWKB",
	"ST_INTERIORRINGN", "ST_INTERSECTION", "ST_INTERSECTS", "ST_ISCLOSED",
	"ST_ISEMPTY", "ST_ISSIMPLE", "ST_LINEFROMTEXT", "ST_LINEFROMWKB", "ST_LINESTRINGFROMTEXT",
	"ST_LINESTRINGFROMWKB", "ST_NUMGEOMETRIES", "ST_NUMINTERIORRING", "ST_NUMINTERIORRINGS",
	"ST_NUMPOINTS", "ST_OVERLAPS", "ST_POINTFROMTEXT", "ST_POINTFROMWKB", "ST_POINTN",
	"ST_POLYFROMTEXT", "ST_POLYFROMWKB", "ST_POLYGONFROMTEXT", "ST_POLYGONFROMWKB",
	"ST_SRID", "ST_STARTPOINT", "ST_SYMDIFFERENCE", "ST_TOUCHES", "ST_UNION",
	"ST_WITHIN", "ST_X", "ST_Y", "SUBDATE", "SUBSTRING_INDEX", "SUBTIME", "SYSTEM_USER",
	"TAN", "TIMEDIFF", "TIMESTAMPADD", "TIMESTAMPDIFF", "TIME_FORMAT", "TIME_TO_SEC",
	"TOUCHES", "TO_BASE64", "TO_DAYS", "TO_SECONDS", "UCASE", "UNCOMPRESS",
	"UNCOMPRESSED_LENGTH", "UNHEX", "UNIX_TIMESTAMP", "UPDATEXML", "UPPER",
	"UUID", "UUID_SHORT", "VALIDATE_PASSWORD_STRENGTH", "VERSION", "WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS",
	"WEEKDAY", "WEEKOFYEAR", "WEIGHT_STRING", "WITHIN", "YEARWEEK", "Y_FUNCTION",
	"X_FUNCTION", "VAR_ASSIGN", "PLUS_ASSIGN", "MINUS_ASSIGN", "MULT_ASSIGN",
	"DIV_ASSIGN", "MOD_ASSIGN", "AND_ASSIGN", "XOR_ASSIGN", "OR_ASSIGN", "STAR",
	"DIVIDE", "MODULE", "PLUS", "MINUSMINUS", "MINUS", "DIV", "MOD", "EQUAL_SYMBOL",
	"GREATER_SYMBOL", "LESS_SYMBOL", "EXCLAMATION_SYMBOL", "BIT_NOT_OP", "BIT_OR_OP",
	"BIT_AND_OP", "BIT_XOR_OP", "DOT", "LR_BRACKET", "RR_BRACKET", "COMMA",
	"SEMI", "AT_SIGN", "ZERO_DECIMAL", "ONE_DECIMAL", "TWO_DECIMAL", "SINGLE_QUOTE_SYMB",
	"DOUBLE_QUOTE_SYMB", "REVERSE_QUOTE_SYMB", "COLON_SYMB", "CHARSET_REVERSE_QOUTE_STRING",
	"FILESIZE_LITERAL", "START_NATIONAL_STRING_LITERAL", "STRING_LITERAL",
	"DECIMAL_LITERAL", "HEXADECIMAL_LITERAL", "REAL_LITERAL", "NULL_SPEC_LITERAL",
	"BIT_STRING", "STRING_CHARSET_NAME", "DOT_ID", "ID", "REVERSE_QUOTE_ID",
	"STRING_USER_NAME", "LOCAL_ID", "GLOBAL_ID", "ERROR_RECONGNIGION",
}

var ruleNames = []string{
	"root", "selectStatement", "assignmentField", "lockClause", "orderByClause",
	"orderByExpression", "tableSources", "tableSource", "tableSourceItem",
	"indexHint", "indexHintType", "joinPart", "queryExpression", "queryExpressionNointo",
	"querySpecification", "querySpecificationNointo", "unionParenthesis", "unionStatement",
	"unionStatement2", "unionstatement3", "selectSpec", "selectElements", "selectElement",
	"selectIntoExpression", "selectFieldsInto", "selectLinesInto", "fromClause",
	"groupByItem", "limitClause", "limitClauseAtom", "fullId", "tableName",
	"fullColumnName", "mysqlVariable", "charsetName", "uid", "engineName",
	"simpleId", "dottedId", "collationName", "decimalLiteral", "stringLiteral",
	"nullNotnull", "booleanLiteral", "hexadecimalLiteral", "constant", "dataType",
	"collectionOptions", "convertedDataType", "lengthOneDimension", "lengthTwoDimension",
	"lengthTwoOptionalDimension", "uidList", "expressions", "intervalType",
	"functionCall", "specificFunction", "caseFuncAlternative", "levelsInWeightString",
	"levelInWeightListElement", "aggregateWindowedFunction", "scalarFunctionName",
	"passwordFunctionClause", "functionArgs", "functionArg", "expression",
	"predicate", "expressionAtom", "unaryOperator", "comparisonOperator", "logicalOperator",
	"bitOperator", "mathOperator", "jsonOperator", "charsetNameBase", "transactionLevelBase",
	"privilegesBase", "intervalTypeBase", "dataTypeBase", "keywordsCanBeId",
	"functionNameBase",
}
var decisionToDFA = make([]*antlr.DFA, len(deserializedATN.DecisionToState))

func init() {
	for index, ds := range deserializedATN.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(ds, index)
	}
}

type MySqlParser struct {
	*antlr.BaseParser
}

func NewMySqlParser(input antlr.TokenStream) *MySqlParser {
	this := new(MySqlParser)

	this.BaseParser = antlr.NewBaseParser(input)

	this.Interpreter = antlr.NewParserATNSimulator(this, deserializedATN, decisionToDFA, antlr.NewPredictionContextCache())
	this.RuleNames = ruleNames
	this.LiteralNames = literalNames
	this.SymbolicNames = symbolicNames
	this.GrammarFileName = "MySqlParser.g4"

	return this
}

// MySqlParser tokens.
const (
	MySqlParserEOF                               = antlr.TokenEOF
	MySqlParserSPACE                             = 1
	MySqlParserSPEC_MYSQL_COMMENT                = 2
	MySqlParserCOMMENT_INPUT                     = 3
	MySqlParserLINE_COMMENT                      = 4
	MySqlParserADD                               = 5
	MySqlParserALL                               = 6
	MySqlParserALTER                             = 7
	MySqlParserALWAYS                            = 8
	MySqlParserANALYZE                           = 9
	MySqlParserAND                               = 10
	MySqlParserAS                                = 11
	MySqlParserASC                               = 12
	MySqlParserBEFORE                            = 13
	MySqlParserBETWEEN                           = 14
	MySqlParserBOTH                              = 15
	MySqlParserBY                                = 16
	MySqlParserCALL                              = 17
	MySqlParserCASCADE                           = 18
	MySqlParserCASE                              = 19
	MySqlParserCAST                              = 20
	MySqlParserCHANGE                            = 21
	MySqlParserCHARACTER                         = 22
	MySqlParserCHECK                             = 23
	MySqlParserCOLLATE                           = 24
	MySqlParserCOLUMN                            = 25
	MySqlParserCONDITION                         = 26
	MySqlParserCONSTRAINT                        = 27
	MySqlParserCONTINUE                          = 28
	MySqlParserCONVERT                           = 29
	MySqlParserCREATE                            = 30
	MySqlParserCROSS                             = 31
	MySqlParserCURRENT                           = 32
	MySqlParserCURRENT_USER                      = 33
	MySqlParserCURSOR                            = 34
	MySqlParserDATABASE                          = 35
	MySqlParserDATABASES                         = 36
	MySqlParserDECLARE                           = 37
	MySqlParserDEFAULT                           = 38
	MySqlParserDELAYED                           = 39
	MySqlParserDELETE                            = 40
	MySqlParserDESC                              = 41
	MySqlParserDESCRIBE                          = 42
	MySqlParserDETERMINISTIC                     = 43
	MySqlParserDIAGNOSTICS                       = 44
	MySqlParserDISTINCT                          = 45
	MySqlParserDISTINCTROW                       = 46
	MySqlParserDROP                              = 47
	MySqlParserEACH                              = 48
	MySqlParserELSE                              = 49
	MySqlParserELSEIF                            = 50
	MySqlParserENCLOSED                          = 51
	MySqlParserESCAPED                           = 52
	MySqlParserEXISTS                            = 53
	MySqlParserEXIT                              = 54
	MySqlParserEXPLAIN                           = 55
	MySqlParserFALSE                             = 56
	MySqlParserFETCH                             = 57
	MySqlParserFOR                               = 58
	MySqlParserFORCE                             = 59
	MySqlParserFOREIGN                           = 60
	MySqlParserFROM                              = 61
	MySqlParserFULLTEXT                          = 62
	MySqlParserGENERATED                         = 63
	MySqlParserGET                               = 64
	MySqlParserGRANT                             = 65
	MySqlParserGROUP                             = 66
	MySqlParserHAVING                            = 67
	MySqlParserHIGH_PRIORITY                     = 68
	MySqlParserIF                                = 69
	MySqlParserIGNORE                            = 70
	MySqlParserIN                                = 71
	MySqlParserINDEX                             = 72
	MySqlParserINFILE                            = 73
	MySqlParserINNER                             = 74
	MySqlParserINOUT                             = 75
	MySqlParserINSERT                            = 76
	MySqlParserINTERVAL                          = 77
	MySqlParserINTO                              = 78
	MySqlParserIS                                = 79
	MySqlParserITERATE                           = 80
	MySqlParserJOIN                              = 81
	MySqlParserKEY                               = 82
	MySqlParserKEYS                              = 83
	MySqlParserKILL                              = 84
	MySqlParserLEADING                           = 85
	MySqlParserLEAVE                             = 86
	MySqlParserLEFT                              = 87
	MySqlParserLIKE                              = 88
	MySqlParserLIMIT                             = 89
	MySqlParserLINEAR                            = 90
	MySqlParserLINES                             = 91
	MySqlParserLOAD                              = 92
	MySqlParserLOCK                              = 93
	MySqlParserLOOP                              = 94
	MySqlParserLOW_PRIORITY                      = 95
	MySqlParserMASTER_BIND                       = 96
	MySqlParserMASTER_SSL_VERIFY_SERVER_CERT     = 97
	MySqlParserMATCH                             = 98
	MySqlParserMAXVALUE                          = 99
	MySqlParserMODIFIES                          = 100
	MySqlParserNATURAL                           = 101
	MySqlParserNOT                               = 102
	MySqlParserNO_WRITE_TO_BINLOG                = 103
	MySqlParserNULL_LITERAL                      = 104
	MySqlParserNUMBER                            = 105
	MySqlParserON                                = 106
	MySqlParserOPTIMIZE                          = 107
	MySqlParserOPTION                            = 108
	MySqlParserOPTIONALLY                        = 109
	MySqlParserOR                                = 110
	MySqlParserORDER                             = 111
	MySqlParserOUT                               = 112
	MySqlParserOUTER                             = 113
	MySqlParserOUTFILE                           = 114
	MySqlParserPARTITION                         = 115
	MySqlParserPRIMARY                           = 116
	MySqlParserPROCEDURE                         = 117
	MySqlParserPURGE                             = 118
	MySqlParserRANGE                             = 119
	MySqlParserREAD                              = 120
	MySqlParserREADS                             = 121
	MySqlParserREFERENCES                        = 122
	MySqlParserREGEXP                            = 123
	MySqlParserRELEASE                           = 124
	MySqlParserRENAME                            = 125
	MySqlParserREPEAT                            = 126
	MySqlParserREPLACE                           = 127
	MySqlParserREQUIRE                           = 128
	MySqlParserRESIGNAL                          = 129
	MySqlParserRESTRICT                          = 130
	MySqlParserRETURN                            = 131
	MySqlParserREVOKE                            = 132
	MySqlParserRIGHT                             = 133
	MySqlParserRLIKE                             = 134
	MySqlParserSCHEMA                            = 135
	MySqlParserSCHEMAS                           = 136
	MySqlParserSELECT                            = 137
	MySqlParserSET                               = 138
	MySqlParserSEPARATOR                         = 139
	MySqlParserSHOW                              = 140
	MySqlParserSIGNAL                            = 141
	MySqlParserSPATIAL                           = 142
	MySqlParserSQL                               = 143
	MySqlParserSQLEXCEPTION                      = 144
	MySqlParserSQLSTATE                          = 145
	MySqlParserSQLWARNING                        = 146
	MySqlParserSQL_BIG_RESULT                    = 147
	MySqlParserSQL_CALC_FOUND_ROWS               = 148
	MySqlParserSQL_SMALL_RESULT                  = 149
	MySqlParserSSL                               = 150
	MySqlParserSTACKED                           = 151
	MySqlParserSTARTING                          = 152
	MySqlParserSTRAIGHT_JOIN                     = 153
	MySqlParserTABLE                             = 154
	MySqlParserTERMINATED                        = 155
	MySqlParserTHEN                              = 156
	MySqlParserTO                                = 157
	MySqlParserTRAILING                          = 158
	MySqlParserTRIGGER                           = 159
	MySqlParserTRUE                              = 160
	MySqlParserUNDO                              = 161
	MySqlParserUNION                             = 162
	MySqlParserUNIQUE                            = 163
	MySqlParserUNLOCK                            = 164
	MySqlParserUNSIGNED                          = 165
	MySqlParserUPDATE                            = 166
	MySqlParserUSAGE                             = 167
	MySqlParserUSE                               = 168
	MySqlParserUSING                             = 169
	MySqlParserVALUES                            = 170
	MySqlParserWHEN                              = 171
	MySqlParserWHERE                             = 172
	MySqlParserWHILE                             = 173
	MySqlParserWITH                              = 174
	MySqlParserWRITE                             = 175
	MySqlParserXOR                               = 176
	MySqlParserZEROFILL                          = 177
	MySqlParserTINYINT                           = 178
	MySqlParserSMALLINT                          = 179
	MySqlParserMEDIUMINT                         = 180
	MySqlParserMIDDLEINT                         = 181
	MySqlParserINT                               = 182
	MySqlParserINT1                              = 183
	MySqlParserINT2                              = 184
	MySqlParserINT3                              = 185
	MySqlParserINT4                              = 186
	MySqlParserINT8                              = 187
	MySqlParserINTEGER                           = 188
	MySqlParserBIGINT                            = 189
	MySqlParserREAL                              = 190
	MySqlParserDOUBLE                            = 191
	MySqlParserPRECISION                         = 192
	MySqlParserFLOAT                             = 193
	MySqlParserFLOAT4                            = 194
	MySqlParserFLOAT8                            = 195
	MySqlParserDECIMAL                           = 196
	MySqlParserDEC                               = 197
	MySqlParserNUMERIC                           = 198
	MySqlParserDATE                              = 199
	MySqlParserTIME                              = 200
	MySqlParserTIMESTAMP                         = 201
	MySqlParserDATETIME                          = 202
	MySqlParserYEAR                              = 203
	MySqlParserCHAR                              = 204
	MySqlParserVARCHAR                           = 205
	MySqlParserNVARCHAR                          = 206
	MySqlParserNATIONAL                          = 207
	MySqlParserBINARY                            = 208
	MySqlParserVARBINARY                         = 209
	MySqlParserTINYBLOB                          = 210
	MySqlParserBLOB                              = 211
	MySqlParserMEDIUMBLOB                        = 212
	MySqlParserLONG                              = 213
	MySqlParserLONGBLOB                          = 214
	MySqlParserTINYTEXT                          = 215
	MySqlParserTEXT                              = 216
	MySqlParserMEDIUMTEXT                        = 217
	MySqlParserLONGTEXT                          = 218
	MySqlParserENUM                              = 219
	MySqlParserVARYING                           = 220
	MySqlParserSERIAL                            = 221
	MySqlParserYEAR_MONTH                        = 222
	MySqlParserDAY_HOUR                          = 223
	MySqlParserDAY_MINUTE                        = 224
	MySqlParserDAY_SECOND                        = 225
	MySqlParserHOUR_MINUTE                       = 226
	MySqlParserHOUR_SECOND                       = 227
	MySqlParserMINUTE_SECOND                     = 228
	MySqlParserSECOND_MICROSECOND                = 229
	MySqlParserMINUTE_MICROSECOND                = 230
	MySqlParserHOUR_MICROSECOND                  = 231
	MySqlParserDAY_MICROSECOND                   = 232
	MySqlParserJSON_VALID                        = 233
	MySqlParserJSON_SCHEMA_VALID                 = 234
	MySqlParserAVG                               = 235
	MySqlParserBIT_AND                           = 236
	MySqlParserBIT_OR                            = 237
	MySqlParserBIT_XOR                           = 238
	MySqlParserCOUNT                             = 239
	MySqlParserGROUP_CONCAT                      = 240
	MySqlParserMAX                               = 241
	MySqlParserMIN                               = 242
	MySqlParserSTD                               = 243
	MySqlParserSTDDEV                            = 244
	MySqlParserSTDDEV_POP                        = 245
	MySqlParserSTDDEV_SAMP                       = 246
	MySqlParserSUM                               = 247
	MySqlParserVAR_POP                           = 248
	MySqlParserVAR_SAMP                          = 249
	MySqlParserVARIANCE                          = 250
	MySqlParserCURRENT_DATE                      = 251
	MySqlParserCURRENT_TIME                      = 252
	MySqlParserCURRENT_TIMESTAMP                 = 253
	MySqlParserLOCALTIME                         = 254
	MySqlParserCURDATE                           = 255
	MySqlParserCURTIME                           = 256
	MySqlParserDATE_ADD                          = 257
	MySqlParserDATE_SUB                          = 258
	MySqlParserEXTRACT                           = 259
	MySqlParserLOCALTIMESTAMP                    = 260
	MySqlParserNOW                               = 261
	MySqlParserPOSITION                          = 262
	MySqlParserSUBSTR                            = 263
	MySqlParserSUBSTRING                         = 264
	MySqlParserSYSDATE                           = 265
	MySqlParserTRIM                              = 266
	MySqlParserUTC_DATE                          = 267
	MySqlParserUTC_TIME                          = 268
	MySqlParserUTC_TIMESTAMP                     = 269
	MySqlParserACCOUNT                           = 270
	MySqlParserACTION                            = 271
	MySqlParserAFTER                             = 272
	MySqlParserAGGREGATE                         = 273
	MySqlParserALGORITHM                         = 274
	MySqlParserANY                               = 275
	MySqlParserAT                                = 276
	MySqlParserAUTHORS                           = 277
	MySqlParserAUTOCOMMIT                        = 278
	MySqlParserAUTOEXTEND_SIZE                   = 279
	MySqlParserAUTO_INCREMENT                    = 280
	MySqlParserAVG_ROW_LENGTH                    = 281
	MySqlParserBEGIN                             = 282
	MySqlParserBINLOG                            = 283
	MySqlParserBIT                               = 284
	MySqlParserBLOCK                             = 285
	MySqlParserBOOL                              = 286
	MySqlParserBOOLEAN                           = 287
	MySqlParserBTREE                             = 288
	MySqlParserCACHE                             = 289
	MySqlParserCASCADED                          = 290
	MySqlParserCHAIN                             = 291
	MySqlParserCHANGED                           = 292
	MySqlParserCHANNEL                           = 293
	MySqlParserCHECKSUM                          = 294
	MySqlParserPAGE_CHECKSUM                     = 295
	MySqlParserCIPHER                            = 296
	MySqlParserCLASS_ORIGIN                      = 297
	MySqlParserCLIENT                            = 298
	MySqlParserCLOSE                             = 299
	MySqlParserCOALESCE                          = 300
	MySqlParserCODE                              = 301
	MySqlParserCOLUMNS                           = 302
	MySqlParserCOLUMN_FORMAT                     = 303
	MySqlParserCOLUMN_NAME                       = 304
	MySqlParserCOMMENT                           = 305
	MySqlParserCOMMIT                            = 306
	MySqlParserCOMPACT                           = 307
	MySqlParserCOMPLETION                        = 308
	MySqlParserCOMPRESSED                        = 309
	MySqlParserCOMPRESSION                       = 310
	MySqlParserCONCURRENT                        = 311
	MySqlParserCONNECTION                        = 312
	MySqlParserCONSISTENT                        = 313
	MySqlParserCONSTRAINT_CATALOG                = 314
	MySqlParserCONSTRAINT_SCHEMA                 = 315
	MySqlParserCONSTRAINT_NAME                   = 316
	MySqlParserCONTAINS                          = 317
	MySqlParserCONTEXT                           = 318
	MySqlParserCONTRIBUTORS                      = 319
	MySqlParserCOPY                              = 320
	MySqlParserCPU                               = 321
	MySqlParserCURSOR_NAME                       = 322
	MySqlParserDATA                              = 323
	MySqlParserDATAFILE                          = 324
	MySqlParserDEALLOCATE                        = 325
	MySqlParserDEFAULT_AUTH                      = 326
	MySqlParserDEFINER                           = 327
	MySqlParserDELAY_KEY_WRITE                   = 328
	MySqlParserDES_KEY_FILE                      = 329
	MySqlParserDIRECTORY                         = 330
	MySqlParserDISABLE                           = 331
	MySqlParserDISCARD                           = 332
	MySqlParserDISK                              = 333
	MySqlParserDO                                = 334
	MySqlParserDUMPFILE                          = 335
	MySqlParserDUPLICATE                         = 336
	MySqlParserDYNAMIC                           = 337
	MySqlParserENABLE                            = 338
	MySqlParserENCRYPTION                        = 339
	MySqlParserEND                               = 340
	MySqlParserENDS                              = 341
	MySqlParserENGINE                            = 342
	MySqlParserENGINES                           = 343
	MySqlParserERROR                             = 344
	MySqlParserERRORS                            = 345
	MySqlParserESCAPE                            = 346
	MySqlParserEVEN                              = 347
	MySqlParserEVENT                             = 348
	MySqlParserEVENTS                            = 349
	MySqlParserEVERY                             = 350
	MySqlParserEXCHANGE                          = 351
	MySqlParserEXCLUSIVE                         = 352
	MySqlParserEXPIRE                            = 353
	MySqlParserEXPORT                            = 354
	MySqlParserEXTENDED                          = 355
	MySqlParserEXTENT_SIZE                       = 356
	MySqlParserFAST                              = 357
	MySqlParserFAULTS                            = 358
	MySqlParserFIELDS                            = 359
	MySqlParserFILE_BLOCK_SIZE                   = 360
	MySqlParserFILTER                            = 361
	MySqlParserFIRST                             = 362
	MySqlParserFIXED                             = 363
	MySqlParserFLUSH                             = 364
	MySqlParserFOLLOWS                           = 365
	MySqlParserFOUND                             = 366
	MySqlParserFULL                              = 367
	MySqlParserFUNCTION                          = 368
	MySqlParserGENERAL                           = 369
	MySqlParserGLOBAL                            = 370
	MySqlParserGRANTS                            = 371
	MySqlParserGROUP_REPLICATION                 = 372
	MySqlParserHANDLER                           = 373
	MySqlParserHASH                              = 374
	MySqlParserHELP                              = 375
	MySqlParserHOST                              = 376
	MySqlParserHOSTS                             = 377
	MySqlParserIDENTIFIED                        = 378
	MySqlParserIGNORE_SERVER_IDS                 = 379
	MySqlParserIMPORT                            = 380
	MySqlParserINDEXES                           = 381
	MySqlParserINITIAL_SIZE                      = 382
	MySqlParserINPLACE                           = 383
	MySqlParserINSERT_METHOD                     = 384
	MySqlParserINSTALL                           = 385
	MySqlParserINSTANCE                          = 386
	MySqlParserINVISIBLE                         = 387
	MySqlParserINVOKER                           = 388
	MySqlParserIO                                = 389
	MySqlParserIO_THREAD                         = 390
	MySqlParserIPC                               = 391
	MySqlParserISOLATION                         = 392
	MySqlParserISSUER                            = 393
	MySqlParserJSON                              = 394
	MySqlParserKEY_BLOCK_SIZE                    = 395
	MySqlParserLANGUAGE                          = 396
	MySqlParserLAST                              = 397
	MySqlParserLEAVES                            = 398
	MySqlParserLESS                              = 399
	MySqlParserLEVEL                             = 400
	MySqlParserLIST                              = 401
	MySqlParserLOCAL                             = 402
	MySqlParserLOGFILE                           = 403
	MySqlParserLOGS                              = 404
	MySqlParserMASTER                            = 405
	MySqlParserMASTER_AUTO_POSITION              = 406
	MySqlParserMASTER_CONNECT_RETRY              = 407
	MySqlParserMASTER_DELAY                      = 408
	MySqlParserMASTER_HEARTBEAT_PERIOD           = 409
	MySqlParserMASTER_HOST                       = 410
	MySqlParserMASTER_LOG_FILE                   = 411
	MySqlParserMASTER_LOG_POS                    = 412
	MySqlParserMASTER_PASSWORD                   = 413
	MySqlParserMASTER_PORT                       = 414
	MySqlParserMASTER_RETRY_COUNT                = 415
	MySqlParserMASTER_SSL                        = 416
	MySqlParserMASTER_SSL_CA                     = 417
	MySqlParserMASTER_SSL_CAPATH                 = 418
	MySqlParserMASTER_SSL_CERT                   = 419
	MySqlParserMASTER_SSL_CIPHER                 = 420
	MySqlParserMASTER_SSL_CRL                    = 421
	MySqlParserMASTER_SSL_CRLPATH                = 422
	MySqlParserMASTER_SSL_KEY                    = 423
	MySqlParserMASTER_TLS_VERSION                = 424
	MySqlParserMASTER_USER                       = 425
	MySqlParserMAX_CONNECTIONS_PER_HOUR          = 426
	MySqlParserMAX_QUERIES_PER_HOUR              = 427
	MySqlParserMAX_ROWS                          = 428
	MySqlParserMAX_SIZE                          = 429
	MySqlParserMAX_UPDATES_PER_HOUR              = 430
	MySqlParserMAX_USER_CONNECTIONS              = 431
	MySqlParserMEDIUM                            = 432
	MySqlParserMEMBER                            = 433
	MySqlParserMERGE                             = 434
	MySqlParserMESSAGE_TEXT                      = 435
	MySqlParserMID                               = 436
	MySqlParserMIGRATE                           = 437
	MySqlParserMIN_ROWS                          = 438
	MySqlParserMODE                              = 439
	MySqlParserMODIFY                            = 440
	MySqlParserMUTEX                             = 441
	MySqlParserMYSQL                             = 442
	MySqlParserMYSQL_ERRNO                       = 443
	MySqlParserNAME                              = 444
	MySqlParserNAMES                             = 445
	MySqlParserNCHAR                             = 446
	MySqlParserNEVER                             = 447
	MySqlParserNEXT                              = 448
	MySqlParserNO                                = 449
	MySqlParserNODEGROUP                         = 450
	MySqlParserNONE                              = 451
	MySqlParserOFFLINE                           = 452
	MySqlParserOFFSET                            = 453
	MySqlParserOF                                = 454
	MySqlParserOJ                                = 455
	MySqlParserOLD_PASSWORD                      = 456
	MySqlParserONE                               = 457
	MySqlParserONLINE                            = 458
	MySqlParserONLY                              = 459
	MySqlParserOPEN                              = 460
	MySqlParserOPTIMIZER_COSTS                   = 461
	MySqlParserOPTIONS                           = 462
	MySqlParserOWNER                             = 463
	MySqlParserPACK_KEYS                         = 464
	MySqlParserPAGE                              = 465
	MySqlParserPARSER                            = 466
	MySqlParserPARTIAL                           = 467
	MySqlParserPARTITIONING                      = 468
	MySqlParserPARTITIONS                        = 469
	MySqlParserPASSWORD                          = 470
	MySqlParserPHASE                             = 471
	MySqlParserPLUGIN                            = 472
	MySqlParserPLUGIN_DIR                        = 473
	MySqlParserPLUGINS                           = 474
	MySqlParserPORT                              = 475
	MySqlParserPRECEDES                          = 476
	MySqlParserPREPARE                           = 477
	MySqlParserPRESERVE                          = 478
	MySqlParserPREV                              = 479
	MySqlParserPROCESSLIST                       = 480
	MySqlParserPROFILE                           = 481
	MySqlParserPROFILES                          = 482
	MySqlParserPROXY                             = 483
	MySqlParserQUERY                             = 484
	MySqlParserQUICK                             = 485
	MySqlParserREBUILD                           = 486
	MySqlParserRECOVER                           = 487
	MySqlParserREDO_BUFFER_SIZE                  = 488
	MySqlParserREDUNDANT                         = 489
	MySqlParserRELAY                             = 490
	MySqlParserRELAY_LOG_FILE                    = 491
	MySqlParserRELAY_LOG_POS                     = 492
	MySqlParserRELAYLOG                          = 493
	MySqlParserREMOVE                            = 494
	MySqlParserREORGANIZE                        = 495
	MySqlParserREPAIR                            = 496
	MySqlParserREPLICATE_DO_DB                   = 497
	MySqlParserREPLICATE_DO_TABLE                = 498
	MySqlParserREPLICATE_IGNORE_DB               = 499
	MySqlParserREPLICATE_IGNORE_TABLE            = 500
	MySqlParserREPLICATE_REWRITE_DB              = 501
	MySqlParserREPLICATE_WILD_DO_TABLE           = 502
	MySqlParserREPLICATE_WILD_IGNORE_TABLE       = 503
	MySqlParserREPLICATION                       = 504
	MySqlParserRESET                             = 505
	MySqlParserRESUME                            = 506
	MySqlParserRETURNED_SQLSTATE                 = 507
	MySqlParserRETURNS                           = 508
	MySqlParserROLE                              = 509
	MySqlParserROLLBACK                          = 510
	MySqlParserROLLUP                            = 511
	MySqlParserROTATE                            = 512
	MySqlParserROW                               = 513
	MySqlParserROWS                              = 514
	MySqlParserROW_FORMAT                        = 515
	MySqlParserSAVEPOINT                         = 516
	MySqlParserSCHEDULE                          = 517
	MySqlParserSECURITY                          = 518
	MySqlParserSERVER                            = 519
	MySqlParserSESSION                           = 520
	MySqlParserSHARE                             = 521
	MySqlParserSHARED                            = 522
	MySqlParserSIGNED                            = 523
	MySqlParserSIMPLE                            = 524
	MySqlParserSLAVE                             = 525
	MySqlParserSLOW                              = 526
	MySqlParserSNAPSHOT                          = 527
	MySqlParserSOCKET                            = 528
	MySqlParserSOME                              = 529
	MySqlParserSONAME                            = 530
	MySqlParserSOUNDS                            = 531
	MySqlParserSOURCE                            = 532
	MySqlParserSQL_AFTER_GTIDS                   = 533
	MySqlParserSQL_AFTER_MTS_GAPS                = 534
	MySqlParserSQL_BEFORE_GTIDS                  = 535
	MySqlParserSQL_BUFFER_RESULT                 = 536
	MySqlParserSQL_CACHE                         = 537
	MySqlParserSQL_NO_CACHE                      = 538
	MySqlParserSQL_THREAD                        = 539
	MySqlParserSTART                             = 540
	MySqlParserSTARTS                            = 541
	MySqlParserSTATS_AUTO_RECALC                 = 542
	MySqlParserSTATS_PERSISTENT                  = 543
	MySqlParserSTATS_SAMPLE_PAGES                = 544
	MySqlParserSTATUS                            = 545
	MySqlParserSTOP                              = 546
	MySqlParserSTORAGE                           = 547
	MySqlParserSTORED                            = 548
	MySqlParserSTRING                            = 549
	MySqlParserSUBCLASS_ORIGIN                   = 550
	MySqlParserSUBJECT                           = 551
	MySqlParserSUBPARTITION                      = 552
	MySqlParserSUBPARTITIONS                     = 553
	MySqlParserSUSPEND                           = 554
	MySqlParserSWAPS                             = 555
	MySqlParserSWITCHES                          = 556
	MySqlParserTABLE_NAME                        = 557
	MySqlParserTABLESPACE                        = 558
	MySqlParserTEMPORARY                         = 559
	MySqlParserTEMPTABLE                         = 560
	MySqlParserTHAN                              = 561
	MySqlParserTRADITIONAL                       = 562
	MySqlParserTRANSACTION                       = 563
	MySqlParserTRANSACTIONAL                     = 564
	MySqlParserTRIGGERS                          = 565
	MySqlParserTRUNCATE                          = 566
	MySqlParserUNDEFINED                         = 567
	MySqlParserUNDOFILE                          = 568
	MySqlParserUNDO_BUFFER_SIZE                  = 569
	MySqlParserUNINSTALL                         = 570
	MySqlParserUNKNOWN                           = 571
	MySqlParserUNTIL                             = 572
	MySqlParserUPGRADE                           = 573
	MySqlParserUSER                              = 574
	MySqlParserUSE_FRM                           = 575
	MySqlParserUSER_RESOURCES                    = 576
	MySqlParserVALIDATION                        = 577
	MySqlParserVALUE                             = 578
	MySqlParserVARIABLES                         = 579
	MySqlParserVIEW                              = 580
	MySqlParserVIRTUAL                           = 581
	MySqlParserVISIBLE                           = 582
	MySqlParserWAIT                              = 583
	MySqlParserWARNINGS                          = 584
	MySqlParserWITHOUT                           = 585
	MySqlParserWORK                              = 586
	MySqlParserWRAPPER                           = 587
	MySqlParserX509                              = 588
	MySqlParserXA                                = 589
	MySqlParserXML                               = 590
	MySqlParserEUR                               = 591
	MySqlParserUSA                               = 592
	MySqlParserJIS                               = 593
	MySqlParserISO                               = 594
	MySqlParserINTERNAL                          = 595
	MySqlParserQUARTER                           = 596
	MySqlParserMONTH                             = 597
	MySqlParserDAY                               = 598
	MySqlParserHOUR                              = 599
	MySqlParserMINUTE                            = 600
	MySqlParserWEEK                              = 601
	MySqlParserSECOND                            = 602
	MySqlParserMICROSECOND                       = 603
	MySqlParserTABLES                            = 604
	MySqlParserROUTINE                           = 605
	MySqlParserEXECUTE                           = 606
	MySqlParserFILE                              = 607
	MySqlParserPROCESS                           = 608
	MySqlParserRELOAD                            = 609
	MySqlParserSHUTDOWN                          = 610
	MySqlParserSUPER                             = 611
	MySqlParserPRIVILEGES                        = 612
	MySqlParserAPPLICATION_PASSWORD_ADMIN        = 613
	MySqlParserAUDIT_ADMIN                       = 614
	MySqlParserBACKUP_ADMIN                      = 615
	MySqlParserBINLOG_ADMIN                      = 616
	MySqlParserBINLOG_ENCRYPTION_ADMIN           = 617
	MySqlParserCLONE_ADMIN                       = 618
	MySqlParserCONNECTION_ADMIN                  = 619
	MySqlParserENCRYPTION_KEY_ADMIN              = 620
	MySqlParserFIREWALL_ADMIN                    = 621
	MySqlParserFIREWALL_USER                     = 622
	MySqlParserGROUP_REPLICATION_ADMIN           = 623
	MySqlParserINNODB_REDO_LOG_ARCHIVE           = 624
	MySqlParserNDB_STORED_USER                   = 625
	MySqlParserPERSIST_RO_VARIABLES_ADMIN        = 626
	MySqlParserREPLICATION_APPLIER               = 627
	MySqlParserREPLICATION_SLAVE_ADMIN           = 628
	MySqlParserRESOURCE_GROUP_ADMIN              = 629
	MySqlParserRESOURCE_GROUP_USER               = 630
	MySqlParserROLE_ADMIN                        = 631
	MySqlParserSESSION_VARIABLES_ADMIN           = 632
	MySqlParserSET_USER_ID                       = 633
	MySqlParserSHOW_ROUTINE                      = 634
	MySqlParserSYSTEM_VARIABLES_ADMIN            = 635
	MySqlParserTABLE_ENCRYPTION_ADMIN            = 636
	MySqlParserVERSION_TOKEN_ADMIN               = 637
	MySqlParserXA_RECOVER_ADMIN                  = 638
	MySqlParserARMSCII8                          = 639
	MySqlParserASCII                             = 640
	MySqlParserBIG5                              = 641
	MySqlParserCP1250                            = 642
	MySqlParserCP1251                            = 643
	MySqlParserCP1256                            = 644
	MySqlParserCP1257                            = 645
	MySqlParserCP850                             = 646
	MySqlParserCP852                             = 647
	MySqlParserCP866                             = 648
	MySqlParserCP932                             = 649
	MySqlParserDEC8                              = 650
	MySqlParserEUCJPMS                           = 651
	MySqlParserEUCKR                             = 652
	MySqlParserGB2312                            = 653
	MySqlParserGBK                               = 654
	MySqlParserGEOSTD8                           = 655
	MySqlParserGREEK                             = 656
	MySqlParserHEBREW                            = 657
	MySqlParserHP8                               = 658
	MySqlParserKEYBCS2                           = 659
	MySqlParserKOI8R                             = 660
	MySqlParserKOI8U                             = 661
	MySqlParserLATIN1                            = 662
	MySqlParserLATIN2                            = 663
	MySqlParserLATIN5                            = 664
	MySqlParserLATIN7                            = 665
	MySqlParserMACCE                             = 666
	MySqlParserMACROMAN                          = 667
	MySqlParserSJIS                              = 668
	MySqlParserSWE7                              = 669
	MySqlParserTIS620                            = 670
	MySqlParserUCS2                              = 671
	MySqlParserUJIS                              = 672
	MySqlParserUTF16                             = 673
	MySqlParserUTF16LE                           = 674
	MySqlParserUTF32                             = 675
	MySqlParserUTF8                              = 676
	MySqlParserUTF8MB3                           = 677
	MySqlParserUTF8MB4                           = 678
	MySqlParserARCHIVE                           = 679
	MySqlParserBLACKHOLE                         = 680
	MySqlParserCSV                               = 681
	MySqlParserFEDERATED                         = 682
	MySqlParserINNODB                            = 683
	MySqlParserMEMORY                            = 684
	MySqlParserMRG_MYISAM                        = 685
	MySqlParserMYISAM                            = 686
	MySqlParserNDB                               = 687
	MySqlParserNDBCLUSTER                        = 688
	MySqlParserPERFORMANCE_SCHEMA                = 689
	MySqlParserTOKUDB                            = 690
	MySqlParserREPEATABLE                        = 691
	MySqlParserCOMMITTED                         = 692
	MySqlParserUNCOMMITTED                       = 693
	MySqlParserSERIALIZABLE                      = 694
	MySqlParserGEOMETRYCOLLECTION                = 695
	MySqlParserGEOMCOLLECTION                    = 696
	MySqlParserGEOMETRY                          = 697
	MySqlParserLINESTRING                        = 698
	MySqlParserMULTILINESTRING                   = 699
	MySqlParserMULTIPOINT                        = 700
	MySqlParserMULTIPOLYGON                      = 701
	MySqlParserPOINT                             = 702
	MySqlParserPOLYGON                           = 703
	MySqlParserABS                               = 704
	MySqlParserACOS                              = 705
	MySqlParserADDDATE                           = 706
	MySqlParserADDTIME                           = 707
	MySqlParserAES_DECRYPT                       = 708
	MySqlParserAES_ENCRYPT                       = 709
	MySqlParserAREA                              = 710
	MySqlParserASBINARY                          = 711
	MySqlParserASIN                              = 712
	MySqlParserASTEXT                            = 713
	MySqlParserASWKB                             = 714
	MySqlParserASWKT                             = 715
	MySqlParserASYMMETRIC_DECRYPT                = 716
	MySqlParserASYMMETRIC_DERIVE                 = 717
	MySqlParserASYMMETRIC_ENCRYPT                = 718
	MySqlParserASYMMETRIC_SIGN                   = 719
	MySqlParserASYMMETRIC_VERIFY                 = 720
	MySqlParserATAN                              = 721
	MySqlParserATAN2                             = 722
	MySqlParserBENCHMARK                         = 723
	MySqlParserBIN                               = 724
	MySqlParserBIT_COUNT                         = 725
	MySqlParserBIT_LENGTH                        = 726
	MySqlParserBUFFER                            = 727
	MySqlParserCATALOG_NAME                      = 728
	MySqlParserCEIL                              = 729
	MySqlParserCEILING                           = 730
	MySqlParserCENTROID                          = 731
	MySqlParserCHARACTER_LENGTH                  = 732
	MySqlParserCHARSET                           = 733
	MySqlParserCHAR_LENGTH                       = 734
	MySqlParserCOERCIBILITY                      = 735
	MySqlParserCOLLATION                         = 736
	MySqlParserCOMPRESS                          = 737
	MySqlParserCONCAT                            = 738
	MySqlParserCONCAT_WS                         = 739
	MySqlParserCONNECTION_ID                     = 740
	MySqlParserCONV                              = 741
	MySqlParserCONVERT_TZ                        = 742
	MySqlParserCOS                               = 743
	MySqlParserCOT                               = 744
	MySqlParserCRC32                             = 745
	MySqlParserCREATE_ASYMMETRIC_PRIV_KEY        = 746
	MySqlParserCREATE_ASYMMETRIC_PUB_KEY         = 747
	MySqlParserCREATE_DH_PARAMETERS              = 748
	MySqlParserCREATE_DIGEST                     = 749
	MySqlParserCROSSES                           = 750
	MySqlParserDATEDIFF                          = 751
	MySqlParserDATE_FORMAT                       = 752
	MySqlParserDAYNAME                           = 753
	MySqlParserDAYOFMONTH                        = 754
	MySqlParserDAYOFWEEK                         = 755
	MySqlParserDAYOFYEAR                         = 756
	MySqlParserDECODE                            = 757
	MySqlParserDEGREES                           = 758
	MySqlParserDES_DECRYPT                       = 759
	MySqlParserDES_ENCRYPT                       = 760
	MySqlParserDIMENSION                         = 761
	MySqlParserDISJOINT                          = 762
	MySqlParserELT                               = 763
	MySqlParserENCODE                            = 764
	MySqlParserENCRYPT                           = 765
	MySqlParserENDPOINT                          = 766
	MySqlParserENVELOPE                          = 767
	MySqlParserEQUALS                            = 768
	MySqlParserEXP                               = 769
	MySqlParserEXPORT_SET                        = 770
	MySqlParserEXTERIORRING                      = 771
	MySqlParserEXTRACTVALUE                      = 772
	MySqlParserFIELD                             = 773
	MySqlParserFIND_IN_SET                       = 774
	MySqlParserFLOOR                             = 775
	MySqlParserFORMAT                            = 776
	MySqlParserFOUND_ROWS                        = 777
	MySqlParserFROM_BASE64                       = 778
	MySqlParserFROM_DAYS                         = 779
	MySqlParserFROM_UNIXTIME                     = 780
	MySqlParserGEOMCOLLFROMTEXT                  = 781
	MySqlParserGEOMCOLLFROMWKB                   = 782
	MySqlParserGEOMETRYCOLLECTIONFROMTEXT        = 783
	MySqlParserGEOMETRYCOLLECTIONFROMWKB         = 784
	MySqlParserGEOMETRYFROMTEXT                  = 785
	MySqlParserGEOMETRYFROMWKB                   = 786
	MySqlParserGEOMETRYN                         = 787
	MySqlParserGEOMETRYTYPE                      = 788
	MySqlParserGEOMFROMTEXT                      = 789
	MySqlParserGEOMFROMWKB                       = 790
	MySqlParserGET_FORMAT                        = 791
	MySqlParserGET_LOCK                          = 792
	MySqlParserGLENGTH                           = 793
	MySqlParserGREATEST                          = 794
	MySqlParserGTID_SUBSET                       = 795
	MySqlParserGTID_SUBTRACT                     = 796
	MySqlParserHEX                               = 797
	MySqlParserIFNULL                            = 798
	MySqlParserINET6_ATON                        = 799
	MySqlParserINET6_NTOA                        = 800
	MySqlParserINET_ATON                         = 801
	MySqlParserINET_NTOA                         = 802
	MySqlParserINSTR                             = 803
	MySqlParserINTERIORRINGN                     = 804
	MySqlParserINTERSECTS                        = 805
	MySqlParserISCLOSED                          = 806
	MySqlParserISEMPTY                           = 807
	MySqlParserISNULL                            = 808
	MySqlParserISSIMPLE                          = 809
	MySqlParserIS_FREE_LOCK                      = 810
	MySqlParserIS_IPV4                           = 811
	MySqlParserIS_IPV4_COMPAT                    = 812
	MySqlParserIS_IPV4_MAPPED                    = 813
	MySqlParserIS_IPV6                           = 814
	MySqlParserIS_USED_LOCK                      = 815
	MySqlParserLAST_INSERT_ID                    = 816
	MySqlParserLCASE                             = 817
	MySqlParserLEAST                             = 818
	MySqlParserLENGTH                            = 819
	MySqlParserLINEFROMTEXT                      = 820
	MySqlParserLINEFROMWKB                       = 821
	MySqlParserLINESTRINGFROMTEXT                = 822
	MySqlParserLINESTRINGFROMWKB                 = 823
	MySqlParserLN                                = 824
	MySqlParserLOAD_FILE                         = 825
	MySqlParserLOCATE                            = 826
	MySqlParserLOG                               = 827
	MySqlParserLOG10                             = 828
	MySqlParserLOG2                              = 829
	MySqlParserLOWER                             = 830
	MySqlParserLPAD                              = 831
	MySqlParserLTRIM                             = 832
	MySqlParserMAKEDATE                          = 833
	MySqlParserMAKETIME                          = 834
	MySqlParserMAKE_SET                          = 835
	MySqlParserMASTER_POS_WAIT                   = 836
	MySqlParserMBRCONTAINS                       = 837
	MySqlParserMBRDISJOINT                       = 838
	MySqlParserMBREQUAL                          = 839
	MySqlParserMBRINTERSECTS                     = 840
	MySqlParserMBROVERLAPS                       = 841
	MySqlParserMBRTOUCHES                        = 842
	MySqlParserMBRWITHIN                         = 843
	MySqlParserMD5                               = 844
	MySqlParserMLINEFROMTEXT                     = 845
	MySqlParserMLINEFROMWKB                      = 846
	MySqlParserMONTHNAME                         = 847
	MySqlParserMPOINTFROMTEXT                    = 848
	MySqlParserMPOINTFROMWKB                     = 849
	MySqlParserMPOLYFROMTEXT                     = 850
	MySqlParserMPOLYFROMWKB                      = 851
	MySqlParserMULTILINESTRINGFROMTEXT           = 852
	MySqlParserMULTILINESTRINGFROMWKB            = 853
	MySqlParserMULTIPOINTFROMTEXT                = 854
	MySqlParserMULTIPOINTFROMWKB                 = 855
	MySqlParserMULTIPOLYGONFROMTEXT              = 856
	MySqlParserMULTIPOLYGONFROMWKB               = 857
	MySqlParserNAME_CONST                        = 858
	MySqlParserNULLIF                            = 859
	MySqlParserNUMGEOMETRIES                     = 860
	MySqlParserNUMINTERIORRINGS                  = 861
	MySqlParserNUMPOINTS                         = 862
	MySqlParserOCT                               = 863
	MySqlParserOCTET_LENGTH                      = 864
	MySqlParserORD                               = 865
	MySqlParserOVERLAPS                          = 866
	MySqlParserPERIOD_ADD                        = 867
	MySqlParserPERIOD_DIFF                       = 868
	MySqlParserPI                                = 869
	MySqlParserPOINTFROMTEXT                     = 870
	MySqlParserPOINTFROMWKB                      = 871
	MySqlParserPOINTN                            = 872
	MySqlParserPOLYFROMTEXT                      = 873
	MySqlParserPOLYFROMWKB                       = 874
	MySqlParserPOLYGONFROMTEXT                   = 875
	MySqlParserPOLYGONFROMWKB                    = 876
	MySqlParserPOW                               = 877
	MySqlParserPOWER                             = 878
	MySqlParserQUOTE                             = 879
	MySqlParserRADIANS                           = 880
	MySqlParserRAND                              = 881
	MySqlParserRANDOM_BYTES                      = 882
	MySqlParserRELEASE_LOCK                      = 883
	MySqlParserREVERSE                           = 884
	MySqlParserROUND                             = 885
	MySqlParserROW_COUNT                         = 886
	MySqlParserRPAD                              = 887
	MySqlParserRTRIM                             = 888
	MySqlParserSEC_TO_TIME                       = 889
	MySqlParserSESSION_USER                      = 890
	MySqlParserSHA                               = 891
	MySqlParserSHA1                              = 892
	MySqlParserSHA2                              = 893
	MySqlParserSCHEMA_NAME                       = 894
	MySqlParserSIGN                              = 895
	MySqlParserSIN                               = 896
	MySqlParserSLEEP                             = 897
	MySqlParserSOUNDEX                           = 898
	MySqlParserSQL_THREAD_WAIT_AFTER_GTIDS       = 899
	MySqlParserSQRT                              = 900
	MySqlParserSRID                              = 901
	MySqlParserSTARTPOINT                        = 902
	MySqlParserSTRCMP                            = 903
	MySqlParserSTR_TO_DATE                       = 904
	MySqlParserST_AREA                           = 905
	MySqlParserST_ASBINARY                       = 906
	MySqlParserST_ASTEXT                         = 907
	MySqlParserST_ASWKB                          = 908
	MySqlParserST_ASWKT                          = 909
	MySqlParserST_BUFFER                         = 910
	MySqlParserST_CENTROID                       = 911
	MySqlParserST_CONTAINS                       = 912
	MySqlParserST_CROSSES                        = 913
	MySqlParserST_DIFFERENCE                     = 914
	MySqlParserST_DIMENSION                      = 915
	MySqlParserST_DISJOINT                       = 916
	MySqlParserST_DISTANCE                       = 917
	MySqlParserST_ENDPOINT                       = 918
	MySqlParserST_ENVELOPE                       = 919
	MySqlParserST_EQUALS                         = 920
	MySqlParserST_EXTERIORRING                   = 921
	MySqlParserST_GEOMCOLLFROMTEXT               = 922
	MySqlParserST_GEOMCOLLFROMTXT                = 923
	MySqlParserST_GEOMCOLLFROMWKB                = 924
	MySqlParserST_GEOMETRYCOLLECTIONFROMTEXT     = 925
	MySqlParserST_GEOMETRYCOLLECTIONFROMWKB      = 926
	MySqlParserST_GEOMETRYFROMTEXT               = 927
	MySqlParserST_GEOMETRYFROMWKB                = 928
	MySqlParserST_GEOMETRYN                      = 929
	MySqlParserST_GEOMETRYTYPE                   = 930
	MySqlParserST_GEOMFROMTEXT                   = 931
	MySqlParserST_GEOMFROMWKB                    = 932
	MySqlParserST_INTERIORRINGN                  = 933
	MySqlParserST_INTERSECTION                   = 934
	MySqlParserST_INTERSECTS                     = 935
	MySqlParserST_ISCLOSED                       = 936
	MySqlParserST_ISEMPTY                        = 937
	MySqlParserST_ISSIMPLE                       = 938
	MySqlParserST_LINEFROMTEXT                   = 939
	MySqlParserST_LINEFROMWKB                    = 940
	MySqlParserST_LINESTRINGFROMTEXT             = 941
	MySqlParserST_LINESTRINGFROMWKB              = 942
	MySqlParserST_NUMGEOMETRIES                  = 943
	MySqlParserST_NUMINTERIORRING                = 944
	MySqlParserST_NUMINTERIORRINGS               = 945
	MySqlParserST_NUMPOINTS                      = 946
	MySqlParserST_OVERLAPS                       = 947
	MySqlParserST_POINTFROMTEXT                  = 948
	MySqlParserST_POINTFROMWKB                   = 949
	MySqlParserST_POINTN                         = 950
	MySqlParserST_POLYFROMTEXT                   = 951
	MySqlParserST_POLYFROMWKB                    = 952
	MySqlParserST_POLYGONFROMTEXT                = 953
	MySqlParserST_POLYGONFROMWKB                 = 954
	MySqlParserST_SRID                           = 955
	MySqlParserST_STARTPOINT                     = 956
	MySqlParserST_SYMDIFFERENCE                  = 957
	MySqlParserST_TOUCHES                        = 958
	MySqlParserST_UNION                          = 959
	MySqlParserST_WITHIN                         = 960
	MySqlParserST_X                              = 961
	MySqlParserST_Y                              = 962
	MySqlParserSUBDATE                           = 963
	MySqlParserSUBSTRING_INDEX                   = 964
	MySqlParserSUBTIME                           = 965
	MySqlParserSYSTEM_USER                       = 966
	MySqlParserTAN                               = 967
	MySqlParserTIMEDIFF                          = 968
	MySqlParserTIMESTAMPADD                      = 969
	MySqlParserTIMESTAMPDIFF                     = 970
	MySqlParserTIME_FORMAT                       = 971
	MySqlParserTIME_TO_SEC                       = 972
	MySqlParserTOUCHES                           = 973
	MySqlParserTO_BASE64                         = 974
	MySqlParserTO_DAYS                           = 975
	MySqlParserTO_SECONDS                        = 976
	MySqlParserUCASE                             = 977
	MySqlParserUNCOMPRESS                        = 978
	MySqlParserUNCOMPRESSED_LENGTH               = 979
	MySqlParserUNHEX                             = 980
	MySqlParserUNIX_TIMESTAMP                    = 981
	MySqlParserUPDATEXML                         = 982
	MySqlParserUPPER                             = 983
	MySqlParserUUID                              = 984
	MySqlParserUUID_SHORT                        = 985
	MySqlParserVALIDATE_PASSWORD_STRENGTH        = 986
	MySqlParserVERSION                           = 987
	MySqlParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS = 988
	MySqlParserWEEKDAY                           = 989
	MySqlParserWEEKOFYEAR                        = 990
	MySqlParserWEIGHT_STRING                     = 991
	MySqlParserWITHIN                            = 992
	MySqlParserYEARWEEK                          = 993
	MySqlParserY_FUNCTION                        = 994
	MySqlParserX_FUNCTION                        = 995
	MySqlParserVAR_ASSIGN                        = 996
	MySqlParserPLUS_ASSIGN                       = 997
	MySqlParserMINUS_ASSIGN                      = 998
	MySqlParserMULT_ASSIGN                       = 999
	MySqlParserDIV_ASSIGN                        = 1000
	MySqlParserMOD_ASSIGN                        = 1001
	MySqlParserAND_ASSIGN                        = 1002
	MySqlParserXOR_ASSIGN                        = 1003
	MySqlParserOR_ASSIGN                         = 1004
	MySqlParserSTAR                              = 1005
	MySqlParserDIVIDE                            = 1006
	MySqlParserMODULE                            = 1007
	MySqlParserPLUS                              = 1008
	MySqlParserMINUSMINUS                        = 1009
	MySqlParserMINUS                             = 1010
	MySqlParserDIV                               = 1011
	MySqlParserMOD                               = 1012
	MySqlParserEQUAL_SYMBOL                      = 1013
	MySqlParserGREATER_SYMBOL                    = 1014
	MySqlParserLESS_SYMBOL                       = 1015
	MySqlParserEXCLAMATION_SYMBOL                = 1016
	MySqlParserBIT_NOT_OP                        = 1017
	MySqlParserBIT_OR_OP                         = 1018
	MySqlParserBIT_AND_OP                        = 1019
	MySqlParserBIT_XOR_OP                        = 1020
	MySqlParserDOT                               = 1021
	MySqlParserLR_BRACKET                        = 1022
	MySqlParserRR_BRACKET                        = 1023
	MySqlParserCOMMA                             = 1024
	MySqlParserSEMI                              = 1025
	MySqlParserAT_SIGN                           = 1026
	MySqlParserZERO_DECIMAL                      = 1027
	MySqlParserONE_DECIMAL                       = 1028
	MySqlParserTWO_DECIMAL                       = 1029
	MySqlParserSINGLE_QUOTE_SYMB                 = 1030
	MySqlParserDOUBLE_QUOTE_SYMB                 = 1031
	MySqlParserREVERSE_QUOTE_SYMB                = 1032
	MySqlParserCOLON_SYMB                        = 1033
	MySqlParserCHARSET_REVERSE_QOUTE_STRING      = 1034
	MySqlParserFILESIZE_LITERAL                  = 1035
	MySqlParserSTART_NATIONAL_STRING_LITERAL     = 1036
	MySqlParserSTRING_LITERAL                    = 1037
	MySqlParserDECIMAL_LITERAL                   = 1038
	MySqlParserHEXADECIMAL_LITERAL               = 1039
	MySqlParserREAL_LITERAL                      = 1040
	MySqlParserNULL_SPEC_LITERAL                 = 1041
	MySqlParserBIT_STRING                        = 1042
	MySqlParserSTRING_CHARSET_NAME               = 1043
	MySqlParserDOT_ID                            = 1044
	MySqlParserID                                = 1045
	MySqlParserREVERSE_QUOTE_ID                  = 1046
	MySqlParserSTRING_USER_NAME                  = 1047
	MySqlParserLOCAL_ID                          = 1048
	MySqlParserGLOBAL_ID                         = 1049
	MySqlParserERROR_RECONGNIGION                = 1050
)

// MySqlParser rules.
const (
	MySqlParserRULE_root                       = 0
	MySqlParserRULE_selectStatement            = 1
	MySqlParserRULE_assignmentField            = 2
	MySqlParserRULE_lockClause                 = 3
	MySqlParserRULE_orderByClause              = 4
	MySqlParserRULE_orderByExpression          = 5
	MySqlParserRULE_tableSources               = 6
	MySqlParserRULE_tableSource                = 7
	MySqlParserRULE_tableSourceItem            = 8
	MySqlParserRULE_indexHint                  = 9
	MySqlParserRULE_indexHintType              = 10
	MySqlParserRULE_joinPart                   = 11
	MySqlParserRULE_queryExpression            = 12
	MySqlParserRULE_queryExpressionNointo      = 13
	MySqlParserRULE_querySpecification         = 14
	MySqlParserRULE_querySpecificationNointo   = 15
	MySqlParserRULE_unionParenthesis           = 16
	MySqlParserRULE_unionStatement             = 17
	MySqlParserRULE_unionStatement2            = 18
	MySqlParserRULE_unionstatement3            = 19
	MySqlParserRULE_selectSpec                 = 20
	MySqlParserRULE_selectElements             = 21
	MySqlParserRULE_selectElement              = 22
	MySqlParserRULE_selectIntoExpression       = 23
	MySqlParserRULE_selectFieldsInto           = 24
	MySqlParserRULE_selectLinesInto            = 25
	MySqlParserRULE_fromClause                 = 26
	MySqlParserRULE_groupByItem                = 27
	MySqlParserRULE_limitClause                = 28
	MySqlParserRULE_limitClauseAtom            = 29
	MySqlParserRULE_fullId                     = 30
	MySqlParserRULE_tableName                  = 31
	MySqlParserRULE_fullColumnName             = 32
	MySqlParserRULE_mysqlVariable              = 33
	MySqlParserRULE_charsetName                = 34
	MySqlParserRULE_uid                        = 35
	MySqlParserRULE_engineName                 = 36
	MySqlParserRULE_simpleId                   = 37
	MySqlParserRULE_dottedId                   = 38
	MySqlParserRULE_collationName              = 39
	MySqlParserRULE_decimalLiteral             = 40
	MySqlParserRULE_stringLiteral              = 41
	MySqlParserRULE_nullNotnull                = 42
	MySqlParserRULE_booleanLiteral             = 43
	MySqlParserRULE_hexadecimalLiteral         = 44
	MySqlParserRULE_constant                   = 45
	MySqlParserRULE_dataType                   = 46
	MySqlParserRULE_collectionOptions          = 47
	MySqlParserRULE_convertedDataType          = 48
	MySqlParserRULE_lengthOneDimension         = 49
	MySqlParserRULE_lengthTwoDimension         = 50
	MySqlParserRULE_lengthTwoOptionalDimension = 51
	MySqlParserRULE_uidList                    = 52
	MySqlParserRULE_expressions                = 53
	MySqlParserRULE_intervalType               = 54
	MySqlParserRULE_functionCall               = 55
	MySqlParserRULE_specificFunction           = 56
	MySqlParserRULE_caseFuncAlternative        = 57
	MySqlParserRULE_levelsInWeightString       = 58
	MySqlParserRULE_levelInWeightListElement   = 59
	MySqlParserRULE_aggregateWindowedFunction  = 60
	MySqlParserRULE_scalarFunctionName         = 61
	MySqlParserRULE_passwordFunctionClause     = 62
	MySqlParserRULE_functionArgs               = 63
	MySqlParserRULE_functionArg                = 64
	MySqlParserRULE_expression                 = 65
	MySqlParserRULE_predicate                  = 66
	MySqlParserRULE_expressionAtom             = 67
	MySqlParserRULE_unaryOperator              = 68
	MySqlParserRULE_comparisonOperator         = 69
	MySqlParserRULE_logicalOperator            = 70
	MySqlParserRULE_bitOperator                = 71
	MySqlParserRULE_mathOperator               = 72
	MySqlParserRULE_jsonOperator               = 73
	MySqlParserRULE_charsetNameBase            = 74
	MySqlParserRULE_transactionLevelBase       = 75
	MySqlParserRULE_privilegesBase             = 76
	MySqlParserRULE_intervalTypeBase           = 77
	MySqlParserRULE_dataTypeBase               = 78
	MySqlParserRULE_keywordsCanBeId            = 79
	MySqlParserRULE_functionNameBase           = 80
)

// IRootContext is an interface to support dynamic dispatch.
type IRootContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRootContext differentiates from other interfaces.
	IsRootContext()
}

type RootContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRootContext() *RootContext {
	var p = new(RootContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_root
	return p
}

func (*RootContext) IsRootContext() {}

func NewRootContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RootContext {
	var p = new(RootContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_root

	return p
}

func (s *RootContext) GetParser() antlr.Parser { return s.parser }

func (s *RootContext) SelectStatement() ISelectStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelectStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelectStatementContext)
}

func (s *RootContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RootContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RootContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterRoot(s)
	}
}

func (s *RootContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitRoot(s)
	}
}

func (s *RootContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitRoot(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) Root() (localctx IRootContext) {
	localctx = NewRootContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, MySqlParserRULE_root)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(162)
		p.SelectStatement()
	}

	return localctx
}

// ISelectStatementContext is an interface to support dynamic dispatch.
type ISelectStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSelectStatementContext differentiates from other interfaces.
	IsSelectStatementContext()
}

type SelectStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectStatementContext() *SelectStatementContext {
	var p = new(SelectStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_selectStatement
	return p
}

func (*SelectStatementContext) IsSelectStatementContext() {}

func NewSelectStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectStatementContext {
	var p = new(SelectStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_selectStatement

	return p
}

func (s *SelectStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectStatementContext) CopyFrom(ctx *SelectStatementContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *SelectStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type UnionSelectContext struct {
	*SelectStatementContext
}

func NewUnionSelectContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnionSelectContext {
	var p = new(UnionSelectContext)

	p.SelectStatementContext = NewEmptySelectStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SelectStatementContext))

	return p
}

func (s *UnionSelectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnionSelectContext) QuerySpecificationNointo() IQuerySpecificationNointoContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQuerySpecificationNointoContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQuerySpecificationNointoContext)
}

func (s *UnionSelectContext) AllUnionStatement() []IUnionStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IUnionStatementContext)(nil)).Elem())
	var tst = make([]IUnionStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IUnionStatementContext)
		}
	}

	return tst
}

func (s *UnionSelectContext) UnionStatement(i int) IUnionStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnionStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IUnionStatementContext)
}

func (s *UnionSelectContext) UnionStatement2() IUnionStatement2Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnionStatement2Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnionStatement2Context)
}

func (s *UnionSelectContext) OrderByClause() IOrderByClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOrderByClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOrderByClauseContext)
}

func (s *UnionSelectContext) LimitClause() ILimitClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILimitClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *UnionSelectContext) LockClause() ILockClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILockClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILockClauseContext)
}

func (s *UnionSelectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterUnionSelect(s)
	}
}

func (s *UnionSelectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitUnionSelect(s)
	}
}

func (s *UnionSelectContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitUnionSelect(s)

	default:
		return t.VisitChildren(s)
	}
}

type UnionParenthesisSelectContext struct {
	*SelectStatementContext
}

func NewUnionParenthesisSelectContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnionParenthesisSelectContext {
	var p = new(UnionParenthesisSelectContext)

	p.SelectStatementContext = NewEmptySelectStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SelectStatementContext))

	return p
}

func (s *UnionParenthesisSelectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnionParenthesisSelectContext) QueryExpressionNointo() IQueryExpressionNointoContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueryExpressionNointoContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQueryExpressionNointoContext)
}

func (s *UnionParenthesisSelectContext) AllUnionParenthesis() []IUnionParenthesisContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IUnionParenthesisContext)(nil)).Elem())
	var tst = make([]IUnionParenthesisContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IUnionParenthesisContext)
		}
	}

	return tst
}

func (s *UnionParenthesisSelectContext) UnionParenthesis(i int) IUnionParenthesisContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnionParenthesisContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IUnionParenthesisContext)
}

func (s *UnionParenthesisSelectContext) Unionstatement3() IUnionstatement3Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnionstatement3Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnionstatement3Context)
}

func (s *UnionParenthesisSelectContext) OrderByClause() IOrderByClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOrderByClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOrderByClauseContext)
}

func (s *UnionParenthesisSelectContext) LimitClause() ILimitClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILimitClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *UnionParenthesisSelectContext) LockClause() ILockClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILockClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILockClauseContext)
}

func (s *UnionParenthesisSelectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterUnionParenthesisSelect(s)
	}
}

func (s *UnionParenthesisSelectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitUnionParenthesisSelect(s)
	}
}

func (s *UnionParenthesisSelectContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitUnionParenthesisSelect(s)

	default:
		return t.VisitChildren(s)
	}
}

type SimpleSelectContext struct {
	*SelectStatementContext
}

func NewSimpleSelectContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleSelectContext {
	var p = new(SimpleSelectContext)

	p.SelectStatementContext = NewEmptySelectStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SelectStatementContext))

	return p
}

func (s *SimpleSelectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleSelectContext) QuerySpecification() IQuerySpecificationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQuerySpecificationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQuerySpecificationContext)
}

func (s *SimpleSelectContext) LockClause() ILockClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILockClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILockClauseContext)
}

func (s *SimpleSelectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSimpleSelect(s)
	}
}

func (s *SimpleSelectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSimpleSelect(s)
	}
}

func (s *SimpleSelectContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSimpleSelect(s)

	default:
		return t.VisitChildren(s)
	}
}

type ParenthesisSelectContext struct {
	*SelectStatementContext
}

func NewParenthesisSelectContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ParenthesisSelectContext {
	var p = new(ParenthesisSelectContext)

	p.SelectStatementContext = NewEmptySelectStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SelectStatementContext))

	return p
}

func (s *ParenthesisSelectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParenthesisSelectContext) QueryExpression() IQueryExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueryExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQueryExpressionContext)
}

func (s *ParenthesisSelectContext) LockClause() ILockClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILockClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILockClauseContext)
}

func (s *ParenthesisSelectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterParenthesisSelect(s)
	}
}

func (s *ParenthesisSelectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitParenthesisSelect(s)
	}
}

func (s *ParenthesisSelectContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitParenthesisSelect(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) SelectStatement() (localctx ISelectStatementContext) {
	localctx = NewSelectStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, MySqlParserRULE_selectStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(208)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 12, p.GetParserRuleContext()) {
	case 1:
		localctx = NewSimpleSelectContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(164)
			p.QuerySpecification()
		}
		p.SetState(166)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserFOR || _la == MySqlParserLOCK {
			{
				p.SetState(165)
				p.LockClause()
			}

		}

	case 2:
		localctx = NewParenthesisSelectContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(168)
			p.QueryExpression()
		}
		p.SetState(170)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserFOR || _la == MySqlParserLOCK {
			{
				p.SetState(169)
				p.LockClause()
			}

		}

	case 3:
		localctx = NewUnionSelectContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(172)
			p.QuerySpecificationNointo()
		}
		p.SetState(174)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(173)
					p.UnionStatement()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(176)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 2, p.GetParserRuleContext())
		}
		p.SetState(179)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserUNION {
			{
				p.SetState(178)
				p.UnionStatement2()
			}

		}
		p.SetState(182)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserORDER {
			{
				p.SetState(181)
				p.OrderByClause()
			}

		}
		p.SetState(185)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserLIMIT {
			{
				p.SetState(184)
				p.LimitClause()
			}

		}
		p.SetState(188)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserFOR || _la == MySqlParserLOCK {
			{
				p.SetState(187)
				p.LockClause()
			}

		}

	case 4:
		localctx = NewUnionParenthesisSelectContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(190)
			p.QueryExpressionNointo()
		}
		p.SetState(192)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(191)
					p.UnionParenthesis()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(194)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 7, p.GetParserRuleContext())
		}
		p.SetState(197)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserUNION {
			{
				p.SetState(196)
				p.Unionstatement3()
			}

		}
		p.SetState(200)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserORDER {
			{
				p.SetState(199)
				p.OrderByClause()
			}

		}
		p.SetState(203)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserLIMIT {
			{
				p.SetState(202)
				p.LimitClause()
			}

		}
		p.SetState(206)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserFOR || _la == MySqlParserLOCK {
			{
				p.SetState(205)
				p.LockClause()
			}

		}

	}

	return localctx
}

// IAssignmentFieldContext is an interface to support dynamic dispatch.
type IAssignmentFieldContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssignmentFieldContext differentiates from other interfaces.
	IsAssignmentFieldContext()
}

type AssignmentFieldContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentFieldContext() *AssignmentFieldContext {
	var p = new(AssignmentFieldContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_assignmentField
	return p
}

func (*AssignmentFieldContext) IsAssignmentFieldContext() {}

func NewAssignmentFieldContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentFieldContext {
	var p = new(AssignmentFieldContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_assignmentField

	return p
}

func (s *AssignmentFieldContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentFieldContext) Uid() IUidContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUidContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AssignmentFieldContext) LOCAL_ID() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCAL_ID, 0)
}

func (s *AssignmentFieldContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentFieldContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentFieldContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAssignmentField(s)
	}
}

func (s *AssignmentFieldContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAssignmentField(s)
	}
}

func (s *AssignmentFieldContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAssignmentField(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) AssignmentField() (localctx IAssignmentFieldContext) {
	localctx = NewAssignmentFieldContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, MySqlParserRULE_assignmentField)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(212)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case MySqlParserCURRENT, MySqlParserDATABASE, MySqlParserDIAGNOSTICS, MySqlParserLEFT, MySqlParserNUMBER, MySqlParserRIGHT, MySqlParserSTACKED, MySqlParserDATE, MySqlParserTIME, MySqlParserTIMESTAMP, MySqlParserDATETIME, MySqlParserYEAR, MySqlParserTEXT, MySqlParserENUM, MySqlParserSERIAL, MySqlParserJSON_VALID, MySqlParserJSON_SCHEMA_VALID, MySqlParserCOUNT, MySqlParserPOSITION, MySqlParserACCOUNT, MySqlParserACTION, MySqlParserAFTER, MySqlParserAGGREGATE, MySqlParserALGORITHM, MySqlParserANY, MySqlParserAT, MySqlParserAUTHORS, MySqlParserAUTOCOMMIT, MySqlParserAUTOEXTEND_SIZE, MySqlParserAUTO_INCREMENT, MySqlParserAVG_ROW_LENGTH, MySqlParserBEGIN, MySqlParserBINLOG, MySqlParserBIT, MySqlParserBLOCK, MySqlParserBOOL, MySqlParserBOOLEAN, MySqlParserBTREE, MySqlParserCACHE, MySqlParserCASCADED, MySqlParserCHAIN, MySqlParserCHANGED, MySqlParserCHANNEL, MySqlParserCHECKSUM, MySqlParserPAGE_CHECKSUM, MySqlParserCIPHER, MySqlParserCLASS_ORIGIN, MySqlParserCLIENT, MySqlParserCLOSE, MySqlParserCOALESCE, MySqlParserCODE, MySqlParserCOLUMNS, MySqlParserCOLUMN_FORMAT, MySqlParserCOLUMN_NAME, MySqlParserCOMMENT, MySqlParserCOMMIT, MySqlParserCOMPACT, MySqlParserCOMPLETION, MySqlParserCOMPRESSED, MySqlParserCOMPRESSION, MySqlParserCONCURRENT, MySqlParserCONNECTION, MySqlParserCONSISTENT, MySqlParserCONSTRAINT_CATALOG, MySqlParserCONSTRAINT_SCHEMA, MySqlParserCONSTRAINT_NAME, MySqlParserCONTAINS, MySqlParserCONTEXT, MySqlParserCONTRIBUTORS, MySqlParserCOPY, MySqlParserCPU, MySqlParserCURSOR_NAME, MySqlParserDATA, MySqlParserDATAFILE, MySqlParserDEALLOCATE, MySqlParserDEFAULT_AUTH, MySqlParserDEFINER, MySqlParserDELAY_KEY_WRITE, MySqlParserDES_KEY_FILE, MySqlParserDIRECTORY, MySqlParserDISABLE, MySqlParserDISCARD, MySqlParserDISK, MySqlParserDO, MySqlParserDUMPFILE, MySqlParserDUPLICATE, MySqlParserDYNAMIC, MySqlParserENABLE, MySqlParserENCRYPTION, MySqlParserEND, MySqlParserENDS, MySqlParserENGINE, MySqlParserENGINES, MySqlParserERROR, MySqlParserERRORS, MySqlParserESCAPE, MySqlParserEVEN, MySqlParserEVENT, MySqlParserEVENTS, MySqlParserEVERY, MySqlParserEXCHANGE, MySqlParserEXCLUSIVE, MySqlParserEXPIRE, MySqlParserEXPORT, MySqlParserEXTENDED, MySqlParserEXTENT_SIZE, MySqlParserFAST, MySqlParserFAULTS, MySqlParserFIELDS, MySqlParserFILE_BLOCK_SIZE, MySqlParserFILTER, MySqlParserFIRST, MySqlParserFIXED, MySqlParserFLUSH, MySqlParserFOLLOWS, MySqlParserFOUND, MySqlParserFULL, MySqlParserFUNCTION, MySqlParserGENERAL, MySqlParserGLOBAL, MySqlParserGRANTS, MySqlParserGROUP_REPLICATION, MySqlParserHANDLER, MySqlParserHASH, MySqlParserHELP, MySqlParserHOST, MySqlParserHOSTS, MySqlParserIDENTIFIED, MySqlParserIGNORE_SERVER_IDS, MySqlParserIMPORT, MySqlParserINDEXES, MySqlParserINITIAL_SIZE, MySqlParserINPLACE, MySqlParserINSERT_METHOD, MySqlParserINSTALL, MySqlParserINSTANCE, MySqlParserINVISIBLE, MySqlParserINVOKER, MySqlParserIO, MySqlParserIO_THREAD, MySqlParserIPC, MySqlParserISOLATION, MySqlParserISSUER, MySqlParserJSON, MySqlParserKEY_BLOCK_SIZE, MySqlParserLANGUAGE, MySqlParserLAST, MySqlParserLEAVES, MySqlParserLESS, MySqlParserLEVEL, MySqlParserLIST, MySqlParserLOCAL, MySqlParserLOGFILE, MySqlParserLOGS, MySqlParserMASTER, MySqlParserMASTER_AUTO_POSITION, MySqlParserMASTER_CONNECT_RETRY, MySqlParserMASTER_DELAY, MySqlParserMASTER_HEARTBEAT_PERIOD, MySqlParserMASTER_HOST, MySqlParserMASTER_LOG_FILE, MySqlParserMASTER_LOG_POS, MySqlParserMASTER_PASSWORD, MySqlParserMASTER_PORT, MySqlParserMASTER_RETRY_COUNT, MySqlParserMASTER_SSL, MySqlParserMASTER_SSL_CA, MySqlParserMASTER_SSL_CAPATH, MySqlParserMASTER_SSL_CERT, MySqlParserMASTER_SSL_CIPHER, MySqlParserMASTER_SSL_CRL, MySqlParserMASTER_SSL_CRLPATH, MySqlParserMASTER_SSL_KEY, MySqlParserMASTER_TLS_VERSION, MySqlParserMASTER_USER, MySqlParserMAX_CONNECTIONS_PER_HOUR, MySqlParserMAX_QUERIES_PER_HOUR, MySqlParserMAX_ROWS, MySqlParserMAX_SIZE, MySqlParserMAX_UPDATES_PER_HOUR, MySqlParserMAX_USER_CONNECTIONS, MySqlParserMEDIUM, MySqlParserMEMBER, MySqlParserMERGE, MySqlParserMESSAGE_TEXT, MySqlParserMID, MySqlParserMIGRATE, MySqlParserMIN_ROWS, MySqlParserMODE, MySqlParserMODIFY, MySqlParserMUTEX, MySqlParserMYSQL, MySqlParserMYSQL_ERRNO, MySqlParserNAME, MySqlParserNAMES, MySqlParserNCHAR, MySqlParserNEVER, MySqlParserNEXT, MySqlParserNO, MySqlParserNODEGROUP, MySqlParserNONE, MySqlParserOFFLINE, MySqlParserOFFSET, MySqlParserOF, MySqlParserOJ, MySqlParserOLD_PASSWORD, MySqlParserONE, MySqlParserONLINE, MySqlParserONLY, MySqlParserOPEN, MySqlParserOPTIMIZER_COSTS, MySqlParserOPTIONS, MySqlParserOWNER, MySqlParserPACK_KEYS, MySqlParserPAGE, MySqlParserPARSER, MySqlParserPARTIAL, MySqlParserPARTITIONING, MySqlParserPARTITIONS, MySqlParserPASSWORD, MySqlParserPHASE, MySqlParserPLUGIN, MySqlParserPLUGIN_DIR, MySqlParserPLUGINS, MySqlParserPORT, MySqlParserPRECEDES, MySqlParserPREPARE, MySqlParserPRESERVE, MySqlParserPREV, MySqlParserPROCESSLIST, MySqlParserPROFILE, MySqlParserPROFILES, MySqlParserPROXY, MySqlParserQUERY, MySqlParserQUICK, MySqlParserREBUILD, MySqlParserRECOVER, MySqlParserREDO_BUFFER_SIZE, MySqlParserREDUNDANT, MySqlParserRELAY, MySqlParserRELAY_LOG_FILE, MySqlParserRELAY_LOG_POS, MySqlParserRELAYLOG, MySqlParserREMOVE, MySqlParserREORGANIZE, MySqlParserREPAIR, MySqlParserREPLICATE_DO_DB, MySqlParserREPLICATE_DO_TABLE, MySqlParserREPLICATE_IGNORE_DB, MySqlParserREPLICATE_IGNORE_TABLE, MySqlParserREPLICATE_REWRITE_DB, MySqlParserREPLICATE_WILD_DO_TABLE, MySqlParserREPLICATE_WILD_IGNORE_TABLE, MySqlParserREPLICATION, MySqlParserRESET, MySqlParserRESUME, MySqlParserRETURNED_SQLSTATE, MySqlParserRETURNS, MySqlParserROLE, MySqlParserROLLBACK, MySqlParserROLLUP, MySqlParserROTATE, MySqlParserROW, MySqlParserROWS, MySqlParserROW_FORMAT, MySqlParserSAVEPOINT, MySqlParserSCHEDULE, MySqlParserSECURITY, MySqlParserSERVER, MySqlParserSESSION, MySqlParserSHARE, MySqlParserSHARED, MySqlParserSIGNED, MySqlParserSIMPLE, MySqlParserSLAVE, MySqlParserSLOW, MySqlParserSNAPSHOT, MySqlParserSOCKET, MySqlParserSOME, MySqlParserSONAME, MySqlParserSOUNDS, MySqlParserSOURCE, MySqlParserSQL_AFTER_GTIDS, MySqlParserSQL_AFTER_MTS_GAPS, MySqlParserSQL_BEFORE_GTIDS, MySqlParserSQL_BUFFER_RESULT, MySqlParserSQL_CACHE, MySqlParserSQL_NO_CACHE, MySqlParserSQL_THREAD, MySqlParserSTART, MySqlParserSTARTS, MySqlParserSTATS_AUTO_RECALC, MySqlParserSTATS_PERSISTENT, MySqlParserSTATS_SAMPLE_PAGES, MySqlParserSTATUS, MySqlParserSTOP, MySqlParserSTORAGE, MySqlParserSTRING, MySqlParserSUBCLASS_ORIGIN, MySqlParserSUBJECT, MySqlParserSUBPARTITION, MySqlParserSUBPARTITIONS, MySqlParserSUSPEND, MySqlParserSWAPS, MySqlParserSWITCHES, MySqlParserTABLE_NAME, MySqlParserTABLESPACE, MySqlParserTEMPORARY, MySqlParserTEMPTABLE, MySqlParserTHAN, MySqlParserTRADITIONAL, MySqlParserTRANSACTION, MySqlParserTRANSACTIONAL, MySqlParserTRIGGERS, MySqlParserTRUNCATE, MySqlParserUNDEFINED, MySqlParserUNDOFILE, MySqlParserUNDO_BUFFER_SIZE, MySqlParserUNINSTALL, MySqlParserUNKNOWN, MySqlParserUNTIL, MySqlParserUPGRADE, MySqlParserUSER, MySqlParserUSE_FRM, MySqlParserUSER_RESOURCES, MySqlParserVALIDATION, MySqlParserVALUE, MySqlParserVARIABLES, MySqlParserVIEW, MySqlParserVISIBLE, MySqlParserWAIT, MySqlParserWARNINGS, MySqlParserWITHOUT, MySqlParserWORK, MySqlParserWRAPPER, MySqlParserX509, MySqlParserXA, MySqlParserXML, MySqlParserINTERNAL, MySqlParserQUARTER, MySqlParserMONTH, MySqlParserDAY, MySqlParserHOUR, MySqlParserMINUTE, MySqlParserWEEK, MySqlParserSECOND, MySqlParserMICROSECOND, MySqlParserTABLES, MySqlParserROUTINE, MySqlParserEXECUTE, MySqlParserFILE, MySqlParserPROCESS, MySqlParserRELOAD, MySqlParserSHUTDOWN, MySqlParserSUPER, MySqlParserPRIVILEGES, MySqlParserAUDIT_ADMIN, MySqlParserBACKUP_ADMIN, MySqlParserBINLOG_ADMIN, MySqlParserBINLOG_ENCRYPTION_ADMIN, MySqlParserCLONE_ADMIN, MySqlParserCONNECTION_ADMIN, MySqlParserENCRYPTION_KEY_ADMIN, MySqlParserFIREWALL_ADMIN, MySqlParserFIREWALL_USER, MySqlParserGROUP_REPLICATION_ADMIN, MySqlParserINNODB_REDO_LOG_ARCHIVE, MySqlParserNDB_STORED_USER, MySqlParserPERSIST_RO_VARIABLES_ADMIN, MySqlParserREPLICATION_APPLIER, MySqlParserREPLICATION_SLAVE_ADMIN, MySqlParserRESOURCE_GROUP_ADMIN, MySqlParserRESOURCE_GROUP_USER, MySqlParserROLE_ADMIN, MySqlParserSESSION_VARIABLES_ADMIN, MySqlParserSET_USER_ID, MySqlParserSHOW_ROUTINE, MySqlParserSYSTEM_VARIABLES_ADMIN, MySqlParserTABLE_ENCRYPTION_ADMIN, MySqlParserVERSION_TOKEN_ADMIN, MySqlParserXA_RECOVER_ADMIN, MySqlParserARMSCII8, MySqlParserASCII, MySqlParserBIG5, MySqlParserCP1250, MySqlParserCP1251, MySqlParserCP1256, MySqlParserCP1257, MySqlParserCP850, MySqlParserCP852, MySqlParserCP866, MySqlParserCP932, MySqlParserDEC8, MySqlParserEUCJPMS, MySqlParserEUCKR, MySqlParserGB2312, MySqlParserGBK, MySqlParserGEOSTD8, MySqlParserGREEK, MySqlParserHEBREW, MySqlParserHP8, MySqlParserKEYBCS2, MySqlParserKOI8R, MySqlParserKOI8U, MySqlParserLATIN1, MySqlParserLATIN2, MySqlParserLATIN5, MySqlParserLATIN7, MySqlParserMACCE, MySqlParserMACROMAN, MySqlParserSJIS, MySqlParserSWE7, MySqlParserTIS620, MySqlParserUCS2, MySqlParserUJIS, MySqlParserUTF16, MySqlParserUTF16LE, MySqlParserUTF32, MySqlParserUTF8, MySqlParserUTF8MB3, MySqlParserUTF8MB4, MySqlParserARCHIVE, MySqlParserBLACKHOLE, MySqlParserCSV, MySqlParserFEDERATED, MySqlParserINNODB, MySqlParserMEMORY, MySqlParserMRG_MYISAM, MySqlParserMYISAM, MySqlParserNDB, MySqlParserNDBCLUSTER, MySqlParserPERFORMANCE_SCHEMA, MySqlParserTOKUDB, MySqlParserREPEATABLE, MySqlParserCOMMITTED, MySqlParserUNCOMMITTED, MySqlParserSERIALIZABLE, MySqlParserGEOMETRYCOLLECTION, MySqlParserLINESTRING, MySqlParserMULTILINESTRING, MySqlParserMULTIPOINT, MySqlParserMULTIPOLYGON, MySqlParserPOINT, MySqlParserPOLYGON, MySqlParserABS, MySqlParserACOS, MySqlParserADDDATE, MySqlParserADDTIME, MySqlParserAES_DECRYPT, MySqlParserAES_ENCRYPT, MySqlParserAREA, MySqlParserASBINARY, MySqlParserASIN, MySqlParserASTEXT, MySqlParserASWKB, MySqlParserASWKT, MySqlParserASYMMETRIC_DECRYPT, MySqlParserASYMMETRIC_DERIVE, MySqlParserASYMMETRIC_ENCRYPT, MySqlParserASYMMETRIC_SIGN, MySqlParserASYMMETRIC_VERIFY, MySqlParserATAN, MySqlParserATAN2, MySqlParserBENCHMARK, MySqlParserBIN, MySqlParserBIT_COUNT, MySqlParserBIT_LENGTH, MySqlParserBUFFER, MySqlParserCATALOG_NAME, MySqlParserCEIL, MySqlParserCEILING, MySqlParserCENTROID, MySqlParserCHARACTER_LENGTH, MySqlParserCHARSET, MySqlParserCHAR_LENGTH, MySqlParserCOERCIBILITY, MySqlParserCOLLATION, MySqlParserCOMPRESS, MySqlParserCONCAT, MySqlParserCONCAT_WS, MySqlParserCONNECTION_ID, MySqlParserCONV, MySqlParserCONVERT_TZ, MySqlParserCOS, MySqlParserCOT, MySqlParserCRC32, MySqlParserCREATE_ASYMMETRIC_PRIV_KEY, MySqlParserCREATE_ASYMMETRIC_PUB_KEY, MySqlParserCREATE_DH_PARAMETERS, MySqlParserCREATE_DIGEST, MySqlParserCROSSES, MySqlParserDATEDIFF, MySqlParserDATE_FORMAT, MySqlParserDAYNAME, MySqlParserDAYOFMONTH, MySqlParserDAYOFWEEK, MySqlParserDAYOFYEAR, MySqlParserDECODE, MySqlParserDEGREES, MySqlParserDES_DECRYPT, MySqlParserDES_ENCRYPT, MySqlParserDIMENSION, MySqlParserDISJOINT, MySqlParserELT, MySqlParserENCODE, MySqlParserENCRYPT, MySqlParserENDPOINT, MySqlParserENVELOPE, MySqlParserEQUALS, MySqlParserEXP, MySqlParserEXPORT_SET, MySqlParserEXTERIORRING, MySqlParserEXTRACTVALUE, MySqlParserFIELD, MySqlParserFIND_IN_SET, MySqlParserFLOOR, MySqlParserFORMAT, MySqlParserFOUND_ROWS, MySqlParserFROM_BASE64, MySqlParserFROM_DAYS, MySqlParserFROM_UNIXTIME, MySqlParserGEOMCOLLFROMTEXT, MySqlParserGEOMCOLLFROMWKB, MySqlParserGEOMETRYCOLLECTIONFROMTEXT, MySqlParserGEOMETRYCOLLECTIONFROMWKB, MySqlParserGEOMETRYFROMTEXT, MySqlParserGEOMETRYFROMWKB, MySqlParserGEOMETRYN, MySqlParserGEOMETRYTYPE, MySqlParserGEOMFROMTEXT, MySqlParserGEOMFROMWKB, MySqlParserGET_FORMAT, MySqlParserGET_LOCK, MySqlParserGLENGTH, MySqlParserGREATEST, MySqlParserGTID_SUBSET, MySqlParserGTID_SUBTRACT, MySqlParserHEX, MySqlParserIFNULL, MySqlParserINET6_ATON, MySqlParserINET6_NTOA, MySqlParserINET_ATON, MySqlParserINET_NTOA, MySqlParserINSTR, MySqlParserINTERIORRINGN, MySqlParserINTERSECTS, MySqlParserISCLOSED, MySqlParserISEMPTY, MySqlParserISNULL, MySqlParserISSIMPLE, MySqlParserIS_FREE_LOCK, MySqlParserIS_IPV4, MySqlParserIS_IPV4_COMPAT, MySqlParserIS_IPV4_MAPPED, MySqlParserIS_IPV6, MySqlParserIS_USED_LOCK, MySqlParserLAST_INSERT_ID, MySqlParserLCASE, MySqlParserLEAST, MySqlParserLENGTH, MySqlParserLINEFROMTEXT, MySqlParserLINEFROMWKB, MySqlParserLINESTRINGFROMTEXT, MySqlParserLINESTRINGFROMWKB, MySqlParserLN, MySqlParserLOAD_FILE, MySqlParserLOCATE, MySqlParserLOG, MySqlParserLOG10, MySqlParserLOG2, MySqlParserLOWER, MySqlParserLPAD, MySqlParserLTRIM, MySqlParserMAKEDATE, MySqlParserMAKETIME, MySqlParserMAKE_SET, MySqlParserMASTER_POS_WAIT, MySqlParserMBRCONTAINS, MySqlParserMBRDISJOINT, MySqlParserMBREQUAL, MySqlParserMBRINTERSECTS, MySqlParserMBROVERLAPS, MySqlParserMBRTOUCHES, MySqlParserMBRWITHIN, MySqlParserMD5, MySqlParserMLINEFROMTEXT, MySqlParserMLINEFROMWKB, MySqlParserMONTHNAME, MySqlParserMPOINTFROMTEXT, MySqlParserMPOINTFROMWKB, MySqlParserMPOLYFROMTEXT, MySqlParserMPOLYFROMWKB, MySqlParserMULTILINESTRINGFROMTEXT, MySqlParserMULTILINESTRINGFROMWKB, MySqlParserMULTIPOINTFROMTEXT, MySqlParserMULTIPOINTFROMWKB, MySqlParserMULTIPOLYGONFROMTEXT, MySqlParserMULTIPOLYGONFROMWKB, MySqlParserNAME_CONST, MySqlParserNULLIF, MySqlParserNUMGEOMETRIES, MySqlParserNUMINTERIORRINGS, MySqlParserNUMPOINTS, MySqlParserOCT, MySqlParserOCTET_LENGTH, MySqlParserORD, MySqlParserOVERLAPS, MySqlParserPERIOD_ADD, MySqlParserPERIOD_DIFF, MySqlParserPI, MySqlParserPOINTFROMTEXT, MySqlParserPOINTFROMWKB, MySqlParserPOINTN, MySqlParserPOLYFROMTEXT, MySqlParserPOLYFROMWKB, MySqlParserPOLYGONFROMTEXT, MySqlParserPOLYGONFROMWKB, MySqlParserPOW, MySqlParserPOWER, MySqlParserQUOTE, MySqlParserRADIANS, MySqlParserRAND, MySqlParserRANDOM_BYTES, MySqlParserRELEASE_LOCK, MySqlParserREVERSE, MySqlParserROUND, MySqlParserROW_COUNT, MySqlParserRPAD, MySqlParserRTRIM, MySqlParserSEC_TO_TIME, MySqlParserSESSION_USER, MySqlParserSHA, MySqlParserSHA1, MySqlParserSHA2, MySqlParserSCHEMA_NAME, MySqlParserSIGN, MySqlParserSIN, MySqlParserSLEEP, MySqlParserSOUNDEX, MySqlParserSQL_THREAD_WAIT_AFTER_GTIDS, MySqlParserSQRT, MySqlParserSRID, MySqlParserSTARTPOINT, MySqlParserSTRCMP, MySqlParserSTR_TO_DATE, MySqlParserST_AREA, MySqlParserST_ASBINARY, MySqlParserST_ASTEXT, MySqlParserST_ASWKB, MySqlParserST_ASWKT, MySqlParserST_BUFFER, MySqlParserST_CENTROID, MySqlParserST_CONTAINS, MySqlParserST_CROSSES, MySqlParserST_DIFFERENCE, MySqlParserST_DIMENSION, MySqlParserST_DISJOINT, MySqlParserST_DISTANCE, MySqlParserST_ENDPOINT, MySqlParserST_ENVELOPE, MySqlParserST_EQUALS, MySqlParserST_EXTERIORRING, MySqlParserST_GEOMCOLLFROMTEXT, MySqlParserST_GEOMCOLLFROMTXT, MySqlParserST_GEOMCOLLFROMWKB, MySqlParserST_GEOMETRYCOLLECTIONFROMTEXT, MySqlParserST_GEOMETRYCOLLECTIONFROMWKB, MySqlParserST_GEOMETRYFROMTEXT, MySqlParserST_GEOMETRYFROMWKB, MySqlParserST_GEOMETRYN, MySqlParserST_GEOMETRYTYPE, MySqlParserST_GEOMFROMTEXT, MySqlParserST_GEOMFROMWKB, MySqlParserST_INTERIORRINGN, MySqlParserST_INTERSECTION, MySqlParserST_INTERSECTS, MySqlParserST_ISCLOSED, MySqlParserST_ISEMPTY, MySqlParserST_ISSIMPLE, MySqlParserST_LINEFROMTEXT, MySqlParserST_LINEFROMWKB, MySqlParserST_LINESTRINGFROMTEXT, MySqlParserST_LINESTRINGFROMWKB, MySqlParserST_NUMGEOMETRIES, MySqlParserST_NUMINTERIORRING, MySqlParserST_NUMINTERIORRINGS, MySqlParserST_NUMPOINTS, MySqlParserST_OVERLAPS, MySqlParserST_POINTFROMTEXT, MySqlParserST_POINTFROMWKB, MySqlParserST_POINTN, MySqlParserST_POLYFROMTEXT, MySqlParserST_POLYFROMWKB, MySqlParserST_POLYGONFROMTEXT, MySqlParserST_POLYGONFROMWKB, MySqlParserST_SRID, MySqlParserST_STARTPOINT, MySqlParserST_SYMDIFFERENCE, MySqlParserST_TOUCHES, MySqlParserST_UNION, MySqlParserST_WITHIN, MySqlParserST_X, MySqlParserST_Y, MySqlParserSUBDATE, MySqlParserSUBSTRING_INDEX, MySqlParserSUBTIME, MySqlParserSYSTEM_USER, MySqlParserTAN, MySqlParserTIMEDIFF, MySqlParserTIMESTAMPADD, MySqlParserTIMESTAMPDIFF, MySqlParserTIME_FORMAT, MySqlParserTIME_TO_SEC, MySqlParserTOUCHES, MySqlParserTO_BASE64, MySqlParserTO_DAYS, MySqlParserTO_SECONDS, MySqlParserUCASE, MySqlParserUNCOMPRESS, MySqlParserUNCOMPRESSED_LENGTH, MySqlParserUNHEX, MySqlParserUNIX_TIMESTAMP, MySqlParserUPDATEXML, MySqlParserUPPER, MySqlParserUUID, MySqlParserUUID_SHORT, MySqlParserVALIDATE_PASSWORD_STRENGTH, MySqlParserVERSION, MySqlParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS, MySqlParserWEEKDAY, MySqlParserWEEKOFYEAR, MySqlParserWEIGHT_STRING, MySqlParserWITHIN, MySqlParserYEARWEEK, MySqlParserY_FUNCTION, MySqlParserX_FUNCTION, MySqlParserCHARSET_REVERSE_QOUTE_STRING, MySqlParserSTRING_LITERAL, MySqlParserID, MySqlParserREVERSE_QUOTE_ID:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(210)
			p.Uid()
		}

	case MySqlParserLOCAL_ID:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(211)
			p.Match(MySqlParserLOCAL_ID)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ILockClauseContext is an interface to support dynamic dispatch.
type ILockClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLockClauseContext differentiates from other interfaces.
	IsLockClauseContext()
}

type LockClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLockClauseContext() *LockClauseContext {
	var p = new(LockClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_lockClause
	return p
}

func (*LockClauseContext) IsLockClauseContext() {}

func NewLockClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LockClauseContext {
	var p = new(LockClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_lockClause

	return p
}

func (s *LockClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *LockClauseContext) FOR() antlr.TerminalNode {
	return s.GetToken(MySqlParserFOR, 0)
}

func (s *LockClauseContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserUPDATE, 0)
}

func (s *LockClauseContext) LOCK() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCK, 0)
}

func (s *LockClauseContext) IN() antlr.TerminalNode {
	return s.GetToken(MySqlParserIN, 0)
}

func (s *LockClauseContext) SHARE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSHARE, 0)
}

func (s *LockClauseContext) MODE() antlr.TerminalNode {
	return s.GetToken(MySqlParserMODE, 0)
}

func (s *LockClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LockClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LockClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterLockClause(s)
	}
}

func (s *LockClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitLockClause(s)
	}
}

func (s *LockClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitLockClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) LockClause() (localctx ILockClauseContext) {
	localctx = NewLockClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, MySqlParserRULE_lockClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(220)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case MySqlParserFOR:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(214)
			p.Match(MySqlParserFOR)
		}
		{
			p.SetState(215)
			p.Match(MySqlParserUPDATE)
		}

	case MySqlParserLOCK:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(216)
			p.Match(MySqlParserLOCK)
		}
		{
			p.SetState(217)
			p.Match(MySqlParserIN)
		}
		{
			p.SetState(218)
			p.Match(MySqlParserSHARE)
		}
		{
			p.SetState(219)
			p.Match(MySqlParserMODE)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IOrderByClauseContext is an interface to support dynamic dispatch.
type IOrderByClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOrderByClauseContext differentiates from other interfaces.
	IsOrderByClauseContext()
}

type OrderByClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrderByClauseContext() *OrderByClauseContext {
	var p = new(OrderByClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_orderByClause
	return p
}

func (*OrderByClauseContext) IsOrderByClauseContext() {}

func NewOrderByClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OrderByClauseContext {
	var p = new(OrderByClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_orderByClause

	return p
}

func (s *OrderByClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *OrderByClauseContext) ORDER() antlr.TerminalNode {
	return s.GetToken(MySqlParserORDER, 0)
}

func (s *OrderByClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(MySqlParserBY, 0)
}

func (s *OrderByClauseContext) AllOrderByExpression() []IOrderByExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOrderByExpressionContext)(nil)).Elem())
	var tst = make([]IOrderByExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOrderByExpressionContext)
		}
	}

	return tst
}

func (s *OrderByClauseContext) OrderByExpression(i int) IOrderByExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOrderByExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOrderByExpressionContext)
}

func (s *OrderByClauseContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *OrderByClauseContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *OrderByClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OrderByClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OrderByClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterOrderByClause(s)
	}
}

func (s *OrderByClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitOrderByClause(s)
	}
}

func (s *OrderByClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitOrderByClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) OrderByClause() (localctx IOrderByClauseContext) {
	localctx = NewOrderByClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, MySqlParserRULE_orderByClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(222)
		p.Match(MySqlParserORDER)
	}
	{
		p.SetState(223)
		p.Match(MySqlParserBY)
	}
	{
		p.SetState(224)
		p.OrderByExpression()
	}
	p.SetState(229)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == MySqlParserCOMMA {
		{
			p.SetState(225)
			p.Match(MySqlParserCOMMA)
		}
		{
			p.SetState(226)
			p.OrderByExpression()
		}

		p.SetState(231)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IOrderByExpressionContext is an interface to support dynamic dispatch.
type IOrderByExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOrder returns the order token.
	GetOrder() antlr.Token

	// SetOrder sets the order token.
	SetOrder(antlr.Token)

	// IsOrderByExpressionContext differentiates from other interfaces.
	IsOrderByExpressionContext()
}

type OrderByExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	order  antlr.Token
}

func NewEmptyOrderByExpressionContext() *OrderByExpressionContext {
	var p = new(OrderByExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_orderByExpression
	return p
}

func (*OrderByExpressionContext) IsOrderByExpressionContext() {}

func NewOrderByExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OrderByExpressionContext {
	var p = new(OrderByExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_orderByExpression

	return p
}

func (s *OrderByExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *OrderByExpressionContext) GetOrder() antlr.Token { return s.order }

func (s *OrderByExpressionContext) SetOrder(v antlr.Token) { s.order = v }

func (s *OrderByExpressionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *OrderByExpressionContext) ASC() antlr.TerminalNode {
	return s.GetToken(MySqlParserASC, 0)
}

func (s *OrderByExpressionContext) DESC() antlr.TerminalNode {
	return s.GetToken(MySqlParserDESC, 0)
}

func (s *OrderByExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OrderByExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OrderByExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterOrderByExpression(s)
	}
}

func (s *OrderByExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitOrderByExpression(s)
	}
}

func (s *OrderByExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitOrderByExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) OrderByExpression() (localctx IOrderByExpressionContext) {
	localctx = NewOrderByExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, MySqlParserRULE_orderByExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(232)
		p.expression(0)
	}
	p.SetState(234)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserASC || _la == MySqlParserDESC {
		{
			p.SetState(233)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*OrderByExpressionContext).order = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserASC || _la == MySqlParserDESC) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*OrderByExpressionContext).order = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

	return localctx
}

// ITableSourcesContext is an interface to support dynamic dispatch.
type ITableSourcesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTableSourcesContext differentiates from other interfaces.
	IsTableSourcesContext()
}

type TableSourcesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableSourcesContext() *TableSourcesContext {
	var p = new(TableSourcesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_tableSources
	return p
}

func (*TableSourcesContext) IsTableSourcesContext() {}

func NewTableSourcesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableSourcesContext {
	var p = new(TableSourcesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_tableSources

	return p
}

func (s *TableSourcesContext) GetParser() antlr.Parser { return s.parser }

func (s *TableSourcesContext) AllTableSource() []ITableSourceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITableSourceContext)(nil)).Elem())
	var tst = make([]ITableSourceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITableSourceContext)
		}
	}

	return tst
}

func (s *TableSourcesContext) TableSource(i int) ITableSourceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableSourceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITableSourceContext)
}

func (s *TableSourcesContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *TableSourcesContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *TableSourcesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableSourcesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableSourcesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableSources(s)
	}
}

func (s *TableSourcesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableSources(s)
	}
}

func (s *TableSourcesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTableSources(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) TableSources() (localctx ITableSourcesContext) {
	localctx = NewTableSourcesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, MySqlParserRULE_tableSources)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(236)
		p.TableSource()
	}
	p.SetState(241)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == MySqlParserCOMMA {
		{
			p.SetState(237)
			p.Match(MySqlParserCOMMA)
		}
		{
			p.SetState(238)
			p.TableSource()
		}

		p.SetState(243)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ITableSourceContext is an interface to support dynamic dispatch.
type ITableSourceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTableSourceContext differentiates from other interfaces.
	IsTableSourceContext()
}

type TableSourceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableSourceContext() *TableSourceContext {
	var p = new(TableSourceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_tableSource
	return p
}

func (*TableSourceContext) IsTableSourceContext() {}

func NewTableSourceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableSourceContext {
	var p = new(TableSourceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_tableSource

	return p
}

func (s *TableSourceContext) GetParser() antlr.Parser { return s.parser }

func (s *TableSourceContext) CopyFrom(ctx *TableSourceContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *TableSourceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableSourceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type TableSourceNestedContext struct {
	*TableSourceContext
}

func NewTableSourceNestedContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableSourceNestedContext {
	var p = new(TableSourceNestedContext)

	p.TableSourceContext = NewEmptyTableSourceContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TableSourceContext))

	return p
}

func (s *TableSourceNestedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableSourceNestedContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *TableSourceNestedContext) TableSourceItem() ITableSourceItemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableSourceItemContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableSourceItemContext)
}

func (s *TableSourceNestedContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *TableSourceNestedContext) AllJoinPart() []IJoinPartContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IJoinPartContext)(nil)).Elem())
	var tst = make([]IJoinPartContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IJoinPartContext)
		}
	}

	return tst
}

func (s *TableSourceNestedContext) JoinPart(i int) IJoinPartContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IJoinPartContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IJoinPartContext)
}

func (s *TableSourceNestedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableSourceNested(s)
	}
}

func (s *TableSourceNestedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableSourceNested(s)
	}
}

func (s *TableSourceNestedContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTableSourceNested(s)

	default:
		return t.VisitChildren(s)
	}
}

type TableSourceBaseContext struct {
	*TableSourceContext
}

func NewTableSourceBaseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableSourceBaseContext {
	var p = new(TableSourceBaseContext)

	p.TableSourceContext = NewEmptyTableSourceContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TableSourceContext))

	return p
}

func (s *TableSourceBaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableSourceBaseContext) TableSourceItem() ITableSourceItemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableSourceItemContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableSourceItemContext)
}

func (s *TableSourceBaseContext) AllJoinPart() []IJoinPartContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IJoinPartContext)(nil)).Elem())
	var tst = make([]IJoinPartContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IJoinPartContext)
		}
	}

	return tst
}

func (s *TableSourceBaseContext) JoinPart(i int) IJoinPartContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IJoinPartContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IJoinPartContext)
}

func (s *TableSourceBaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableSourceBase(s)
	}
}

func (s *TableSourceBaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableSourceBase(s)
	}
}

func (s *TableSourceBaseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTableSourceBase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) TableSource() (localctx ITableSourceContext) {
	localctx = NewTableSourceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, MySqlParserRULE_tableSource)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(261)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 20, p.GetParserRuleContext()) {
	case 1:
		localctx = NewTableSourceBaseContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(244)
			p.TableSourceItem()
		}
		p.SetState(248)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 18, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(245)
					p.JoinPart()
				}

			}
			p.SetState(250)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 18, p.GetParserRuleContext())
		}

	case 2:
		localctx = NewTableSourceNestedContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(251)
			p.Match(MySqlParserLR_BRACKET)
		}
		{
			p.SetState(252)
			p.TableSourceItem()
		}
		p.SetState(256)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCROSS || (((_la-74)&-(0x1f+1)) == 0 && ((1<<uint((_la-74)))&((1<<(MySqlParserINNER-74))|(1<<(MySqlParserJOIN-74))|(1<<(MySqlParserLEFT-74))|(1<<(MySqlParserNATURAL-74)))) != 0) || _la == MySqlParserRIGHT || _la == MySqlParserSTRAIGHT_JOIN {
			{
				p.SetState(253)
				p.JoinPart()
			}

			p.SetState(258)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(259)
			p.Match(MySqlParserRR_BRACKET)
		}

	}

	return localctx
}

// ITableSourceItemContext is an interface to support dynamic dispatch.
type ITableSourceItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTableSourceItemContext differentiates from other interfaces.
	IsTableSourceItemContext()
}

type TableSourceItemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableSourceItemContext() *TableSourceItemContext {
	var p = new(TableSourceItemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_tableSourceItem
	return p
}

func (*TableSourceItemContext) IsTableSourceItemContext() {}

func NewTableSourceItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableSourceItemContext {
	var p = new(TableSourceItemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_tableSourceItem

	return p
}

func (s *TableSourceItemContext) GetParser() antlr.Parser { return s.parser }

func (s *TableSourceItemContext) CopyFrom(ctx *TableSourceItemContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *TableSourceItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableSourceItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SubqueryTableItemContext struct {
	*TableSourceItemContext
	parenthesisSubquery ISelectStatementContext
	alias               IUidContext
}

func NewSubqueryTableItemContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SubqueryTableItemContext {
	var p = new(SubqueryTableItemContext)

	p.TableSourceItemContext = NewEmptyTableSourceItemContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TableSourceItemContext))

	return p
}

func (s *SubqueryTableItemContext) GetParenthesisSubquery() ISelectStatementContext {
	return s.parenthesisSubquery
}

func (s *SubqueryTableItemContext) GetAlias() IUidContext { return s.alias }

func (s *SubqueryTableItemContext) SetParenthesisSubquery(v ISelectStatementContext) {
	s.parenthesisSubquery = v
}

func (s *SubqueryTableItemContext) SetAlias(v IUidContext) { s.alias = v }

func (s *SubqueryTableItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubqueryTableItemContext) Uid() IUidContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUidContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *SubqueryTableItemContext) SelectStatement() ISelectStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelectStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelectStatementContext)
}

func (s *SubqueryTableItemContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *SubqueryTableItemContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *SubqueryTableItemContext) AS() antlr.TerminalNode {
	return s.GetToken(MySqlParserAS, 0)
}

func (s *SubqueryTableItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSubqueryTableItem(s)
	}
}

func (s *SubqueryTableItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSubqueryTableItem(s)
	}
}

func (s *SubqueryTableItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSubqueryTableItem(s)

	default:
		return t.VisitChildren(s)
	}
}

type AtomTableItemContext struct {
	*TableSourceItemContext
	alias IUidContext
}

func NewAtomTableItemContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AtomTableItemContext {
	var p = new(AtomTableItemContext)

	p.TableSourceItemContext = NewEmptyTableSourceItemContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TableSourceItemContext))

	return p
}

func (s *AtomTableItemContext) GetAlias() IUidContext { return s.alias }

func (s *AtomTableItemContext) SetAlias(v IUidContext) { s.alias = v }

func (s *AtomTableItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AtomTableItemContext) TableName() ITableNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *AtomTableItemContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARTITION, 0)
}

func (s *AtomTableItemContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *AtomTableItemContext) UidList() IUidListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUidListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *AtomTableItemContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *AtomTableItemContext) AllIndexHint() []IIndexHintContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIndexHintContext)(nil)).Elem())
	var tst = make([]IIndexHintContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIndexHintContext)
		}
	}

	return tst
}

func (s *AtomTableItemContext) IndexHint(i int) IIndexHintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIndexHintContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIndexHintContext)
}

func (s *AtomTableItemContext) Uid() IUidContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUidContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *AtomTableItemContext) AS() antlr.TerminalNode {
	return s.GetToken(MySqlParserAS, 0)
}

func (s *AtomTableItemContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *AtomTableItemContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *AtomTableItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAtomTableItem(s)
	}
}

func (s *AtomTableItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAtomTableItem(s)
	}
}

func (s *AtomTableItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAtomTableItem(s)

	default:
		return t.VisitChildren(s)
	}
}

type TableSourcesItemContext struct {
	*TableSourceItemContext
}

func NewTableSourcesItemContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableSourcesItemContext {
	var p = new(TableSourcesItemContext)

	p.TableSourceItemContext = NewEmptyTableSourceItemContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TableSourceItemContext))

	return p
}

func (s *TableSourcesItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableSourcesItemContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *TableSourcesItemContext) TableSources() ITableSourcesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableSourcesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableSourcesContext)
}

func (s *TableSourcesItemContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *TableSourcesItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableSourcesItem(s)
	}
}

func (s *TableSourcesItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableSourcesItem(s)
	}
}

func (s *TableSourcesItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTableSourcesItem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) TableSourceItem() (localctx ITableSourceItemContext) {
	localctx = NewTableSourceItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, MySqlParserRULE_tableSourceItem)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(303)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 28, p.GetParserRuleContext()) {
	case 1:
		localctx = NewAtomTableItemContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(263)
			p.TableName()
		}
		p.SetState(269)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserPARTITION {
			{
				p.SetState(264)
				p.Match(MySqlParserPARTITION)
			}
			{
				p.SetState(265)
				p.Match(MySqlParserLR_BRACKET)
			}
			{
				p.SetState(266)
				p.UidList()
			}
			{
				p.SetState(267)
				p.Match(MySqlParserRR_BRACKET)
			}

		}
		p.SetState(275)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 23, p.GetParserRuleContext()) == 1 {
			p.SetState(272)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == MySqlParserAS {
				{
					p.SetState(271)
					p.Match(MySqlParserAS)
				}

			}
			{
				p.SetState(274)

				var _x = p.Uid()

				localctx.(*AtomTableItemContext).alias = _x
			}

		}
		p.SetState(285)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserFORCE || _la == MySqlParserIGNORE || _la == MySqlParserUSE {
			{
				p.SetState(277)
				p.IndexHint()
			}
			p.SetState(282)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 24, p.GetParserRuleContext())

			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(278)
						p.Match(MySqlParserCOMMA)
					}
					{
						p.SetState(279)
						p.IndexHint()
					}

				}
				p.SetState(284)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 24, p.GetParserRuleContext())
			}

		}

	case 2:
		localctx = NewSubqueryTableItemContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		p.SetState(292)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 26, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(287)
				p.SelectStatement()
			}

		case 2:
			{
				p.SetState(288)
				p.Match(MySqlParserLR_BRACKET)
			}
			{
				p.SetState(289)

				var _x = p.SelectStatement()

				localctx.(*SubqueryTableItemContext).parenthesisSubquery = _x
			}
			{
				p.SetState(290)
				p.Match(MySqlParserRR_BRACKET)
			}

		}
		p.SetState(295)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserAS {
			{
				p.SetState(294)
				p.Match(MySqlParserAS)
			}

		}
		{
			p.SetState(297)

			var _x = p.Uid()

			localctx.(*SubqueryTableItemContext).alias = _x
		}

	case 3:
		localctx = NewTableSourcesItemContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(299)
			p.Match(MySqlParserLR_BRACKET)
		}
		{
			p.SetState(300)
			p.TableSources()
		}
		{
			p.SetState(301)
			p.Match(MySqlParserRR_BRACKET)
		}

	}

	return localctx
}

// IIndexHintContext is an interface to support dynamic dispatch.
type IIndexHintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetIndexHintAction returns the indexHintAction token.
	GetIndexHintAction() antlr.Token

	// GetKeyFormat returns the keyFormat token.
	GetKeyFormat() antlr.Token

	// SetIndexHintAction sets the indexHintAction token.
	SetIndexHintAction(antlr.Token)

	// SetKeyFormat sets the keyFormat token.
	SetKeyFormat(antlr.Token)

	// IsIndexHintContext differentiates from other interfaces.
	IsIndexHintContext()
}

type IndexHintContext struct {
	*antlr.BaseParserRuleContext
	parser          antlr.Parser
	indexHintAction antlr.Token
	keyFormat       antlr.Token
}

func NewEmptyIndexHintContext() *IndexHintContext {
	var p = new(IndexHintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_indexHint
	return p
}

func (*IndexHintContext) IsIndexHintContext() {}

func NewIndexHintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexHintContext {
	var p = new(IndexHintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_indexHint

	return p
}

func (s *IndexHintContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexHintContext) GetIndexHintAction() antlr.Token { return s.indexHintAction }

func (s *IndexHintContext) GetKeyFormat() antlr.Token { return s.keyFormat }

func (s *IndexHintContext) SetIndexHintAction(v antlr.Token) { s.indexHintAction = v }

func (s *IndexHintContext) SetKeyFormat(v antlr.Token) { s.keyFormat = v }

func (s *IndexHintContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *IndexHintContext) UidList() IUidListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUidListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *IndexHintContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *IndexHintContext) USE() antlr.TerminalNode {
	return s.GetToken(MySqlParserUSE, 0)
}

func (s *IndexHintContext) IGNORE() antlr.TerminalNode {
	return s.GetToken(MySqlParserIGNORE, 0)
}

func (s *IndexHintContext) FORCE() antlr.TerminalNode {
	return s.GetToken(MySqlParserFORCE, 0)
}

func (s *IndexHintContext) INDEX() antlr.TerminalNode {
	return s.GetToken(MySqlParserINDEX, 0)
}

func (s *IndexHintContext) KEY() antlr.TerminalNode {
	return s.GetToken(MySqlParserKEY, 0)
}

func (s *IndexHintContext) FOR() antlr.TerminalNode {
	return s.GetToken(MySqlParserFOR, 0)
}

func (s *IndexHintContext) IndexHintType() IIndexHintTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIndexHintTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIndexHintTypeContext)
}

func (s *IndexHintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexHintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexHintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterIndexHint(s)
	}
}

func (s *IndexHintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitIndexHint(s)
	}
}

func (s *IndexHintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitIndexHint(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) IndexHint() (localctx IIndexHintContext) {
	localctx = NewIndexHintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, MySqlParserRULE_indexHint)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(305)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*IndexHintContext).indexHintAction = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserFORCE || _la == MySqlParserIGNORE || _la == MySqlParserUSE) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*IndexHintContext).indexHintAction = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(306)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*IndexHintContext).keyFormat = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserINDEX || _la == MySqlParserKEY) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*IndexHintContext).keyFormat = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(309)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserFOR {
		{
			p.SetState(307)
			p.Match(MySqlParserFOR)
		}
		{
			p.SetState(308)
			p.IndexHintType()
		}

	}
	{
		p.SetState(311)
		p.Match(MySqlParserLR_BRACKET)
	}
	{
		p.SetState(312)
		p.UidList()
	}
	{
		p.SetState(313)
		p.Match(MySqlParserRR_BRACKET)
	}

	return localctx
}

// IIndexHintTypeContext is an interface to support dynamic dispatch.
type IIndexHintTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIndexHintTypeContext differentiates from other interfaces.
	IsIndexHintTypeContext()
}

type IndexHintTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexHintTypeContext() *IndexHintTypeContext {
	var p = new(IndexHintTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_indexHintType
	return p
}

func (*IndexHintTypeContext) IsIndexHintTypeContext() {}

func NewIndexHintTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexHintTypeContext {
	var p = new(IndexHintTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_indexHintType

	return p
}

func (s *IndexHintTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexHintTypeContext) JOIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserJOIN, 0)
}

func (s *IndexHintTypeContext) ORDER() antlr.TerminalNode {
	return s.GetToken(MySqlParserORDER, 0)
}

func (s *IndexHintTypeContext) BY() antlr.TerminalNode {
	return s.GetToken(MySqlParserBY, 0)
}

func (s *IndexHintTypeContext) GROUP() antlr.TerminalNode {
	return s.GetToken(MySqlParserGROUP, 0)
}

func (s *IndexHintTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexHintTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexHintTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterIndexHintType(s)
	}
}

func (s *IndexHintTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitIndexHintType(s)
	}
}

func (s *IndexHintTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitIndexHintType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) IndexHintType() (localctx IIndexHintTypeContext) {
	localctx = NewIndexHintTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, MySqlParserRULE_indexHintType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(320)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case MySqlParserJOIN:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(315)
			p.Match(MySqlParserJOIN)
		}

	case MySqlParserORDER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(316)
			p.Match(MySqlParserORDER)
		}
		{
			p.SetState(317)
			p.Match(MySqlParserBY)
		}

	case MySqlParserGROUP:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(318)
			p.Match(MySqlParserGROUP)
		}
		{
			p.SetState(319)
			p.Match(MySqlParserBY)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IJoinPartContext is an interface to support dynamic dispatch.
type IJoinPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsJoinPartContext differentiates from other interfaces.
	IsJoinPartContext()
}

type JoinPartContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoinPartContext() *JoinPartContext {
	var p = new(JoinPartContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_joinPart
	return p
}

func (*JoinPartContext) IsJoinPartContext() {}

func NewJoinPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinPartContext {
	var p = new(JoinPartContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_joinPart

	return p
}

func (s *JoinPartContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinPartContext) CopyFrom(ctx *JoinPartContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *JoinPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type InnerJoinContext struct {
	*JoinPartContext
}

func NewInnerJoinContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InnerJoinContext {
	var p = new(InnerJoinContext)

	p.JoinPartContext = NewEmptyJoinPartContext()
	p.parser = parser
	p.CopyFrom(ctx.(*JoinPartContext))

	return p
}

func (s *InnerJoinContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InnerJoinContext) JOIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserJOIN, 0)
}

func (s *InnerJoinContext) TableSourceItem() ITableSourceItemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableSourceItemContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableSourceItemContext)
}

func (s *InnerJoinContext) ON() antlr.TerminalNode {
	return s.GetToken(MySqlParserON, 0)
}

func (s *InnerJoinContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *InnerJoinContext) USING() antlr.TerminalNode {
	return s.GetToken(MySqlParserUSING, 0)
}

func (s *InnerJoinContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *InnerJoinContext) UidList() IUidListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUidListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *InnerJoinContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *InnerJoinContext) INNER() antlr.TerminalNode {
	return s.GetToken(MySqlParserINNER, 0)
}

func (s *InnerJoinContext) CROSS() antlr.TerminalNode {
	return s.GetToken(MySqlParserCROSS, 0)
}

func (s *InnerJoinContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterInnerJoin(s)
	}
}

func (s *InnerJoinContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitInnerJoin(s)
	}
}

func (s *InnerJoinContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitInnerJoin(s)

	default:
		return t.VisitChildren(s)
	}
}

type NaturalJoinContext struct {
	*JoinPartContext
}

func NewNaturalJoinContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NaturalJoinContext {
	var p = new(NaturalJoinContext)

	p.JoinPartContext = NewEmptyJoinPartContext()
	p.parser = parser
	p.CopyFrom(ctx.(*JoinPartContext))

	return p
}

func (s *NaturalJoinContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NaturalJoinContext) NATURAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserNATURAL, 0)
}

func (s *NaturalJoinContext) JOIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserJOIN, 0)
}

func (s *NaturalJoinContext) TableSourceItem() ITableSourceItemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableSourceItemContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableSourceItemContext)
}

func (s *NaturalJoinContext) LEFT() antlr.TerminalNode {
	return s.GetToken(MySqlParserLEFT, 0)
}

func (s *NaturalJoinContext) RIGHT() antlr.TerminalNode {
	return s.GetToken(MySqlParserRIGHT, 0)
}

func (s *NaturalJoinContext) OUTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserOUTER, 0)
}

func (s *NaturalJoinContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterNaturalJoin(s)
	}
}

func (s *NaturalJoinContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitNaturalJoin(s)
	}
}

func (s *NaturalJoinContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitNaturalJoin(s)

	default:
		return t.VisitChildren(s)
	}
}

type OuterJoinContext struct {
	*JoinPartContext
}

func NewOuterJoinContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *OuterJoinContext {
	var p = new(OuterJoinContext)

	p.JoinPartContext = NewEmptyJoinPartContext()
	p.parser = parser
	p.CopyFrom(ctx.(*JoinPartContext))

	return p
}

func (s *OuterJoinContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OuterJoinContext) JOIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserJOIN, 0)
}

func (s *OuterJoinContext) TableSourceItem() ITableSourceItemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableSourceItemContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableSourceItemContext)
}

func (s *OuterJoinContext) LEFT() antlr.TerminalNode {
	return s.GetToken(MySqlParserLEFT, 0)
}

func (s *OuterJoinContext) RIGHT() antlr.TerminalNode {
	return s.GetToken(MySqlParserRIGHT, 0)
}

func (s *OuterJoinContext) ON() antlr.TerminalNode {
	return s.GetToken(MySqlParserON, 0)
}

func (s *OuterJoinContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *OuterJoinContext) USING() antlr.TerminalNode {
	return s.GetToken(MySqlParserUSING, 0)
}

func (s *OuterJoinContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *OuterJoinContext) UidList() IUidListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUidListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUidListContext)
}

func (s *OuterJoinContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *OuterJoinContext) OUTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserOUTER, 0)
}

func (s *OuterJoinContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterOuterJoin(s)
	}
}

func (s *OuterJoinContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitOuterJoin(s)
	}
}

func (s *OuterJoinContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitOuterJoin(s)

	default:
		return t.VisitChildren(s)
	}
}

type StraightJoinContext struct {
	*JoinPartContext
}

func NewStraightJoinContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StraightJoinContext {
	var p = new(StraightJoinContext)

	p.JoinPartContext = NewEmptyJoinPartContext()
	p.parser = parser
	p.CopyFrom(ctx.(*JoinPartContext))

	return p
}

func (s *StraightJoinContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StraightJoinContext) STRAIGHT_JOIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRAIGHT_JOIN, 0)
}

func (s *StraightJoinContext) TableSourceItem() ITableSourceItemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableSourceItemContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableSourceItemContext)
}

func (s *StraightJoinContext) ON() antlr.TerminalNode {
	return s.GetToken(MySqlParserON, 0)
}

func (s *StraightJoinContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *StraightJoinContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterStraightJoin(s)
	}
}

func (s *StraightJoinContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitStraightJoin(s)
	}
}

func (s *StraightJoinContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitStraightJoin(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) JoinPart() (localctx IJoinPartContext) {
	localctx = NewJoinPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, MySqlParserRULE_joinPart)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(366)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case MySqlParserCROSS, MySqlParserINNER, MySqlParserJOIN:
		localctx = NewInnerJoinContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(323)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserCROSS || _la == MySqlParserINNER {
			{
				p.SetState(322)
				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserCROSS || _la == MySqlParserINNER) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(325)
			p.Match(MySqlParserJOIN)
		}
		{
			p.SetState(326)
			p.TableSourceItem()
		}
		p.SetState(334)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case MySqlParserON:
			{
				p.SetState(327)
				p.Match(MySqlParserON)
			}
			{
				p.SetState(328)
				p.expression(0)
			}

		case MySqlParserUSING:
			{
				p.SetState(329)
				p.Match(MySqlParserUSING)
			}
			{
				p.SetState(330)
				p.Match(MySqlParserLR_BRACKET)
			}
			{
				p.SetState(331)
				p.UidList()
			}
			{
				p.SetState(332)
				p.Match(MySqlParserRR_BRACKET)
			}

		case MySqlParserEOF, MySqlParserAS, MySqlParserCROSS, MySqlParserCURRENT, MySqlParserDATABASE, MySqlParserDIAGNOSTICS, MySqlParserFOR, MySqlParserGROUP, MySqlParserHAVING, MySqlParserINNER, MySqlParserINTO, MySqlParserJOIN, MySqlParserLEFT, MySqlParserLIMIT, MySqlParserLOCK, MySqlParserNATURAL, MySqlParserNUMBER, MySqlParserORDER, MySqlParserRIGHT, MySqlParserSTACKED, MySqlParserSTRAIGHT_JOIN, MySqlParserUNION, MySqlParserWHERE, MySqlParserDATE, MySqlParserTIME, MySqlParserTIMESTAMP, MySqlParserDATETIME, MySqlParserYEAR, MySqlParserTEXT, MySqlParserENUM, MySqlParserSERIAL, MySqlParserJSON_VALID, MySqlParserJSON_SCHEMA_VALID, MySqlParserCOUNT, MySqlParserPOSITION, MySqlParserACCOUNT, MySqlParserACTION, MySqlParserAFTER, MySqlParserAGGREGATE, MySqlParserALGORITHM, MySqlParserANY, MySqlParserAT, MySqlParserAUTHORS, MySqlParserAUTOCOMMIT, MySqlParserAUTOEXTEND_SIZE, MySqlParserAUTO_INCREMENT, MySqlParserAVG_ROW_LENGTH, MySqlParserBEGIN, MySqlParserBINLOG, MySqlParserBIT, MySqlParserBLOCK, MySqlParserBOOL, MySqlParserBOOLEAN, MySqlParserBTREE, MySqlParserCACHE, MySqlParserCASCADED, MySqlParserCHAIN, MySqlParserCHANGED, MySqlParserCHANNEL, MySqlParserCHECKSUM, MySqlParserPAGE_CHECKSUM, MySqlParserCIPHER, MySqlParserCLASS_ORIGIN, MySqlParserCLIENT, MySqlParserCLOSE, MySqlParserCOALESCE, MySqlParserCODE, MySqlParserCOLUMNS, MySqlParserCOLUMN_FORMAT, MySqlParserCOLUMN_NAME, MySqlParserCOMMENT, MySqlParserCOMMIT, MySqlParserCOMPACT, MySqlParserCOMPLETION, MySqlParserCOMPRESSED, MySqlParserCOMPRESSION, MySqlParserCONCURRENT, MySqlParserCONNECTION, MySqlParserCONSISTENT, MySqlParserCONSTRAINT_CATALOG, MySqlParserCONSTRAINT_SCHEMA, MySqlParserCONSTRAINT_NAME, MySqlParserCONTAINS, MySqlParserCONTEXT, MySqlParserCONTRIBUTORS, MySqlParserCOPY, MySqlParserCPU, MySqlParserCURSOR_NAME, MySqlParserDATA, MySqlParserDATAFILE, MySqlParserDEALLOCATE, MySqlParserDEFAULT_AUTH, MySqlParserDEFINER, MySqlParserDELAY_KEY_WRITE, MySqlParserDES_KEY_FILE, MySqlParserDIRECTORY, MySqlParserDISABLE, MySqlParserDISCARD, MySqlParserDISK, MySqlParserDO, MySqlParserDUMPFILE, MySqlParserDUPLICATE, MySqlParserDYNAMIC, MySqlParserENABLE, MySqlParserENCRYPTION, MySqlParserEND, MySqlParserENDS, MySqlParserENGINE, MySqlParserENGINES, MySqlParserERROR, MySqlParserERRORS, MySqlParserESCAPE, MySqlParserEVEN, MySqlParserEVENT, MySqlParserEVENTS, MySqlParserEVERY, MySqlParserEXCHANGE, MySqlParserEXCLUSIVE, MySqlParserEXPIRE, MySqlParserEXPORT, MySqlParserEXTENDED, MySqlParserEXTENT_SIZE, MySqlParserFAST, MySqlParserFAULTS, MySqlParserFIELDS, MySqlParserFILE_BLOCK_SIZE, MySqlParserFILTER, MySqlParserFIRST, MySqlParserFIXED, MySqlParserFLUSH, MySqlParserFOLLOWS, MySqlParserFOUND, MySqlParserFULL, MySqlParserFUNCTION, MySqlParserGENERAL, MySqlParserGLOBAL, MySqlParserGRANTS, MySqlParserGROUP_REPLICATION, MySqlParserHANDLER, MySqlParserHASH, MySqlParserHELP, MySqlParserHOST, MySqlParserHOSTS, MySqlParserIDENTIFIED, MySqlParserIGNORE_SERVER_IDS, MySqlParserIMPORT, MySqlParserINDEXES, MySqlParserINITIAL_SIZE, MySqlParserINPLACE, MySqlParserINSERT_METHOD, MySqlParserINSTALL, MySqlParserINSTANCE, MySqlParserINVISIBLE, MySqlParserINVOKER, MySqlParserIO, MySqlParserIO_THREAD, MySqlParserIPC, MySqlParserISOLATION, MySqlParserISSUER, MySqlParserJSON, MySqlParserKEY_BLOCK_SIZE, MySqlParserLANGUAGE, MySqlParserLAST, MySqlParserLEAVES, MySqlParserLESS, MySqlParserLEVEL, MySqlParserLIST, MySqlParserLOCAL, MySqlParserLOGFILE, MySqlParserLOGS, MySqlParserMASTER, MySqlParserMASTER_AUTO_POSITION, MySqlParserMASTER_CONNECT_RETRY, MySqlParserMASTER_DELAY, MySqlParserMASTER_HEARTBEAT_PERIOD, MySqlParserMASTER_HOST, MySqlParserMASTER_LOG_FILE, MySqlParserMASTER_LOG_POS, MySqlParserMASTER_PASSWORD, MySqlParserMASTER_PORT, MySqlParserMASTER_RETRY_COUNT, MySqlParserMASTER_SSL, MySqlParserMASTER_SSL_CA, MySqlParserMASTER_SSL_CAPATH, MySqlParserMASTER_SSL_CERT, MySqlParserMASTER_SSL_CIPHER, MySqlParserMASTER_SSL_CRL, MySqlParserMASTER_SSL_CRLPATH, MySqlParserMASTER_SSL_KEY, MySqlParserMASTER_TLS_VERSION, MySqlParserMASTER_USER, MySqlParserMAX_CONNECTIONS_PER_HOUR, MySqlParserMAX_QUERIES_PER_HOUR, MySqlParserMAX_ROWS, MySqlParserMAX_SIZE, MySqlParserMAX_UPDATES_PER_HOUR, MySqlParserMAX_USER_CONNECTIONS, MySqlParserMEDIUM, MySqlParserMEMBER, MySqlParserMERGE, MySqlParserMESSAGE_TEXT, MySqlParserMID, MySqlParserMIGRATE, MySqlParserMIN_ROWS, MySqlParserMODE, MySqlParserMODIFY, MySqlParserMUTEX, MySqlParserMYSQL, MySqlParserMYSQL_ERRNO, MySqlParserNAME, MySqlParserNAMES, MySqlParserNCHAR, MySqlParserNEVER, MySqlParserNEXT, MySqlParserNO, MySqlParserNODEGROUP, MySqlParserNONE, MySqlParserOFFLINE, MySqlParserOFFSET, MySqlParserOF, MySqlParserOJ, MySqlParserOLD_PASSWORD, MySqlParserONE, MySqlParserONLINE, MySqlParserONLY, MySqlParserOPEN, MySqlParserOPTIMIZER_COSTS, MySqlParserOPTIONS, MySqlParserOWNER, MySqlParserPACK_KEYS, MySqlParserPAGE, MySqlParserPARSER, MySqlParserPARTIAL, MySqlParserPARTITIONING, MySqlParserPARTITIONS, MySqlParserPASSWORD, MySqlParserPHASE, MySqlParserPLUGIN, MySqlParserPLUGIN_DIR, MySqlParserPLUGINS, MySqlParserPORT, MySqlParserPRECEDES, MySqlParserPREPARE, MySqlParserPRESERVE, MySqlParserPREV, MySqlParserPROCESSLIST, MySqlParserPROFILE, MySqlParserPROFILES, MySqlParserPROXY, MySqlParserQUERY, MySqlParserQUICK, MySqlParserREBUILD, MySqlParserRECOVER, MySqlParserREDO_BUFFER_SIZE, MySqlParserREDUNDANT, MySqlParserRELAY, MySqlParserRELAY_LOG_FILE, MySqlParserRELAY_LOG_POS, MySqlParserRELAYLOG, MySqlParserREMOVE, MySqlParserREORGANIZE, MySqlParserREPAIR, MySqlParserREPLICATE_DO_DB, MySqlParserREPLICATE_DO_TABLE, MySqlParserREPLICATE_IGNORE_DB, MySqlParserREPLICATE_IGNORE_TABLE, MySqlParserREPLICATE_REWRITE_DB, MySqlParserREPLICATE_WILD_DO_TABLE, MySqlParserREPLICATE_WILD_IGNORE_TABLE, MySqlParserREPLICATION, MySqlParserRESET, MySqlParserRESUME, MySqlParserRETURNED_SQLSTATE, MySqlParserRETURNS, MySqlParserROLE, MySqlParserROLLBACK, MySqlParserROLLUP, MySqlParserROTATE, MySqlParserROW, MySqlParserROWS, MySqlParserROW_FORMAT, MySqlParserSAVEPOINT, MySqlParserSCHEDULE, MySqlParserSECURITY, MySqlParserSERVER, MySqlParserSESSION, MySqlParserSHARE, MySqlParserSHARED, MySqlParserSIGNED, MySqlParserSIMPLE, MySqlParserSLAVE, MySqlParserSLOW, MySqlParserSNAPSHOT, MySqlParserSOCKET, MySqlParserSOME, MySqlParserSONAME, MySqlParserSOUNDS, MySqlParserSOURCE, MySqlParserSQL_AFTER_GTIDS, MySqlParserSQL_AFTER_MTS_GAPS, MySqlParserSQL_BEFORE_GTIDS, MySqlParserSQL_BUFFER_RESULT, MySqlParserSQL_CACHE, MySqlParserSQL_NO_CACHE, MySqlParserSQL_THREAD, MySqlParserSTART, MySqlParserSTARTS, MySqlParserSTATS_AUTO_RECALC, MySqlParserSTATS_PERSISTENT, MySqlParserSTATS_SAMPLE_PAGES, MySqlParserSTATUS, MySqlParserSTOP, MySqlParserSTORAGE, MySqlParserSTRING, MySqlParserSUBCLASS_ORIGIN, MySqlParserSUBJECT, MySqlParserSUBPARTITION, MySqlParserSUBPARTITIONS, MySqlParserSUSPEND, MySqlParserSWAPS, MySqlParserSWITCHES, MySqlParserTABLE_NAME, MySqlParserTABLESPACE, MySqlParserTEMPORARY, MySqlParserTEMPTABLE, MySqlParserTHAN, MySqlParserTRADITIONAL, MySqlParserTRANSACTION, MySqlParserTRANSACTIONAL, MySqlParserTRIGGERS, MySqlParserTRUNCATE, MySqlParserUNDEFINED, MySqlParserUNDOFILE, MySqlParserUNDO_BUFFER_SIZE, MySqlParserUNINSTALL, MySqlParserUNKNOWN, MySqlParserUNTIL, MySqlParserUPGRADE, MySqlParserUSER, MySqlParserUSE_FRM, MySqlParserUSER_RESOURCES, MySqlParserVALIDATION, MySqlParserVALUE, MySqlParserVARIABLES, MySqlParserVIEW, MySqlParserVISIBLE, MySqlParserWAIT, MySqlParserWARNINGS, MySqlParserWITHOUT, MySqlParserWORK, MySqlParserWRAPPER, MySqlParserX509, MySqlParserXA, MySqlParserXML, MySqlParserINTERNAL, MySqlParserQUARTER, MySqlParserMONTH, MySqlParserDAY, MySqlParserHOUR, MySqlParserMINUTE, MySqlParserWEEK, MySqlParserSECOND, MySqlParserMICROSECOND, MySqlParserTABLES, MySqlParserROUTINE, MySqlParserEXECUTE, MySqlParserFILE, MySqlParserPROCESS, MySqlParserRELOAD, MySqlParserSHUTDOWN, MySqlParserSUPER, MySqlParserPRIVILEGES, MySqlParserAUDIT_ADMIN, MySqlParserBACKUP_ADMIN, MySqlParserBINLOG_ADMIN, MySqlParserBINLOG_ENCRYPTION_ADMIN, MySqlParserCLONE_ADMIN, MySqlParserCONNECTION_ADMIN, MySqlParserENCRYPTION_KEY_ADMIN, MySqlParserFIREWALL_ADMIN, MySqlParserFIREWALL_USER, MySqlParserGROUP_REPLICATION_ADMIN, MySqlParserINNODB_REDO_LOG_ARCHIVE, MySqlParserNDB_STORED_USER, MySqlParserPERSIST_RO_VARIABLES_ADMIN, MySqlParserREPLICATION_APPLIER, MySqlParserREPLICATION_SLAVE_ADMIN, MySqlParserRESOURCE_GROUP_ADMIN, MySqlParserRESOURCE_GROUP_USER, MySqlParserROLE_ADMIN, MySqlParserSESSION_VARIABLES_ADMIN, MySqlParserSET_USER_ID, MySqlParserSHOW_ROUTINE, MySqlParserSYSTEM_VARIABLES_ADMIN, MySqlParserTABLE_ENCRYPTION_ADMIN, MySqlParserVERSION_TOKEN_ADMIN, MySqlParserXA_RECOVER_ADMIN, MySqlParserARMSCII8, MySqlParserASCII, MySqlParserBIG5, MySqlParserCP1250, MySqlParserCP1251, MySqlParserCP1256, MySqlParserCP1257, MySqlParserCP850, MySqlParserCP852, MySqlParserCP866, MySqlParserCP932, MySqlParserDEC8, MySqlParserEUCJPMS, MySqlParserEUCKR, MySqlParserGB2312, MySqlParserGBK, MySqlParserGEOSTD8, MySqlParserGREEK, MySqlParserHEBREW, MySqlParserHP8, MySqlParserKEYBCS2, MySqlParserKOI8R, MySqlParserKOI8U, MySqlParserLATIN1, MySqlParserLATIN2, MySqlParserLATIN5, MySqlParserLATIN7, MySqlParserMACCE, MySqlParserMACROMAN, MySqlParserSJIS, MySqlParserSWE7, MySqlParserTIS620, MySqlParserUCS2, MySqlParserUJIS, MySqlParserUTF16, MySqlParserUTF16LE, MySqlParserUTF32, MySqlParserUTF8, MySqlParserUTF8MB3, MySqlParserUTF8MB4, MySqlParserARCHIVE, MySqlParserBLACKHOLE, MySqlParserCSV, MySqlParserFEDERATED, MySqlParserINNODB, MySqlParserMEMORY, MySqlParserMRG_MYISAM, MySqlParserMYISAM, MySqlParserNDB, MySqlParserNDBCLUSTER, MySqlParserPERFORMANCE_SCHEMA, MySqlParserTOKUDB, MySqlParserREPEATABLE, MySqlParserCOMMITTED, MySqlParserUNCOMMITTED, MySqlParserSERIALIZABLE, MySqlParserGEOMETRYCOLLECTION, MySqlParserLINESTRING, MySqlParserMULTILINESTRING, MySqlParserMULTIPOINT, MySqlParserMULTIPOLYGON, MySqlParserPOINT, MySqlParserPOLYGON, MySqlParserABS, MySqlParserACOS, MySqlParserADDDATE, MySqlParserADDTIME, MySqlParserAES_DECRYPT, MySqlParserAES_ENCRYPT, MySqlParserAREA, MySqlParserASBINARY, MySqlParserASIN, MySqlParserASTEXT, MySqlParserASWKB, MySqlParserASWKT, MySqlParserASYMMETRIC_DECRYPT, MySqlParserASYMMETRIC_DERIVE, MySqlParserASYMMETRIC_ENCRYPT, MySqlParserASYMMETRIC_SIGN, MySqlParserASYMMETRIC_VERIFY, MySqlParserATAN, MySqlParserATAN2, MySqlParserBENCHMARK, MySqlParserBIN, MySqlParserBIT_COUNT, MySqlParserBIT_LENGTH, MySqlParserBUFFER, MySqlParserCATALOG_NAME, MySqlParserCEIL, MySqlParserCEILING, MySqlParserCENTROID, MySqlParserCHARACTER_LENGTH, MySqlParserCHARSET, MySqlParserCHAR_LENGTH, MySqlParserCOERCIBILITY, MySqlParserCOLLATION, MySqlParserCOMPRESS, MySqlParserCONCAT, MySqlParserCONCAT_WS, MySqlParserCONNECTION_ID, MySqlParserCONV, MySqlParserCONVERT_TZ, MySqlParserCOS, MySqlParserCOT, MySqlParserCRC32, MySqlParserCREATE_ASYMMETRIC_PRIV_KEY, MySqlParserCREATE_ASYMMETRIC_PUB_KEY, MySqlParserCREATE_DH_PARAMETERS, MySqlParserCREATE_DIGEST, MySqlParserCROSSES, MySqlParserDATEDIFF, MySqlParserDATE_FORMAT, MySqlParserDAYNAME, MySqlParserDAYOFMONTH, MySqlParserDAYOFWEEK, MySqlParserDAYOFYEAR, MySqlParserDECODE, MySqlParserDEGREES, MySqlParserDES_DECRYPT, MySqlParserDES_ENCRYPT, MySqlParserDIMENSION, MySqlParserDISJOINT, MySqlParserELT, MySqlParserENCODE, MySqlParserENCRYPT, MySqlParserENDPOINT, MySqlParserENVELOPE, MySqlParserEQUALS, MySqlParserEXP, MySqlParserEXPORT_SET, MySqlParserEXTERIORRING, MySqlParserEXTRACTVALUE, MySqlParserFIELD, MySqlParserFIND_IN_SET, MySqlParserFLOOR, MySqlParserFORMAT, MySqlParserFOUND_ROWS, MySqlParserFROM_BASE64, MySqlParserFROM_DAYS, MySqlParserFROM_UNIXTIME, MySqlParserGEOMCOLLFROMTEXT, MySqlParserGEOMCOLLFROMWKB, MySqlParserGEOMETRYCOLLECTIONFROMTEXT, MySqlParserGEOMETRYCOLLECTIONFROMWKB, MySqlParserGEOMETRYFROMTEXT, MySqlParserGEOMETRYFROMWKB, MySqlParserGEOMETRYN, MySqlParserGEOMETRYTYPE, MySqlParserGEOMFROMTEXT, MySqlParserGEOMFROMWKB, MySqlParserGET_FORMAT, MySqlParserGET_LOCK, MySqlParserGLENGTH, MySqlParserGREATEST, MySqlParserGTID_SUBSET, MySqlParserGTID_SUBTRACT, MySqlParserHEX, MySqlParserIFNULL, MySqlParserINET6_ATON, MySqlParserINET6_NTOA, MySqlParserINET_ATON, MySqlParserINET_NTOA, MySqlParserINSTR, MySqlParserINTERIORRINGN, MySqlParserINTERSECTS, MySqlParserISCLOSED, MySqlParserISEMPTY, MySqlParserISNULL, MySqlParserISSIMPLE, MySqlParserIS_FREE_LOCK, MySqlParserIS_IPV4, MySqlParserIS_IPV4_COMPAT, MySqlParserIS_IPV4_MAPPED, MySqlParserIS_IPV6, MySqlParserIS_USED_LOCK, MySqlParserLAST_INSERT_ID, MySqlParserLCASE, MySqlParserLEAST, MySqlParserLENGTH, MySqlParserLINEFROMTEXT, MySqlParserLINEFROMWKB, MySqlParserLINESTRINGFROMTEXT, MySqlParserLINESTRINGFROMWKB, MySqlParserLN, MySqlParserLOAD_FILE, MySqlParserLOCATE, MySqlParserLOG, MySqlParserLOG10, MySqlParserLOG2, MySqlParserLOWER, MySqlParserLPAD, MySqlParserLTRIM, MySqlParserMAKEDATE, MySqlParserMAKETIME, MySqlParserMAKE_SET, MySqlParserMASTER_POS_WAIT, MySqlParserMBRCONTAINS, MySqlParserMBRDISJOINT, MySqlParserMBREQUAL, MySqlParserMBRINTERSECTS, MySqlParserMBROVERLAPS, MySqlParserMBRTOUCHES, MySqlParserMBRWITHIN, MySqlParserMD5, MySqlParserMLINEFROMTEXT, MySqlParserMLINEFROMWKB, MySqlParserMONTHNAME, MySqlParserMPOINTFROMTEXT, MySqlParserMPOINTFROMWKB, MySqlParserMPOLYFROMTEXT, MySqlParserMPOLYFROMWKB, MySqlParserMULTILINESTRINGFROMTEXT, MySqlParserMULTILINESTRINGFROMWKB, MySqlParserMULTIPOINTFROMTEXT, MySqlParserMULTIPOINTFROMWKB, MySqlParserMULTIPOLYGONFROMTEXT, MySqlParserMULTIPOLYGONFROMWKB, MySqlParserNAME_CONST, MySqlParserNULLIF, MySqlParserNUMGEOMETRIES, MySqlParserNUMINTERIORRINGS, MySqlParserNUMPOINTS, MySqlParserOCT, MySqlParserOCTET_LENGTH, MySqlParserORD, MySqlParserOVERLAPS, MySqlParserPERIOD_ADD, MySqlParserPERIOD_DIFF, MySqlParserPI, MySqlParserPOINTFROMTEXT, MySqlParserPOINTFROMWKB, MySqlParserPOINTN, MySqlParserPOLYFROMTEXT, MySqlParserPOLYFROMWKB, MySqlParserPOLYGONFROMTEXT, MySqlParserPOLYGONFROMWKB, MySqlParserPOW, MySqlParserPOWER, MySqlParserQUOTE, MySqlParserRADIANS, MySqlParserRAND, MySqlParserRANDOM_BYTES, MySqlParserRELEASE_LOCK, MySqlParserREVERSE, MySqlParserROUND, MySqlParserROW_COUNT, MySqlParserRPAD, MySqlParserRTRIM, MySqlParserSEC_TO_TIME, MySqlParserSESSION_USER, MySqlParserSHA, MySqlParserSHA1, MySqlParserSHA2, MySqlParserSCHEMA_NAME, MySqlParserSIGN, MySqlParserSIN, MySqlParserSLEEP, MySqlParserSOUNDEX, MySqlParserSQL_THREAD_WAIT_AFTER_GTIDS, MySqlParserSQRT, MySqlParserSRID, MySqlParserSTARTPOINT, MySqlParserSTRCMP, MySqlParserSTR_TO_DATE, MySqlParserST_AREA, MySqlParserST_ASBINARY, MySqlParserST_ASTEXT, MySqlParserST_ASWKB, MySqlParserST_ASWKT, MySqlParserST_BUFFER, MySqlParserST_CENTROID, MySqlParserST_CONTAINS, MySqlParserST_CROSSES, MySqlParserST_DIFFERENCE, MySqlParserST_DIMENSION, MySqlParserST_DISJOINT, MySqlParserST_DISTANCE, MySqlParserST_ENDPOINT, MySqlParserST_ENVELOPE, MySqlParserST_EQUALS, MySqlParserST_EXTERIORRING, MySqlParserST_GEOMCOLLFROMTEXT, MySqlParserST_GEOMCOLLFROMTXT, MySqlParserST_GEOMCOLLFROMWKB, MySqlParserST_GEOMETRYCOLLECTIONFROMTEXT, MySqlParserST_GEOMETRYCOLLECTIONFROMWKB, MySqlParserST_GEOMETRYFROMTEXT, MySqlParserST_GEOMETRYFROMWKB, MySqlParserST_GEOMETRYN, MySqlParserST_GEOMETRYTYPE, MySqlParserST_GEOMFROMTEXT, MySqlParserST_GEOMFROMWKB, MySqlParserST_INTERIORRINGN, MySqlParserST_INTERSECTION, MySqlParserST_INTERSECTS, MySqlParserST_ISCLOSED, MySqlParserST_ISEMPTY, MySqlParserST_ISSIMPLE, MySqlParserST_LINEFROMTEXT, MySqlParserST_LINEFROMWKB, MySqlParserST_LINESTRINGFROMTEXT, MySqlParserST_LINESTRINGFROMWKB, MySqlParserST_NUMGEOMETRIES, MySqlParserST_NUMINTERIORRING, MySqlParserST_NUMINTERIORRINGS, MySqlParserST_NUMPOINTS, MySqlParserST_OVERLAPS, MySqlParserST_POINTFROMTEXT, MySqlParserST_POINTFROMWKB, MySqlParserST_POINTN, MySqlParserST_POLYFROMTEXT, MySqlParserST_POLYFROMWKB, MySqlParserST_POLYGONFROMTEXT, MySqlParserST_POLYGONFROMWKB, MySqlParserST_SRID, MySqlParserST_STARTPOINT, MySqlParserST_SYMDIFFERENCE, MySqlParserST_TOUCHES, MySqlParserST_UNION, MySqlParserST_WITHIN, MySqlParserST_X, MySqlParserST_Y, MySqlParserSUBDATE, MySqlParserSUBSTRING_INDEX, MySqlParserSUBTIME, MySqlParserSYSTEM_USER, MySqlParserTAN, MySqlParserTIMEDIFF, MySqlParserTIMESTAMPADD, MySqlParserTIMESTAMPDIFF, MySqlParserTIME_FORMAT, MySqlParserTIME_TO_SEC, MySqlParserTOUCHES, MySqlParserTO_BASE64, MySqlParserTO_DAYS, MySqlParserTO_SECONDS, MySqlParserUCASE, MySqlParserUNCOMPRESS, MySqlParserUNCOMPRESSED_LENGTH, MySqlParserUNHEX, MySqlParserUNIX_TIMESTAMP, MySqlParserUPDATEXML, MySqlParserUPPER, MySqlParserUUID, MySqlParserUUID_SHORT, MySqlParserVALIDATE_PASSWORD_STRENGTH, MySqlParserVERSION, MySqlParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS, MySqlParserWEEKDAY, MySqlParserWEEKOFYEAR, MySqlParserWEIGHT_STRING, MySqlParserWITHIN, MySqlParserYEARWEEK, MySqlParserY_FUNCTION, MySqlParserX_FUNCTION, MySqlParserRR_BRACKET, MySqlParserCOMMA, MySqlParserCHARSET_REVERSE_QOUTE_STRING, MySqlParserSTRING_LITERAL, MySqlParserID, MySqlParserREVERSE_QUOTE_ID:

		default:
		}

	case MySqlParserSTRAIGHT_JOIN:
		localctx = NewStraightJoinContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(336)
			p.Match(MySqlParserSTRAIGHT_JOIN)
		}
		{
			p.SetState(337)
			p.TableSourceItem()
		}
		p.SetState(340)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserON {
			{
				p.SetState(338)
				p.Match(MySqlParserON)
			}
			{
				p.SetState(339)
				p.expression(0)
			}

		}

	case MySqlParserLEFT, MySqlParserRIGHT:
		localctx = NewOuterJoinContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(342)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserLEFT || _la == MySqlParserRIGHT) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(344)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserOUTER {
			{
				p.SetState(343)
				p.Match(MySqlParserOUTER)
			}

		}
		{
			p.SetState(346)
			p.Match(MySqlParserJOIN)
		}
		{
			p.SetState(347)
			p.TableSourceItem()
		}
		p.SetState(355)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case MySqlParserON:
			{
				p.SetState(348)
				p.Match(MySqlParserON)
			}
			{
				p.SetState(349)
				p.expression(0)
			}

		case MySqlParserUSING:
			{
				p.SetState(350)
				p.Match(MySqlParserUSING)
			}
			{
				p.SetState(351)
				p.Match(MySqlParserLR_BRACKET)
			}
			{
				p.SetState(352)
				p.UidList()
			}
			{
				p.SetState(353)
				p.Match(MySqlParserRR_BRACKET)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	case MySqlParserNATURAL:
		localctx = NewNaturalJoinContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(357)
			p.Match(MySqlParserNATURAL)
		}
		p.SetState(362)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserLEFT || _la == MySqlParserRIGHT {
			{
				p.SetState(358)
				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserLEFT || _la == MySqlParserRIGHT) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			p.SetState(360)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == MySqlParserOUTER {
				{
					p.SetState(359)
					p.Match(MySqlParserOUTER)
				}

			}

		}
		{
			p.SetState(364)
			p.Match(MySqlParserJOIN)
		}
		{
			p.SetState(365)
			p.TableSourceItem()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IQueryExpressionContext is an interface to support dynamic dispatch.
type IQueryExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQueryExpressionContext differentiates from other interfaces.
	IsQueryExpressionContext()
}

type QueryExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryExpressionContext() *QueryExpressionContext {
	var p = new(QueryExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_queryExpression
	return p
}

func (*QueryExpressionContext) IsQueryExpressionContext() {}

func NewQueryExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryExpressionContext {
	var p = new(QueryExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_queryExpression

	return p
}

func (s *QueryExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryExpressionContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *QueryExpressionContext) QuerySpecification() IQuerySpecificationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQuerySpecificationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQuerySpecificationContext)
}

func (s *QueryExpressionContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *QueryExpressionContext) QueryExpression() IQueryExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueryExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQueryExpressionContext)
}

func (s *QueryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QueryExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterQueryExpression(s)
	}
}

func (s *QueryExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitQueryExpression(s)
	}
}

func (s *QueryExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitQueryExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) QueryExpression() (localctx IQueryExpressionContext) {
	localctx = NewQueryExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, MySqlParserRULE_queryExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(376)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 39, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(368)
			p.Match(MySqlParserLR_BRACKET)
		}
		{
			p.SetState(369)
			p.QuerySpecification()
		}
		{
			p.SetState(370)
			p.Match(MySqlParserRR_BRACKET)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(372)
			p.Match(MySqlParserLR_BRACKET)
		}
		{
			p.SetState(373)
			p.QueryExpression()
		}
		{
			p.SetState(374)
			p.Match(MySqlParserRR_BRACKET)
		}

	}

	return localctx
}

// IQueryExpressionNointoContext is an interface to support dynamic dispatch.
type IQueryExpressionNointoContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQueryExpressionNointoContext differentiates from other interfaces.
	IsQueryExpressionNointoContext()
}

type QueryExpressionNointoContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryExpressionNointoContext() *QueryExpressionNointoContext {
	var p = new(QueryExpressionNointoContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_queryExpressionNointo
	return p
}

func (*QueryExpressionNointoContext) IsQueryExpressionNointoContext() {}

func NewQueryExpressionNointoContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryExpressionNointoContext {
	var p = new(QueryExpressionNointoContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_queryExpressionNointo

	return p
}

func (s *QueryExpressionNointoContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryExpressionNointoContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *QueryExpressionNointoContext) QuerySpecificationNointo() IQuerySpecificationNointoContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQuerySpecificationNointoContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQuerySpecificationNointoContext)
}

func (s *QueryExpressionNointoContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *QueryExpressionNointoContext) QueryExpressionNointo() IQueryExpressionNointoContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueryExpressionNointoContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQueryExpressionNointoContext)
}

func (s *QueryExpressionNointoContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryExpressionNointoContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QueryExpressionNointoContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterQueryExpressionNointo(s)
	}
}

func (s *QueryExpressionNointoContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitQueryExpressionNointo(s)
	}
}

func (s *QueryExpressionNointoContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitQueryExpressionNointo(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) QueryExpressionNointo() (localctx IQueryExpressionNointoContext) {
	localctx = NewQueryExpressionNointoContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, MySqlParserRULE_queryExpressionNointo)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(386)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 40, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(378)
			p.Match(MySqlParserLR_BRACKET)
		}
		{
			p.SetState(379)
			p.QuerySpecificationNointo()
		}
		{
			p.SetState(380)
			p.Match(MySqlParserRR_BRACKET)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(382)
			p.Match(MySqlParserLR_BRACKET)
		}
		{
			p.SetState(383)
			p.QueryExpressionNointo()
		}
		{
			p.SetState(384)
			p.Match(MySqlParserRR_BRACKET)
		}

	}

	return localctx
}

// IQuerySpecificationContext is an interface to support dynamic dispatch.
type IQuerySpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQuerySpecificationContext differentiates from other interfaces.
	IsQuerySpecificationContext()
}

type QuerySpecificationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuerySpecificationContext() *QuerySpecificationContext {
	var p = new(QuerySpecificationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_querySpecification
	return p
}

func (*QuerySpecificationContext) IsQuerySpecificationContext() {}

func NewQuerySpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QuerySpecificationContext {
	var p = new(QuerySpecificationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_querySpecification

	return p
}

func (s *QuerySpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *QuerySpecificationContext) CopyFrom(ctx *QuerySpecificationContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *QuerySpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuerySpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type QuerySpecification1Context struct {
	*QuerySpecificationContext
}

func NewQuerySpecification1Context(parser antlr.Parser, ctx antlr.ParserRuleContext) *QuerySpecification1Context {
	var p = new(QuerySpecification1Context)

	p.QuerySpecificationContext = NewEmptyQuerySpecificationContext()
	p.parser = parser
	p.CopyFrom(ctx.(*QuerySpecificationContext))

	return p
}

func (s *QuerySpecification1Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuerySpecification1Context) SELECT() antlr.TerminalNode {
	return s.GetToken(MySqlParserSELECT, 0)
}

func (s *QuerySpecification1Context) SelectElements() ISelectElementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelectElementsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelectElementsContext)
}

func (s *QuerySpecification1Context) AllSelectSpec() []ISelectSpecContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISelectSpecContext)(nil)).Elem())
	var tst = make([]ISelectSpecContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISelectSpecContext)
		}
	}

	return tst
}

func (s *QuerySpecification1Context) SelectSpec(i int) ISelectSpecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelectSpecContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISelectSpecContext)
}

func (s *QuerySpecification1Context) SelectIntoExpression() ISelectIntoExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelectIntoExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelectIntoExpressionContext)
}

func (s *QuerySpecification1Context) FromClause() IFromClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFromClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFromClauseContext)
}

func (s *QuerySpecification1Context) OrderByClause() IOrderByClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOrderByClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOrderByClauseContext)
}

func (s *QuerySpecification1Context) LimitClause() ILimitClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILimitClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *QuerySpecification1Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterQuerySpecification1(s)
	}
}

func (s *QuerySpecification1Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitQuerySpecification1(s)
	}
}

func (s *QuerySpecification1Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitQuerySpecification1(s)

	default:
		return t.VisitChildren(s)
	}
}

type QuerySpecification2Context struct {
	*QuerySpecificationContext
}

func NewQuerySpecification2Context(parser antlr.Parser, ctx antlr.ParserRuleContext) *QuerySpecification2Context {
	var p = new(QuerySpecification2Context)

	p.QuerySpecificationContext = NewEmptyQuerySpecificationContext()
	p.parser = parser
	p.CopyFrom(ctx.(*QuerySpecificationContext))

	return p
}

func (s *QuerySpecification2Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuerySpecification2Context) SELECT() antlr.TerminalNode {
	return s.GetToken(MySqlParserSELECT, 0)
}

func (s *QuerySpecification2Context) SelectElements() ISelectElementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelectElementsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelectElementsContext)
}

func (s *QuerySpecification2Context) AllSelectSpec() []ISelectSpecContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISelectSpecContext)(nil)).Elem())
	var tst = make([]ISelectSpecContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISelectSpecContext)
		}
	}

	return tst
}

func (s *QuerySpecification2Context) SelectSpec(i int) ISelectSpecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelectSpecContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISelectSpecContext)
}

func (s *QuerySpecification2Context) FromClause() IFromClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFromClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFromClauseContext)
}

func (s *QuerySpecification2Context) OrderByClause() IOrderByClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOrderByClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOrderByClauseContext)
}

func (s *QuerySpecification2Context) LimitClause() ILimitClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILimitClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *QuerySpecification2Context) SelectIntoExpression() ISelectIntoExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelectIntoExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelectIntoExpressionContext)
}

func (s *QuerySpecification2Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterQuerySpecification2(s)
	}
}

func (s *QuerySpecification2Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitQuerySpecification2(s)
	}
}

func (s *QuerySpecification2Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitQuerySpecification2(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) QuerySpecification() (localctx IQuerySpecificationContext) {
	localctx = NewQuerySpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, MySqlParserRULE_querySpecification)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(428)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 51, p.GetParserRuleContext()) {
	case 1:
		localctx = NewQuerySpecification1Context(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(388)
			p.Match(MySqlParserSELECT)
		}
		p.SetState(392)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 41, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(389)
					p.SelectSpec()
				}

			}
			p.SetState(394)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 41, p.GetParserRuleContext())
		}
		{
			p.SetState(395)
			p.SelectElements()
		}
		p.SetState(397)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserINTO {
			{
				p.SetState(396)
				p.SelectIntoExpression()
			}

		}
		p.SetState(400)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserFROM {
			{
				p.SetState(399)
				p.FromClause()
			}

		}
		p.SetState(403)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 44, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(402)
				p.OrderByClause()
			}

		}
		p.SetState(406)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 45, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(405)
				p.LimitClause()
			}

		}

	case 2:
		localctx = NewQuerySpecification2Context(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(408)
			p.Match(MySqlParserSELECT)
		}
		p.SetState(412)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 46, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(409)
					p.SelectSpec()
				}

			}
			p.SetState(414)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 46, p.GetParserRuleContext())
		}
		{
			p.SetState(415)
			p.SelectElements()
		}
		p.SetState(417)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserFROM {
			{
				p.SetState(416)
				p.FromClause()
			}

		}
		p.SetState(420)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 48, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(419)
				p.OrderByClause()
			}

		}
		p.SetState(423)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 49, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(422)
				p.LimitClause()
			}

		}
		p.SetState(426)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserINTO {
			{
				p.SetState(425)
				p.SelectIntoExpression()
			}

		}

	}

	return localctx
}

// IQuerySpecificationNointoContext is an interface to support dynamic dispatch.
type IQuerySpecificationNointoContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQuerySpecificationNointoContext differentiates from other interfaces.
	IsQuerySpecificationNointoContext()
}

type QuerySpecificationNointoContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuerySpecificationNointoContext() *QuerySpecificationNointoContext {
	var p = new(QuerySpecificationNointoContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_querySpecificationNointo
	return p
}

func (*QuerySpecificationNointoContext) IsQuerySpecificationNointoContext() {}

func NewQuerySpecificationNointoContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QuerySpecificationNointoContext {
	var p = new(QuerySpecificationNointoContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_querySpecificationNointo

	return p
}

func (s *QuerySpecificationNointoContext) GetParser() antlr.Parser { return s.parser }

func (s *QuerySpecificationNointoContext) SELECT() antlr.TerminalNode {
	return s.GetToken(MySqlParserSELECT, 0)
}

func (s *QuerySpecificationNointoContext) SelectElements() ISelectElementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelectElementsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelectElementsContext)
}

func (s *QuerySpecificationNointoContext) AllSelectSpec() []ISelectSpecContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISelectSpecContext)(nil)).Elem())
	var tst = make([]ISelectSpecContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISelectSpecContext)
		}
	}

	return tst
}

func (s *QuerySpecificationNointoContext) SelectSpec(i int) ISelectSpecContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelectSpecContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISelectSpecContext)
}

func (s *QuerySpecificationNointoContext) FromClause() IFromClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFromClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFromClauseContext)
}

func (s *QuerySpecificationNointoContext) OrderByClause() IOrderByClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOrderByClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOrderByClauseContext)
}

func (s *QuerySpecificationNointoContext) LimitClause() ILimitClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILimitClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *QuerySpecificationNointoContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuerySpecificationNointoContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QuerySpecificationNointoContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterQuerySpecificationNointo(s)
	}
}

func (s *QuerySpecificationNointoContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitQuerySpecificationNointo(s)
	}
}

func (s *QuerySpecificationNointoContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitQuerySpecificationNointo(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) QuerySpecificationNointo() (localctx IQuerySpecificationNointoContext) {
	localctx = NewQuerySpecificationNointoContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, MySqlParserRULE_querySpecificationNointo)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(430)
		p.Match(MySqlParserSELECT)
	}
	p.SetState(434)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 52, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(431)
				p.SelectSpec()
			}

		}
		p.SetState(436)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 52, p.GetParserRuleContext())
	}
	{
		p.SetState(437)
		p.SelectElements()
	}
	p.SetState(439)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserFROM {
		{
			p.SetState(438)
			p.FromClause()
		}

	}
	p.SetState(442)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 54, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(441)
			p.OrderByClause()
		}

	}
	p.SetState(445)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 55, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(444)
			p.LimitClause()
		}

	}

	return localctx
}

// IUnionParenthesisContext is an interface to support dynamic dispatch.
type IUnionParenthesisContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetUnionType returns the unionType token.
	GetUnionType() antlr.Token

	// SetUnionType sets the unionType token.
	SetUnionType(antlr.Token)

	// IsUnionParenthesisContext differentiates from other interfaces.
	IsUnionParenthesisContext()
}

type UnionParenthesisContext struct {
	*antlr.BaseParserRuleContext
	parser    antlr.Parser
	unionType antlr.Token
}

func NewEmptyUnionParenthesisContext() *UnionParenthesisContext {
	var p = new(UnionParenthesisContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_unionParenthesis
	return p
}

func (*UnionParenthesisContext) IsUnionParenthesisContext() {}

func NewUnionParenthesisContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnionParenthesisContext {
	var p = new(UnionParenthesisContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_unionParenthesis

	return p
}

func (s *UnionParenthesisContext) GetParser() antlr.Parser { return s.parser }

func (s *UnionParenthesisContext) GetUnionType() antlr.Token { return s.unionType }

func (s *UnionParenthesisContext) SetUnionType(v antlr.Token) { s.unionType = v }

func (s *UnionParenthesisContext) UNION() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNION, 0)
}

func (s *UnionParenthesisContext) QueryExpressionNointo() IQueryExpressionNointoContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueryExpressionNointoContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQueryExpressionNointoContext)
}

func (s *UnionParenthesisContext) ALL() antlr.TerminalNode {
	return s.GetToken(MySqlParserALL, 0)
}

func (s *UnionParenthesisContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDISTINCT, 0)
}

func (s *UnionParenthesisContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnionParenthesisContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnionParenthesisContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterUnionParenthesis(s)
	}
}

func (s *UnionParenthesisContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitUnionParenthesis(s)
	}
}

func (s *UnionParenthesisContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitUnionParenthesis(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) UnionParenthesis() (localctx IUnionParenthesisContext) {
	localctx = NewUnionParenthesisContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, MySqlParserRULE_unionParenthesis)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(447)
		p.Match(MySqlParserUNION)
	}
	p.SetState(449)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserALL || _la == MySqlParserDISTINCT {
		{
			p.SetState(448)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*UnionParenthesisContext).unionType = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserALL || _la == MySqlParserDISTINCT) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*UnionParenthesisContext).unionType = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(451)
		p.QueryExpressionNointo()
	}

	return localctx
}

// IUnionStatementContext is an interface to support dynamic dispatch.
type IUnionStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetUnionType returns the unionType token.
	GetUnionType() antlr.Token

	// SetUnionType sets the unionType token.
	SetUnionType(antlr.Token)

	// IsUnionStatementContext differentiates from other interfaces.
	IsUnionStatementContext()
}

type UnionStatementContext struct {
	*antlr.BaseParserRuleContext
	parser    antlr.Parser
	unionType antlr.Token
}

func NewEmptyUnionStatementContext() *UnionStatementContext {
	var p = new(UnionStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_unionStatement
	return p
}

func (*UnionStatementContext) IsUnionStatementContext() {}

func NewUnionStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnionStatementContext {
	var p = new(UnionStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_unionStatement

	return p
}

func (s *UnionStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UnionStatementContext) GetUnionType() antlr.Token { return s.unionType }

func (s *UnionStatementContext) SetUnionType(v antlr.Token) { s.unionType = v }

func (s *UnionStatementContext) UNION() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNION, 0)
}

func (s *UnionStatementContext) QuerySpecificationNointo() IQuerySpecificationNointoContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQuerySpecificationNointoContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQuerySpecificationNointoContext)
}

func (s *UnionStatementContext) QueryExpressionNointo() IQueryExpressionNointoContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueryExpressionNointoContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQueryExpressionNointoContext)
}

func (s *UnionStatementContext) ALL() antlr.TerminalNode {
	return s.GetToken(MySqlParserALL, 0)
}

func (s *UnionStatementContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDISTINCT, 0)
}

func (s *UnionStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnionStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnionStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterUnionStatement(s)
	}
}

func (s *UnionStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitUnionStatement(s)
	}
}

func (s *UnionStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitUnionStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) UnionStatement() (localctx IUnionStatementContext) {
	localctx = NewUnionStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, MySqlParserRULE_unionStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(453)
		p.Match(MySqlParserUNION)
	}
	p.SetState(455)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserALL || _la == MySqlParserDISTINCT {
		{
			p.SetState(454)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*UnionStatementContext).unionType = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserALL || _la == MySqlParserDISTINCT) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*UnionStatementContext).unionType = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(459)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case MySqlParserSELECT:
		{
			p.SetState(457)
			p.QuerySpecificationNointo()
		}

	case MySqlParserLR_BRACKET:
		{
			p.SetState(458)
			p.QueryExpressionNointo()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IUnionStatement2Context is an interface to support dynamic dispatch.
type IUnionStatement2Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetUnionType returns the unionType token.
	GetUnionType() antlr.Token

	// SetUnionType sets the unionType token.
	SetUnionType(antlr.Token)

	// IsUnionStatement2Context differentiates from other interfaces.
	IsUnionStatement2Context()
}

type UnionStatement2Context struct {
	*antlr.BaseParserRuleContext
	parser    antlr.Parser
	unionType antlr.Token
}

func NewEmptyUnionStatement2Context() *UnionStatement2Context {
	var p = new(UnionStatement2Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_unionStatement2
	return p
}

func (*UnionStatement2Context) IsUnionStatement2Context() {}

func NewUnionStatement2Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnionStatement2Context {
	var p = new(UnionStatement2Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_unionStatement2

	return p
}

func (s *UnionStatement2Context) GetParser() antlr.Parser { return s.parser }

func (s *UnionStatement2Context) GetUnionType() antlr.Token { return s.unionType }

func (s *UnionStatement2Context) SetUnionType(v antlr.Token) { s.unionType = v }

func (s *UnionStatement2Context) UNION() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNION, 0)
}

func (s *UnionStatement2Context) QuerySpecification() IQuerySpecificationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQuerySpecificationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQuerySpecificationContext)
}

func (s *UnionStatement2Context) QueryExpression() IQueryExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueryExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQueryExpressionContext)
}

func (s *UnionStatement2Context) ALL() antlr.TerminalNode {
	return s.GetToken(MySqlParserALL, 0)
}

func (s *UnionStatement2Context) DISTINCT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDISTINCT, 0)
}

func (s *UnionStatement2Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnionStatement2Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnionStatement2Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterUnionStatement2(s)
	}
}

func (s *UnionStatement2Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitUnionStatement2(s)
	}
}

func (s *UnionStatement2Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitUnionStatement2(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) UnionStatement2() (localctx IUnionStatement2Context) {
	localctx = NewUnionStatement2Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, MySqlParserRULE_unionStatement2)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(461)
		p.Match(MySqlParserUNION)
	}
	p.SetState(463)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserALL || _la == MySqlParserDISTINCT {
		{
			p.SetState(462)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*UnionStatement2Context).unionType = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserALL || _la == MySqlParserDISTINCT) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*UnionStatement2Context).unionType = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(467)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case MySqlParserSELECT:
		{
			p.SetState(465)
			p.QuerySpecification()
		}

	case MySqlParserLR_BRACKET:
		{
			p.SetState(466)
			p.QueryExpression()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IUnionstatement3Context is an interface to support dynamic dispatch.
type IUnionstatement3Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetUnionType returns the unionType token.
	GetUnionType() antlr.Token

	// SetUnionType sets the unionType token.
	SetUnionType(antlr.Token)

	// IsUnionstatement3Context differentiates from other interfaces.
	IsUnionstatement3Context()
}

type Unionstatement3Context struct {
	*antlr.BaseParserRuleContext
	parser    antlr.Parser
	unionType antlr.Token
}

func NewEmptyUnionstatement3Context() *Unionstatement3Context {
	var p = new(Unionstatement3Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_unionstatement3
	return p
}

func (*Unionstatement3Context) IsUnionstatement3Context() {}

func NewUnionstatement3Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Unionstatement3Context {
	var p = new(Unionstatement3Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_unionstatement3

	return p
}

func (s *Unionstatement3Context) GetParser() antlr.Parser { return s.parser }

func (s *Unionstatement3Context) GetUnionType() antlr.Token { return s.unionType }

func (s *Unionstatement3Context) SetUnionType(v antlr.Token) { s.unionType = v }

func (s *Unionstatement3Context) UNION() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNION, 0)
}

func (s *Unionstatement3Context) QueryExpression() IQueryExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueryExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQueryExpressionContext)
}

func (s *Unionstatement3Context) ALL() antlr.TerminalNode {
	return s.GetToken(MySqlParserALL, 0)
}

func (s *Unionstatement3Context) DISTINCT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDISTINCT, 0)
}

func (s *Unionstatement3Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Unionstatement3Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Unionstatement3Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterUnionstatement3(s)
	}
}

func (s *Unionstatement3Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitUnionstatement3(s)
	}
}

func (s *Unionstatement3Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitUnionstatement3(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) Unionstatement3() (localctx IUnionstatement3Context) {
	localctx = NewUnionstatement3Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, MySqlParserRULE_unionstatement3)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(469)
		p.Match(MySqlParserUNION)
	}
	p.SetState(471)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserALL || _la == MySqlParserDISTINCT {
		{
			p.SetState(470)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*Unionstatement3Context).unionType = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserALL || _la == MySqlParserDISTINCT) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*Unionstatement3Context).unionType = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(473)
		p.QueryExpression()
	}

	return localctx
}

// ISelectSpecContext is an interface to support dynamic dispatch.
type ISelectSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSelectSpecContext differentiates from other interfaces.
	IsSelectSpecContext()
}

type SelectSpecContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectSpecContext() *SelectSpecContext {
	var p = new(SelectSpecContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_selectSpec
	return p
}

func (*SelectSpecContext) IsSelectSpecContext() {}

func NewSelectSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectSpecContext {
	var p = new(SelectSpecContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_selectSpec

	return p
}

func (s *SelectSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectSpecContext) ALL() antlr.TerminalNode {
	return s.GetToken(MySqlParserALL, 0)
}

func (s *SelectSpecContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDISTINCT, 0)
}

func (s *SelectSpecContext) DISTINCTROW() antlr.TerminalNode {
	return s.GetToken(MySqlParserDISTINCTROW, 0)
}

func (s *SelectSpecContext) HIGH_PRIORITY() antlr.TerminalNode {
	return s.GetToken(MySqlParserHIGH_PRIORITY, 0)
}

func (s *SelectSpecContext) STRAIGHT_JOIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRAIGHT_JOIN, 0)
}

func (s *SelectSpecContext) SQL_SMALL_RESULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQL_SMALL_RESULT, 0)
}

func (s *SelectSpecContext) SQL_BIG_RESULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQL_BIG_RESULT, 0)
}

func (s *SelectSpecContext) SQL_BUFFER_RESULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQL_BUFFER_RESULT, 0)
}

func (s *SelectSpecContext) SQL_CACHE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQL_CACHE, 0)
}

func (s *SelectSpecContext) SQL_NO_CACHE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQL_NO_CACHE, 0)
}

func (s *SelectSpecContext) SQL_CALC_FOUND_ROWS() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQL_CALC_FOUND_ROWS, 0)
}

func (s *SelectSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSelectSpec(s)
	}
}

func (s *SelectSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSelectSpec(s)
	}
}

func (s *SelectSpecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSelectSpec(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) SelectSpec() (localctx ISelectSpecContext) {
	localctx = NewSelectSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, MySqlParserRULE_selectSpec)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(483)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case MySqlParserALL, MySqlParserDISTINCT, MySqlParserDISTINCTROW:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(475)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserALL || _la == MySqlParserDISTINCT || _la == MySqlParserDISTINCTROW) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case MySqlParserHIGH_PRIORITY:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(476)
			p.Match(MySqlParserHIGH_PRIORITY)
		}

	case MySqlParserSTRAIGHT_JOIN:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(477)
			p.Match(MySqlParserSTRAIGHT_JOIN)
		}

	case MySqlParserSQL_SMALL_RESULT:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(478)
			p.Match(MySqlParserSQL_SMALL_RESULT)
		}

	case MySqlParserSQL_BIG_RESULT:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(479)
			p.Match(MySqlParserSQL_BIG_RESULT)
		}

	case MySqlParserSQL_BUFFER_RESULT:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(480)
			p.Match(MySqlParserSQL_BUFFER_RESULT)
		}

	case MySqlParserSQL_CACHE, MySqlParserSQL_NO_CACHE:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(481)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserSQL_CACHE || _la == MySqlParserSQL_NO_CACHE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case MySqlParserSQL_CALC_FOUND_ROWS:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(482)
			p.Match(MySqlParserSQL_CALC_FOUND_ROWS)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISelectElementsContext is an interface to support dynamic dispatch.
type ISelectElementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetStar returns the star token.
	GetStar() antlr.Token

	// SetStar sets the star token.
	SetStar(antlr.Token)

	// IsSelectElementsContext differentiates from other interfaces.
	IsSelectElementsContext()
}

type SelectElementsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	star   antlr.Token
}

func NewEmptySelectElementsContext() *SelectElementsContext {
	var p = new(SelectElementsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_selectElements
	return p
}

func (*SelectElementsContext) IsSelectElementsContext() {}

func NewSelectElementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectElementsContext {
	var p = new(SelectElementsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_selectElements

	return p
}

func (s *SelectElementsContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectElementsContext) GetStar() antlr.Token { return s.star }

func (s *SelectElementsContext) SetStar(v antlr.Token) { s.star = v }

func (s *SelectElementsContext) AllSelectElement() []ISelectElementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISelectElementContext)(nil)).Elem())
	var tst = make([]ISelectElementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISelectElementContext)
		}
	}

	return tst
}

func (s *SelectElementsContext) SelectElement(i int) ISelectElementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelectElementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISelectElementContext)
}

func (s *SelectElementsContext) STAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTAR, 0)
}

func (s *SelectElementsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *SelectElementsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *SelectElementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectElementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectElementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSelectElements(s)
	}
}

func (s *SelectElementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSelectElements(s)
	}
}

func (s *SelectElementsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSelectElements(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) SelectElements() (localctx ISelectElementsContext) {
	localctx = NewSelectElementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, MySqlParserRULE_selectElements)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(487)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case MySqlParserSTAR:
		{
			p.SetState(485)

			var _m = p.Match(MySqlParserSTAR)

			localctx.(*SelectElementsContext).star = _m
		}

	case MySqlParserCASE, MySqlParserCAST, MySqlParserCONVERT, MySqlParserCURRENT, MySqlParserCURRENT_USER, MySqlParserDATABASE, MySqlParserDIAGNOSTICS, MySqlParserEXISTS, MySqlParserFALSE, MySqlParserIF, MySqlParserINSERT, MySqlParserINTERVAL, MySqlParserLEFT, MySqlParserNOT, MySqlParserNULL_LITERAL, MySqlParserNUMBER, MySqlParserREPLACE, MySqlParserRIGHT, MySqlParserSTACKED, MySqlParserTRUE, MySqlParserVALUES, MySqlParserDATE, MySqlParserTIME, MySqlParserTIMESTAMP, MySqlParserDATETIME, MySqlParserYEAR, MySqlParserCHAR, MySqlParserBINARY, MySqlParserTEXT, MySqlParserENUM, MySqlParserSERIAL, MySqlParserJSON_VALID, MySqlParserJSON_SCHEMA_VALID, MySqlParserAVG, MySqlParserBIT_AND, MySqlParserBIT_OR, MySqlParserBIT_XOR, MySqlParserCOUNT, MySqlParserGROUP_CONCAT, MySqlParserMAX, MySqlParserMIN, MySqlParserSTD, MySqlParserSTDDEV, MySqlParserSTDDEV_POP, MySqlParserSTDDEV_SAMP, MySqlParserSUM, MySqlParserVAR_POP, MySqlParserVAR_SAMP, MySqlParserVARIANCE, MySqlParserCURRENT_DATE, MySqlParserCURRENT_TIME, MySqlParserCURRENT_TIMESTAMP, MySqlParserLOCALTIME, MySqlParserCURDATE, MySqlParserCURTIME, MySqlParserDATE_ADD, MySqlParserDATE_SUB, MySqlParserEXTRACT, MySqlParserLOCALTIMESTAMP, MySqlParserNOW, MySqlParserPOSITION, MySqlParserSUBSTR, MySqlParserSUBSTRING, MySqlParserSYSDATE, MySqlParserTRIM, MySqlParserUTC_DATE, MySqlParserUTC_TIME, MySqlParserUTC_TIMESTAMP, MySqlParserACCOUNT, MySqlParserACTION, MySqlParserAFTER, MySqlParserAGGREGATE, MySqlParserALGORITHM, MySqlParserANY, MySqlParserAT, MySqlParserAUTHORS, MySqlParserAUTOCOMMIT, MySqlParserAUTOEXTEND_SIZE, MySqlParserAUTO_INCREMENT, MySqlParserAVG_ROW_LENGTH, MySqlParserBEGIN, MySqlParserBINLOG, MySqlParserBIT, MySqlParserBLOCK, MySqlParserBOOL, MySqlParserBOOLEAN, MySqlParserBTREE, MySqlParserCACHE, MySqlParserCASCADED, MySqlParserCHAIN, MySqlParserCHANGED, MySqlParserCHANNEL, MySqlParserCHECKSUM, MySqlParserPAGE_CHECKSUM, MySqlParserCIPHER, MySqlParserCLASS_ORIGIN, MySqlParserCLIENT, MySqlParserCLOSE, MySqlParserCOALESCE, MySqlParserCODE, MySqlParserCOLUMNS, MySqlParserCOLUMN_FORMAT, MySqlParserCOLUMN_NAME, MySqlParserCOMMENT, MySqlParserCOMMIT, MySqlParserCOMPACT, MySqlParserCOMPLETION, MySqlParserCOMPRESSED, MySqlParserCOMPRESSION, MySqlParserCONCURRENT, MySqlParserCONNECTION, MySqlParserCONSISTENT, MySqlParserCONSTRAINT_CATALOG, MySqlParserCONSTRAINT_SCHEMA, MySqlParserCONSTRAINT_NAME, MySqlParserCONTAINS, MySqlParserCONTEXT, MySqlParserCONTRIBUTORS, MySqlParserCOPY, MySqlParserCPU, MySqlParserCURSOR_NAME, MySqlParserDATA, MySqlParserDATAFILE, MySqlParserDEALLOCATE, MySqlParserDEFAULT_AUTH, MySqlParserDEFINER, MySqlParserDELAY_KEY_WRITE, MySqlParserDES_KEY_FILE, MySqlParserDIRECTORY, MySqlParserDISABLE, MySqlParserDISCARD, MySqlParserDISK, MySqlParserDO, MySqlParserDUMPFILE, MySqlParserDUPLICATE, MySqlParserDYNAMIC, MySqlParserENABLE, MySqlParserENCRYPTION, MySqlParserEND, MySqlParserENDS, MySqlParserENGINE, MySqlParserENGINES, MySqlParserERROR, MySqlParserERRORS, MySqlParserESCAPE, MySqlParserEVEN, MySqlParserEVENT, MySqlParserEVENTS, MySqlParserEVERY, MySqlParserEXCHANGE, MySqlParserEXCLUSIVE, MySqlParserEXPIRE, MySqlParserEXPORT, MySqlParserEXTENDED, MySqlParserEXTENT_SIZE, MySqlParserFAST, MySqlParserFAULTS, MySqlParserFIELDS, MySqlParserFILE_BLOCK_SIZE, MySqlParserFILTER, MySqlParserFIRST, MySqlParserFIXED, MySqlParserFLUSH, MySqlParserFOLLOWS, MySqlParserFOUND, MySqlParserFULL, MySqlParserFUNCTION, MySqlParserGENERAL, MySqlParserGLOBAL, MySqlParserGRANTS, MySqlParserGROUP_REPLICATION, MySqlParserHANDLER, MySqlParserHASH, MySqlParserHELP, MySqlParserHOST, MySqlParserHOSTS, MySqlParserIDENTIFIED, MySqlParserIGNORE_SERVER_IDS, MySqlParserIMPORT, MySqlParserINDEXES, MySqlParserINITIAL_SIZE, MySqlParserINPLACE, MySqlParserINSERT_METHOD, MySqlParserINSTALL, MySqlParserINSTANCE, MySqlParserINVISIBLE, MySqlParserINVOKER, MySqlParserIO, MySqlParserIO_THREAD, MySqlParserIPC, MySqlParserISOLATION, MySqlParserISSUER, MySqlParserJSON, MySqlParserKEY_BLOCK_SIZE, MySqlParserLANGUAGE, MySqlParserLAST, MySqlParserLEAVES, MySqlParserLESS, MySqlParserLEVEL, MySqlParserLIST, MySqlParserLOCAL, MySqlParserLOGFILE, MySqlParserLOGS, MySqlParserMASTER, MySqlParserMASTER_AUTO_POSITION, MySqlParserMASTER_CONNECT_RETRY, MySqlParserMASTER_DELAY, MySqlParserMASTER_HEARTBEAT_PERIOD, MySqlParserMASTER_HOST, MySqlParserMASTER_LOG_FILE, MySqlParserMASTER_LOG_POS, MySqlParserMASTER_PASSWORD, MySqlParserMASTER_PORT, MySqlParserMASTER_RETRY_COUNT, MySqlParserMASTER_SSL, MySqlParserMASTER_SSL_CA, MySqlParserMASTER_SSL_CAPATH, MySqlParserMASTER_SSL_CERT, MySqlParserMASTER_SSL_CIPHER, MySqlParserMASTER_SSL_CRL, MySqlParserMASTER_SSL_CRLPATH, MySqlParserMASTER_SSL_KEY, MySqlParserMASTER_TLS_VERSION, MySqlParserMASTER_USER, MySqlParserMAX_CONNECTIONS_PER_HOUR, MySqlParserMAX_QUERIES_PER_HOUR, MySqlParserMAX_ROWS, MySqlParserMAX_SIZE, MySqlParserMAX_UPDATES_PER_HOUR, MySqlParserMAX_USER_CONNECTIONS, MySqlParserMEDIUM, MySqlParserMEMBER, MySqlParserMERGE, MySqlParserMESSAGE_TEXT, MySqlParserMID, MySqlParserMIGRATE, MySqlParserMIN_ROWS, MySqlParserMODE, MySqlParserMODIFY, MySqlParserMUTEX, MySqlParserMYSQL, MySqlParserMYSQL_ERRNO, MySqlParserNAME, MySqlParserNAMES, MySqlParserNCHAR, MySqlParserNEVER, MySqlParserNEXT, MySqlParserNO, MySqlParserNODEGROUP, MySqlParserNONE, MySqlParserOFFLINE, MySqlParserOFFSET, MySqlParserOF, MySqlParserOJ, MySqlParserOLD_PASSWORD, MySqlParserONE, MySqlParserONLINE, MySqlParserONLY, MySqlParserOPEN, MySqlParserOPTIMIZER_COSTS, MySqlParserOPTIONS, MySqlParserOWNER, MySqlParserPACK_KEYS, MySqlParserPAGE, MySqlParserPARSER, MySqlParserPARTIAL, MySqlParserPARTITIONING, MySqlParserPARTITIONS, MySqlParserPASSWORD, MySqlParserPHASE, MySqlParserPLUGIN, MySqlParserPLUGIN_DIR, MySqlParserPLUGINS, MySqlParserPORT, MySqlParserPRECEDES, MySqlParserPREPARE, MySqlParserPRESERVE, MySqlParserPREV, MySqlParserPROCESSLIST, MySqlParserPROFILE, MySqlParserPROFILES, MySqlParserPROXY, MySqlParserQUERY, MySqlParserQUICK, MySqlParserREBUILD, MySqlParserRECOVER, MySqlParserREDO_BUFFER_SIZE, MySqlParserREDUNDANT, MySqlParserRELAY, MySqlParserRELAY_LOG_FILE, MySqlParserRELAY_LOG_POS, MySqlParserRELAYLOG, MySqlParserREMOVE, MySqlParserREORGANIZE, MySqlParserREPAIR, MySqlParserREPLICATE_DO_DB, MySqlParserREPLICATE_DO_TABLE, MySqlParserREPLICATE_IGNORE_DB, MySqlParserREPLICATE_IGNORE_TABLE, MySqlParserREPLICATE_REWRITE_DB, MySqlParserREPLICATE_WILD_DO_TABLE, MySqlParserREPLICATE_WILD_IGNORE_TABLE, MySqlParserREPLICATION, MySqlParserRESET, MySqlParserRESUME, MySqlParserRETURNED_SQLSTATE, MySqlParserRETURNS, MySqlParserROLE, MySqlParserROLLBACK, MySqlParserROLLUP, MySqlParserROTATE, MySqlParserROW, MySqlParserROWS, MySqlParserROW_FORMAT, MySqlParserSAVEPOINT, MySqlParserSCHEDULE, MySqlParserSECURITY, MySqlParserSERVER, MySqlParserSESSION, MySqlParserSHARE, MySqlParserSHARED, MySqlParserSIGNED, MySqlParserSIMPLE, MySqlParserSLAVE, MySqlParserSLOW, MySqlParserSNAPSHOT, MySqlParserSOCKET, MySqlParserSOME, MySqlParserSONAME, MySqlParserSOUNDS, MySqlParserSOURCE, MySqlParserSQL_AFTER_GTIDS, MySqlParserSQL_AFTER_MTS_GAPS, MySqlParserSQL_BEFORE_GTIDS, MySqlParserSQL_BUFFER_RESULT, MySqlParserSQL_CACHE, MySqlParserSQL_NO_CACHE, MySqlParserSQL_THREAD, MySqlParserSTART, MySqlParserSTARTS, MySqlParserSTATS_AUTO_RECALC, MySqlParserSTATS_PERSISTENT, MySqlParserSTATS_SAMPLE_PAGES, MySqlParserSTATUS, MySqlParserSTOP, MySqlParserSTORAGE, MySqlParserSTRING, MySqlParserSUBCLASS_ORIGIN, MySqlParserSUBJECT, MySqlParserSUBPARTITION, MySqlParserSUBPARTITIONS, MySqlParserSUSPEND, MySqlParserSWAPS, MySqlParserSWITCHES, MySqlParserTABLE_NAME, MySqlParserTABLESPACE, MySqlParserTEMPORARY, MySqlParserTEMPTABLE, MySqlParserTHAN, MySqlParserTRADITIONAL, MySqlParserTRANSACTION, MySqlParserTRANSACTIONAL, MySqlParserTRIGGERS, MySqlParserTRUNCATE, MySqlParserUNDEFINED, MySqlParserUNDOFILE, MySqlParserUNDO_BUFFER_SIZE, MySqlParserUNINSTALL, MySqlParserUNKNOWN, MySqlParserUNTIL, MySqlParserUPGRADE, MySqlParserUSER, MySqlParserUSE_FRM, MySqlParserUSER_RESOURCES, MySqlParserVALIDATION, MySqlParserVALUE, MySqlParserVARIABLES, MySqlParserVIEW, MySqlParserVISIBLE, MySqlParserWAIT, MySqlParserWARNINGS, MySqlParserWITHOUT, MySqlParserWORK, MySqlParserWRAPPER, MySqlParserX509, MySqlParserXA, MySqlParserXML, MySqlParserINTERNAL, MySqlParserQUARTER, MySqlParserMONTH, MySqlParserDAY, MySqlParserHOUR, MySqlParserMINUTE, MySqlParserWEEK, MySqlParserSECOND, MySqlParserMICROSECOND, MySqlParserTABLES, MySqlParserROUTINE, MySqlParserEXECUTE, MySqlParserFILE, MySqlParserPROCESS, MySqlParserRELOAD, MySqlParserSHUTDOWN, MySqlParserSUPER, MySqlParserPRIVILEGES, MySqlParserAUDIT_ADMIN, MySqlParserBACKUP_ADMIN, MySqlParserBINLOG_ADMIN, MySqlParserBINLOG_ENCRYPTION_ADMIN, MySqlParserCLONE_ADMIN, MySqlParserCONNECTION_ADMIN, MySqlParserENCRYPTION_KEY_ADMIN, MySqlParserFIREWALL_ADMIN, MySqlParserFIREWALL_USER, MySqlParserGROUP_REPLICATION_ADMIN, MySqlParserINNODB_REDO_LOG_ARCHIVE, MySqlParserNDB_STORED_USER, MySqlParserPERSIST_RO_VARIABLES_ADMIN, MySqlParserREPLICATION_APPLIER, MySqlParserREPLICATION_SLAVE_ADMIN, MySqlParserRESOURCE_GROUP_ADMIN, MySqlParserRESOURCE_GROUP_USER, MySqlParserROLE_ADMIN, MySqlParserSESSION_VARIABLES_ADMIN, MySqlParserSET_USER_ID, MySqlParserSHOW_ROUTINE, MySqlParserSYSTEM_VARIABLES_ADMIN, MySqlParserTABLE_ENCRYPTION_ADMIN, MySqlParserVERSION_TOKEN_ADMIN, MySqlParserXA_RECOVER_ADMIN, MySqlParserARMSCII8, MySqlParserASCII, MySqlParserBIG5, MySqlParserCP1250, MySqlParserCP1251, MySqlParserCP1256, MySqlParserCP1257, MySqlParserCP850, MySqlParserCP852, MySqlParserCP866, MySqlParserCP932, MySqlParserDEC8, MySqlParserEUCJPMS, MySqlParserEUCKR, MySqlParserGB2312, MySqlParserGBK, MySqlParserGEOSTD8, MySqlParserGREEK, MySqlParserHEBREW, MySqlParserHP8, MySqlParserKEYBCS2, MySqlParserKOI8R, MySqlParserKOI8U, MySqlParserLATIN1, MySqlParserLATIN2, MySqlParserLATIN5, MySqlParserLATIN7, MySqlParserMACCE, MySqlParserMACROMAN, MySqlParserSJIS, MySqlParserSWE7, MySqlParserTIS620, MySqlParserUCS2, MySqlParserUJIS, MySqlParserUTF16, MySqlParserUTF16LE, MySqlParserUTF32, MySqlParserUTF8, MySqlParserUTF8MB3, MySqlParserUTF8MB4, MySqlParserARCHIVE, MySqlParserBLACKHOLE, MySqlParserCSV, MySqlParserFEDERATED, MySqlParserINNODB, MySqlParserMEMORY, MySqlParserMRG_MYISAM, MySqlParserMYISAM, MySqlParserNDB, MySqlParserNDBCLUSTER, MySqlParserPERFORMANCE_SCHEMA, MySqlParserTOKUDB, MySqlParserREPEATABLE, MySqlParserCOMMITTED, MySqlParserUNCOMMITTED, MySqlParserSERIALIZABLE, MySqlParserGEOMETRYCOLLECTION, MySqlParserLINESTRING, MySqlParserMULTILINESTRING, MySqlParserMULTIPOINT, MySqlParserMULTIPOLYGON, MySqlParserPOINT, MySqlParserPOLYGON, MySqlParserABS, MySqlParserACOS, MySqlParserADDDATE, MySqlParserADDTIME, MySqlParserAES_DECRYPT, MySqlParserAES_ENCRYPT, MySqlParserAREA, MySqlParserASBINARY, MySqlParserASIN, MySqlParserASTEXT, MySqlParserASWKB, MySqlParserASWKT, MySqlParserASYMMETRIC_DECRYPT, MySqlParserASYMMETRIC_DERIVE, MySqlParserASYMMETRIC_ENCRYPT, MySqlParserASYMMETRIC_SIGN, MySqlParserASYMMETRIC_VERIFY, MySqlParserATAN, MySqlParserATAN2, MySqlParserBENCHMARK, MySqlParserBIN, MySqlParserBIT_COUNT, MySqlParserBIT_LENGTH, MySqlParserBUFFER, MySqlParserCATALOG_NAME, MySqlParserCEIL, MySqlParserCEILING, MySqlParserCENTROID, MySqlParserCHARACTER_LENGTH, MySqlParserCHARSET, MySqlParserCHAR_LENGTH, MySqlParserCOERCIBILITY, MySqlParserCOLLATION, MySqlParserCOMPRESS, MySqlParserCONCAT, MySqlParserCONCAT_WS, MySqlParserCONNECTION_ID, MySqlParserCONV, MySqlParserCONVERT_TZ, MySqlParserCOS, MySqlParserCOT, MySqlParserCRC32, MySqlParserCREATE_ASYMMETRIC_PRIV_KEY, MySqlParserCREATE_ASYMMETRIC_PUB_KEY, MySqlParserCREATE_DH_PARAMETERS, MySqlParserCREATE_DIGEST, MySqlParserCROSSES, MySqlParserDATEDIFF, MySqlParserDATE_FORMAT, MySqlParserDAYNAME, MySqlParserDAYOFMONTH, MySqlParserDAYOFWEEK, MySqlParserDAYOFYEAR, MySqlParserDECODE, MySqlParserDEGREES, MySqlParserDES_DECRYPT, MySqlParserDES_ENCRYPT, MySqlParserDIMENSION, MySqlParserDISJOINT, MySqlParserELT, MySqlParserENCODE, MySqlParserENCRYPT, MySqlParserENDPOINT, MySqlParserENVELOPE, MySqlParserEQUALS, MySqlParserEXP, MySqlParserEXPORT_SET, MySqlParserEXTERIORRING, MySqlParserEXTRACTVALUE, MySqlParserFIELD, MySqlParserFIND_IN_SET, MySqlParserFLOOR, MySqlParserFORMAT, MySqlParserFOUND_ROWS, MySqlParserFROM_BASE64, MySqlParserFROM_DAYS, MySqlParserFROM_UNIXTIME, MySqlParserGEOMCOLLFROMTEXT, MySqlParserGEOMCOLLFROMWKB, MySqlParserGEOMETRYCOLLECTIONFROMTEXT, MySqlParserGEOMETRYCOLLECTIONFROMWKB, MySqlParserGEOMETRYFROMTEXT, MySqlParserGEOMETRYFROMWKB, MySqlParserGEOMETRYN, MySqlParserGEOMETRYTYPE, MySqlParserGEOMFROMTEXT, MySqlParserGEOMFROMWKB, MySqlParserGET_FORMAT, MySqlParserGET_LOCK, MySqlParserGLENGTH, MySqlParserGREATEST, MySqlParserGTID_SUBSET, MySqlParserGTID_SUBTRACT, MySqlParserHEX, MySqlParserIFNULL, MySqlParserINET6_ATON, MySqlParserINET6_NTOA, MySqlParserINET_ATON, MySqlParserINET_NTOA, MySqlParserINSTR, MySqlParserINTERIORRINGN, MySqlParserINTERSECTS, MySqlParserISCLOSED, MySqlParserISEMPTY, MySqlParserISNULL, MySqlParserISSIMPLE, MySqlParserIS_FREE_LOCK, MySqlParserIS_IPV4, MySqlParserIS_IPV4_COMPAT, MySqlParserIS_IPV4_MAPPED, MySqlParserIS_IPV6, MySqlParserIS_USED_LOCK, MySqlParserLAST_INSERT_ID, MySqlParserLCASE, MySqlParserLEAST, MySqlParserLENGTH, MySqlParserLINEFROMTEXT, MySqlParserLINEFROMWKB, MySqlParserLINESTRINGFROMTEXT, MySqlParserLINESTRINGFROMWKB, MySqlParserLN, MySqlParserLOAD_FILE, MySqlParserLOCATE, MySqlParserLOG, MySqlParserLOG10, MySqlParserLOG2, MySqlParserLOWER, MySqlParserLPAD, MySqlParserLTRIM, MySqlParserMAKEDATE, MySqlParserMAKETIME, MySqlParserMAKE_SET, MySqlParserMASTER_POS_WAIT, MySqlParserMBRCONTAINS, MySqlParserMBRDISJOINT, MySqlParserMBREQUAL, MySqlParserMBRINTERSECTS, MySqlParserMBROVERLAPS, MySqlParserMBRTOUCHES, MySqlParserMBRWITHIN, MySqlParserMD5, MySqlParserMLINEFROMTEXT, MySqlParserMLINEFROMWKB, MySqlParserMONTHNAME, MySqlParserMPOINTFROMTEXT, MySqlParserMPOINTFROMWKB, MySqlParserMPOLYFROMTEXT, MySqlParserMPOLYFROMWKB, MySqlParserMULTILINESTRINGFROMTEXT, MySqlParserMULTILINESTRINGFROMWKB, MySqlParserMULTIPOINTFROMTEXT, MySqlParserMULTIPOINTFROMWKB, MySqlParserMULTIPOLYGONFROMTEXT, MySqlParserMULTIPOLYGONFROMWKB, MySqlParserNAME_CONST, MySqlParserNULLIF, MySqlParserNUMGEOMETRIES, MySqlParserNUMINTERIORRINGS, MySqlParserNUMPOINTS, MySqlParserOCT, MySqlParserOCTET_LENGTH, MySqlParserORD, MySqlParserOVERLAPS, MySqlParserPERIOD_ADD, MySqlParserPERIOD_DIFF, MySqlParserPI, MySqlParserPOINTFROMTEXT, MySqlParserPOINTFROMWKB, MySqlParserPOINTN, MySqlParserPOLYFROMTEXT, MySqlParserPOLYFROMWKB, MySqlParserPOLYGONFROMTEXT, MySqlParserPOLYGONFROMWKB, MySqlParserPOW, MySqlParserPOWER, MySqlParserQUOTE, MySqlParserRADIANS, MySqlParserRAND, MySqlParserRANDOM_BYTES, MySqlParserRELEASE_LOCK, MySqlParserREVERSE, MySqlParserROUND, MySqlParserROW_COUNT, MySqlParserRPAD, MySqlParserRTRIM, MySqlParserSEC_TO_TIME, MySqlParserSESSION_USER, MySqlParserSHA, MySqlParserSHA1, MySqlParserSHA2, MySqlParserSCHEMA_NAME, MySqlParserSIGN, MySqlParserSIN, MySqlParserSLEEP, MySqlParserSOUNDEX, MySqlParserSQL_THREAD_WAIT_AFTER_GTIDS, MySqlParserSQRT, MySqlParserSRID, MySqlParserSTARTPOINT, MySqlParserSTRCMP, MySqlParserSTR_TO_DATE, MySqlParserST_AREA, MySqlParserST_ASBINARY, MySqlParserST_ASTEXT, MySqlParserST_ASWKB, MySqlParserST_ASWKT, MySqlParserST_BUFFER, MySqlParserST_CENTROID, MySqlParserST_CONTAINS, MySqlParserST_CROSSES, MySqlParserST_DIFFERENCE, MySqlParserST_DIMENSION, MySqlParserST_DISJOINT, MySqlParserST_DISTANCE, MySqlParserST_ENDPOINT, MySqlParserST_ENVELOPE, MySqlParserST_EQUALS, MySqlParserST_EXTERIORRING, MySqlParserST_GEOMCOLLFROMTEXT, MySqlParserST_GEOMCOLLFROMTXT, MySqlParserST_GEOMCOLLFROMWKB, MySqlParserST_GEOMETRYCOLLECTIONFROMTEXT, MySqlParserST_GEOMETRYCOLLECTIONFROMWKB, MySqlParserST_GEOMETRYFROMTEXT, MySqlParserST_GEOMETRYFROMWKB, MySqlParserST_GEOMETRYN, MySqlParserST_GEOMETRYTYPE, MySqlParserST_GEOMFROMTEXT, MySqlParserST_GEOMFROMWKB, MySqlParserST_INTERIORRINGN, MySqlParserST_INTERSECTION, MySqlParserST_INTERSECTS, MySqlParserST_ISCLOSED, MySqlParserST_ISEMPTY, MySqlParserST_ISSIMPLE, MySqlParserST_LINEFROMTEXT, MySqlParserST_LINEFROMWKB, MySqlParserST_LINESTRINGFROMTEXT, MySqlParserST_LINESTRINGFROMWKB, MySqlParserST_NUMGEOMETRIES, MySqlParserST_NUMINTERIORRING, MySqlParserST_NUMINTERIORRINGS, MySqlParserST_NUMPOINTS, MySqlParserST_OVERLAPS, MySqlParserST_POINTFROMTEXT, MySqlParserST_POINTFROMWKB, MySqlParserST_POINTN, MySqlParserST_POLYFROMTEXT, MySqlParserST_POLYFROMWKB, MySqlParserST_POLYGONFROMTEXT, MySqlParserST_POLYGONFROMWKB, MySqlParserST_SRID, MySqlParserST_STARTPOINT, MySqlParserST_SYMDIFFERENCE, MySqlParserST_TOUCHES, MySqlParserST_UNION, MySqlParserST_WITHIN, MySqlParserST_X, MySqlParserST_Y, MySqlParserSUBDATE, MySqlParserSUBSTRING_INDEX, MySqlParserSUBTIME, MySqlParserSYSTEM_USER, MySqlParserTAN, MySqlParserTIMEDIFF, MySqlParserTIMESTAMPADD, MySqlParserTIMESTAMPDIFF, MySqlParserTIME_FORMAT, MySqlParserTIME_TO_SEC, MySqlParserTOUCHES, MySqlParserTO_BASE64, MySqlParserTO_DAYS, MySqlParserTO_SECONDS, MySqlParserUCASE, MySqlParserUNCOMPRESS, MySqlParserUNCOMPRESSED_LENGTH, MySqlParserUNHEX, MySqlParserUNIX_TIMESTAMP, MySqlParserUPDATEXML, MySqlParserUPPER, MySqlParserUUID, MySqlParserUUID_SHORT, MySqlParserVALIDATE_PASSWORD_STRENGTH, MySqlParserVERSION, MySqlParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS, MySqlParserWEEKDAY, MySqlParserWEEKOFYEAR, MySqlParserWEIGHT_STRING, MySqlParserWITHIN, MySqlParserYEARWEEK, MySqlParserY_FUNCTION, MySqlParserX_FUNCTION, MySqlParserPLUS, MySqlParserMINUS, MySqlParserEXCLAMATION_SYMBOL, MySqlParserBIT_NOT_OP, MySqlParserLR_BRACKET, MySqlParserZERO_DECIMAL, MySqlParserONE_DECIMAL, MySqlParserTWO_DECIMAL, MySqlParserCHARSET_REVERSE_QOUTE_STRING, MySqlParserSTART_NATIONAL_STRING_LITERAL, MySqlParserSTRING_LITERAL, MySqlParserDECIMAL_LITERAL, MySqlParserHEXADECIMAL_LITERAL, MySqlParserREAL_LITERAL, MySqlParserNULL_SPEC_LITERAL, MySqlParserBIT_STRING, MySqlParserSTRING_CHARSET_NAME, MySqlParserID, MySqlParserREVERSE_QUOTE_ID, MySqlParserLOCAL_ID, MySqlParserGLOBAL_ID:
		{
			p.SetState(486)
			p.SelectElement()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(493)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == MySqlParserCOMMA {
		{
			p.SetState(489)
			p.Match(MySqlParserCOMMA)
		}
		{
			p.SetState(490)
			p.SelectElement()
		}

		p.SetState(495)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ISelectElementContext is an interface to support dynamic dispatch.
type ISelectElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSelectElementContext differentiates from other interfaces.
	IsSelectElementContext()
}

type SelectElementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectElementContext() *SelectElementContext {
	var p = new(SelectElementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_selectElement
	return p
}

func (*SelectElementContext) IsSelectElementContext() {}

func NewSelectElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectElementContext {
	var p = new(SelectElementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_selectElement

	return p
}

func (s *SelectElementContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectElementContext) CopyFrom(ctx *SelectElementContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *SelectElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SelectExpressionElementContext struct {
	*SelectElementContext
}

func NewSelectExpressionElementContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SelectExpressionElementContext {
	var p = new(SelectExpressionElementContext)

	p.SelectElementContext = NewEmptySelectElementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SelectElementContext))

	return p
}

func (s *SelectExpressionElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectExpressionElementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SelectExpressionElementContext) LOCAL_ID() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCAL_ID, 0)
}

func (s *SelectExpressionElementContext) VAR_ASSIGN() antlr.TerminalNode {
	return s.GetToken(MySqlParserVAR_ASSIGN, 0)
}

func (s *SelectExpressionElementContext) Uid() IUidContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUidContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *SelectExpressionElementContext) AS() antlr.TerminalNode {
	return s.GetToken(MySqlParserAS, 0)
}

func (s *SelectExpressionElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSelectExpressionElement(s)
	}
}

func (s *SelectExpressionElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSelectExpressionElement(s)
	}
}

func (s *SelectExpressionElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSelectExpressionElement(s)

	default:
		return t.VisitChildren(s)
	}
}

type SelectFunctionElementContext struct {
	*SelectElementContext
}

func NewSelectFunctionElementContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SelectFunctionElementContext {
	var p = new(SelectFunctionElementContext)

	p.SelectElementContext = NewEmptySelectElementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SelectElementContext))

	return p
}

func (s *SelectFunctionElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectFunctionElementContext) FunctionCall() IFunctionCallContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionCallContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionCallContext)
}

func (s *SelectFunctionElementContext) Uid() IUidContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUidContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *SelectFunctionElementContext) AS() antlr.TerminalNode {
	return s.GetToken(MySqlParserAS, 0)
}

func (s *SelectFunctionElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSelectFunctionElement(s)
	}
}

func (s *SelectFunctionElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSelectFunctionElement(s)
	}
}

func (s *SelectFunctionElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSelectFunctionElement(s)

	default:
		return t.VisitChildren(s)
	}
}

type SelectStarElementContext struct {
	*SelectElementContext
}

func NewSelectStarElementContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SelectStarElementContext {
	var p = new(SelectStarElementContext)

	p.SelectElementContext = NewEmptySelectElementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SelectElementContext))

	return p
}

func (s *SelectStarElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectStarElementContext) FullId() IFullIdContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFullIdContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFullIdContext)
}

func (s *SelectStarElementContext) DOT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDOT, 0)
}

func (s *SelectStarElementContext) STAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTAR, 0)
}

func (s *SelectStarElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSelectStarElement(s)
	}
}

func (s *SelectStarElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSelectStarElement(s)
	}
}

func (s *SelectStarElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSelectStarElement(s)

	default:
		return t.VisitChildren(s)
	}
}

type SelectColumnElementContext struct {
	*SelectElementContext
}

func NewSelectColumnElementContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SelectColumnElementContext {
	var p = new(SelectColumnElementContext)

	p.SelectElementContext = NewEmptySelectElementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SelectElementContext))

	return p
}

func (s *SelectColumnElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectColumnElementContext) FullColumnName() IFullColumnNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFullColumnNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFullColumnNameContext)
}

func (s *SelectColumnElementContext) Uid() IUidContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUidContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *SelectColumnElementContext) AS() antlr.TerminalNode {
	return s.GetToken(MySqlParserAS, 0)
}

func (s *SelectColumnElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSelectColumnElement(s)
	}
}

func (s *SelectColumnElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSelectColumnElement(s)
	}
}

func (s *SelectColumnElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSelectColumnElement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) SelectElement() (localctx ISelectElementContext) {
	localctx = NewSelectElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, MySqlParserRULE_selectElement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(525)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 72, p.GetParserRuleContext()) {
	case 1:
		localctx = NewSelectStarElementContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(496)
			p.FullId()
		}
		{
			p.SetState(497)
			p.Match(MySqlParserDOT)
		}
		{
			p.SetState(498)
			p.Match(MySqlParserSTAR)
		}

	case 2:
		localctx = NewSelectColumnElementContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(500)
			p.FullColumnName()
		}
		p.SetState(505)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 66, p.GetParserRuleContext()) == 1 {
			p.SetState(502)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == MySqlParserAS {
				{
					p.SetState(501)
					p.Match(MySqlParserAS)
				}

			}
			{
				p.SetState(504)
				p.Uid()
			}

		}

	case 3:
		localctx = NewSelectFunctionElementContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(507)
			p.FunctionCall()
		}
		p.SetState(512)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 68, p.GetParserRuleContext()) == 1 {
			p.SetState(509)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == MySqlParserAS {
				{
					p.SetState(508)
					p.Match(MySqlParserAS)
				}

			}
			{
				p.SetState(511)
				p.Uid()
			}

		}

	case 4:
		localctx = NewSelectExpressionElementContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		p.SetState(516)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 69, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(514)
				p.Match(MySqlParserLOCAL_ID)
			}
			{
				p.SetState(515)
				p.Match(MySqlParserVAR_ASSIGN)
			}

		}
		{
			p.SetState(518)
			p.expression(0)
		}
		p.SetState(523)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 71, p.GetParserRuleContext()) == 1 {
			p.SetState(520)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == MySqlParserAS {
				{
					p.SetState(519)
					p.Match(MySqlParserAS)
				}

			}
			{
				p.SetState(522)
				p.Uid()
			}

		}

	}

	return localctx
}

// ISelectIntoExpressionContext is an interface to support dynamic dispatch.
type ISelectIntoExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSelectIntoExpressionContext differentiates from other interfaces.
	IsSelectIntoExpressionContext()
}

type SelectIntoExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectIntoExpressionContext() *SelectIntoExpressionContext {
	var p = new(SelectIntoExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_selectIntoExpression
	return p
}

func (*SelectIntoExpressionContext) IsSelectIntoExpressionContext() {}

func NewSelectIntoExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectIntoExpressionContext {
	var p = new(SelectIntoExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_selectIntoExpression

	return p
}

func (s *SelectIntoExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectIntoExpressionContext) CopyFrom(ctx *SelectIntoExpressionContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *SelectIntoExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectIntoExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SelectIntoVariablesContext struct {
	*SelectIntoExpressionContext
}

func NewSelectIntoVariablesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SelectIntoVariablesContext {
	var p = new(SelectIntoVariablesContext)

	p.SelectIntoExpressionContext = NewEmptySelectIntoExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SelectIntoExpressionContext))

	return p
}

func (s *SelectIntoVariablesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectIntoVariablesContext) INTO() antlr.TerminalNode {
	return s.GetToken(MySqlParserINTO, 0)
}

func (s *SelectIntoVariablesContext) AllAssignmentField() []IAssignmentFieldContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAssignmentFieldContext)(nil)).Elem())
	var tst = make([]IAssignmentFieldContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAssignmentFieldContext)
		}
	}

	return tst
}

func (s *SelectIntoVariablesContext) AssignmentField(i int) IAssignmentFieldContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignmentFieldContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAssignmentFieldContext)
}

func (s *SelectIntoVariablesContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *SelectIntoVariablesContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *SelectIntoVariablesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSelectIntoVariables(s)
	}
}

func (s *SelectIntoVariablesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSelectIntoVariables(s)
	}
}

func (s *SelectIntoVariablesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSelectIntoVariables(s)

	default:
		return t.VisitChildren(s)
	}
}

type SelectIntoTextFileContext struct {
	*SelectIntoExpressionContext
	filename     antlr.Token
	charset      ICharsetNameContext
	fieldsFormat antlr.Token
}

func NewSelectIntoTextFileContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SelectIntoTextFileContext {
	var p = new(SelectIntoTextFileContext)

	p.SelectIntoExpressionContext = NewEmptySelectIntoExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SelectIntoExpressionContext))

	return p
}

func (s *SelectIntoTextFileContext) GetFilename() antlr.Token { return s.filename }

func (s *SelectIntoTextFileContext) GetFieldsFormat() antlr.Token { return s.fieldsFormat }

func (s *SelectIntoTextFileContext) SetFilename(v antlr.Token) { s.filename = v }

func (s *SelectIntoTextFileContext) SetFieldsFormat(v antlr.Token) { s.fieldsFormat = v }

func (s *SelectIntoTextFileContext) GetCharset() ICharsetNameContext { return s.charset }

func (s *SelectIntoTextFileContext) SetCharset(v ICharsetNameContext) { s.charset = v }

func (s *SelectIntoTextFileContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectIntoTextFileContext) INTO() antlr.TerminalNode {
	return s.GetToken(MySqlParserINTO, 0)
}

func (s *SelectIntoTextFileContext) OUTFILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserOUTFILE, 0)
}

func (s *SelectIntoTextFileContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *SelectIntoTextFileContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHARACTER, 0)
}

func (s *SelectIntoTextFileContext) SET() antlr.TerminalNode {
	return s.GetToken(MySqlParserSET, 0)
}

func (s *SelectIntoTextFileContext) LINES() antlr.TerminalNode {
	return s.GetToken(MySqlParserLINES, 0)
}

func (s *SelectIntoTextFileContext) CharsetName() ICharsetNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICharsetNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICharsetNameContext)
}

func (s *SelectIntoTextFileContext) FIELDS() antlr.TerminalNode {
	return s.GetToken(MySqlParserFIELDS, 0)
}

func (s *SelectIntoTextFileContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLUMNS, 0)
}

func (s *SelectIntoTextFileContext) AllSelectFieldsInto() []ISelectFieldsIntoContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISelectFieldsIntoContext)(nil)).Elem())
	var tst = make([]ISelectFieldsIntoContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISelectFieldsIntoContext)
		}
	}

	return tst
}

func (s *SelectIntoTextFileContext) SelectFieldsInto(i int) ISelectFieldsIntoContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelectFieldsIntoContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISelectFieldsIntoContext)
}

func (s *SelectIntoTextFileContext) AllSelectLinesInto() []ISelectLinesIntoContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISelectLinesIntoContext)(nil)).Elem())
	var tst = make([]ISelectLinesIntoContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISelectLinesIntoContext)
		}
	}

	return tst
}

func (s *SelectIntoTextFileContext) SelectLinesInto(i int) ISelectLinesIntoContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelectLinesIntoContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISelectLinesIntoContext)
}

func (s *SelectIntoTextFileContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSelectIntoTextFile(s)
	}
}

func (s *SelectIntoTextFileContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSelectIntoTextFile(s)
	}
}

func (s *SelectIntoTextFileContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSelectIntoTextFile(s)

	default:
		return t.VisitChildren(s)
	}
}

type SelectIntoDumpFileContext struct {
	*SelectIntoExpressionContext
}

func NewSelectIntoDumpFileContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SelectIntoDumpFileContext {
	var p = new(SelectIntoDumpFileContext)

	p.SelectIntoExpressionContext = NewEmptySelectIntoExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SelectIntoExpressionContext))

	return p
}

func (s *SelectIntoDumpFileContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectIntoDumpFileContext) INTO() antlr.TerminalNode {
	return s.GetToken(MySqlParserINTO, 0)
}

func (s *SelectIntoDumpFileContext) DUMPFILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDUMPFILE, 0)
}

func (s *SelectIntoDumpFileContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *SelectIntoDumpFileContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSelectIntoDumpFile(s)
	}
}

func (s *SelectIntoDumpFileContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSelectIntoDumpFile(s)
	}
}

func (s *SelectIntoDumpFileContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSelectIntoDumpFile(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) SelectIntoExpression() (localctx ISelectIntoExpressionContext) {
	localctx = NewSelectIntoExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, MySqlParserRULE_selectIntoExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(563)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 79, p.GetParserRuleContext()) {
	case 1:
		localctx = NewSelectIntoVariablesContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(527)
			p.Match(MySqlParserINTO)
		}
		{
			p.SetState(528)
			p.AssignmentField()
		}
		p.SetState(533)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(529)
				p.Match(MySqlParserCOMMA)
			}
			{
				p.SetState(530)
				p.AssignmentField()
			}

			p.SetState(535)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		localctx = NewSelectIntoDumpFileContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(536)
			p.Match(MySqlParserINTO)
		}
		{
			p.SetState(537)
			p.Match(MySqlParserDUMPFILE)
		}
		{
			p.SetState(538)
			p.Match(MySqlParserSTRING_LITERAL)
		}

	case 3:
		localctx = NewSelectIntoTextFileContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(539)
			p.Match(MySqlParserINTO)
		}
		{
			p.SetState(540)
			p.Match(MySqlParserOUTFILE)
		}
		{
			p.SetState(541)

			var _m = p.Match(MySqlParserSTRING_LITERAL)

			localctx.(*SelectIntoTextFileContext).filename = _m
		}
		p.SetState(545)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserCHARACTER {
			{
				p.SetState(542)
				p.Match(MySqlParserCHARACTER)
			}
			{
				p.SetState(543)
				p.Match(MySqlParserSET)
			}
			{
				p.SetState(544)

				var _x = p.CharsetName()

				localctx.(*SelectIntoTextFileContext).charset = _x
			}

		}
		p.SetState(553)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 76, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(547)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*SelectIntoTextFileContext).fieldsFormat = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserCOLUMNS || _la == MySqlParserFIELDS) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*SelectIntoTextFileContext).fieldsFormat = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			p.SetState(549)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for ok := true; ok; ok = _la == MySqlParserENCLOSED || _la == MySqlParserESCAPED || _la == MySqlParserOPTIONALLY || _la == MySqlParserTERMINATED {
				{
					p.SetState(548)
					p.SelectFieldsInto()
				}

				p.SetState(551)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}
		p.SetState(561)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserLINES {
			{
				p.SetState(555)
				p.Match(MySqlParserLINES)
			}
			p.SetState(557)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for ok := true; ok; ok = _la == MySqlParserSTARTING || _la == MySqlParserTERMINATED {
				{
					p.SetState(556)
					p.SelectLinesInto()
				}

				p.SetState(559)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}

	}

	return localctx
}

// ISelectFieldsIntoContext is an interface to support dynamic dispatch.
type ISelectFieldsIntoContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTerminationField returns the terminationField token.
	GetTerminationField() antlr.Token

	// GetEnclosion returns the enclosion token.
	GetEnclosion() antlr.Token

	// GetEscaping returns the escaping token.
	GetEscaping() antlr.Token

	// SetTerminationField sets the terminationField token.
	SetTerminationField(antlr.Token)

	// SetEnclosion sets the enclosion token.
	SetEnclosion(antlr.Token)

	// SetEscaping sets the escaping token.
	SetEscaping(antlr.Token)

	// IsSelectFieldsIntoContext differentiates from other interfaces.
	IsSelectFieldsIntoContext()
}

type SelectFieldsIntoContext struct {
	*antlr.BaseParserRuleContext
	parser           antlr.Parser
	terminationField antlr.Token
	enclosion        antlr.Token
	escaping         antlr.Token
}

func NewEmptySelectFieldsIntoContext() *SelectFieldsIntoContext {
	var p = new(SelectFieldsIntoContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_selectFieldsInto
	return p
}

func (*SelectFieldsIntoContext) IsSelectFieldsIntoContext() {}

func NewSelectFieldsIntoContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectFieldsIntoContext {
	var p = new(SelectFieldsIntoContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_selectFieldsInto

	return p
}

func (s *SelectFieldsIntoContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectFieldsIntoContext) GetTerminationField() antlr.Token { return s.terminationField }

func (s *SelectFieldsIntoContext) GetEnclosion() antlr.Token { return s.enclosion }

func (s *SelectFieldsIntoContext) GetEscaping() antlr.Token { return s.escaping }

func (s *SelectFieldsIntoContext) SetTerminationField(v antlr.Token) { s.terminationField = v }

func (s *SelectFieldsIntoContext) SetEnclosion(v antlr.Token) { s.enclosion = v }

func (s *SelectFieldsIntoContext) SetEscaping(v antlr.Token) { s.escaping = v }

func (s *SelectFieldsIntoContext) TERMINATED() antlr.TerminalNode {
	return s.GetToken(MySqlParserTERMINATED, 0)
}

func (s *SelectFieldsIntoContext) BY() antlr.TerminalNode {
	return s.GetToken(MySqlParserBY, 0)
}

func (s *SelectFieldsIntoContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *SelectFieldsIntoContext) ENCLOSED() antlr.TerminalNode {
	return s.GetToken(MySqlParserENCLOSED, 0)
}

func (s *SelectFieldsIntoContext) OPTIONALLY() antlr.TerminalNode {
	return s.GetToken(MySqlParserOPTIONALLY, 0)
}

func (s *SelectFieldsIntoContext) ESCAPED() antlr.TerminalNode {
	return s.GetToken(MySqlParserESCAPED, 0)
}

func (s *SelectFieldsIntoContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectFieldsIntoContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectFieldsIntoContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSelectFieldsInto(s)
	}
}

func (s *SelectFieldsIntoContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSelectFieldsInto(s)
	}
}

func (s *SelectFieldsIntoContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSelectFieldsInto(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) SelectFieldsInto() (localctx ISelectFieldsIntoContext) {
	localctx = NewSelectFieldsIntoContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, MySqlParserRULE_selectFieldsInto)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(577)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case MySqlParserTERMINATED:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(565)
			p.Match(MySqlParserTERMINATED)
		}
		{
			p.SetState(566)
			p.Match(MySqlParserBY)
		}
		{
			p.SetState(567)

			var _m = p.Match(MySqlParserSTRING_LITERAL)

			localctx.(*SelectFieldsIntoContext).terminationField = _m
		}

	case MySqlParserENCLOSED, MySqlParserOPTIONALLY:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(569)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserOPTIONALLY {
			{
				p.SetState(568)
				p.Match(MySqlParserOPTIONALLY)
			}

		}
		{
			p.SetState(571)
			p.Match(MySqlParserENCLOSED)
		}
		{
			p.SetState(572)
			p.Match(MySqlParserBY)
		}
		{
			p.SetState(573)

			var _m = p.Match(MySqlParserSTRING_LITERAL)

			localctx.(*SelectFieldsIntoContext).enclosion = _m
		}

	case MySqlParserESCAPED:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(574)
			p.Match(MySqlParserESCAPED)
		}
		{
			p.SetState(575)
			p.Match(MySqlParserBY)
		}
		{
			p.SetState(576)

			var _m = p.Match(MySqlParserSTRING_LITERAL)

			localctx.(*SelectFieldsIntoContext).escaping = _m
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISelectLinesIntoContext is an interface to support dynamic dispatch.
type ISelectLinesIntoContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetStarting returns the starting token.
	GetStarting() antlr.Token

	// GetTerminationLine returns the terminationLine token.
	GetTerminationLine() antlr.Token

	// SetStarting sets the starting token.
	SetStarting(antlr.Token)

	// SetTerminationLine sets the terminationLine token.
	SetTerminationLine(antlr.Token)

	// IsSelectLinesIntoContext differentiates from other interfaces.
	IsSelectLinesIntoContext()
}

type SelectLinesIntoContext struct {
	*antlr.BaseParserRuleContext
	parser          antlr.Parser
	starting        antlr.Token
	terminationLine antlr.Token
}

func NewEmptySelectLinesIntoContext() *SelectLinesIntoContext {
	var p = new(SelectLinesIntoContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_selectLinesInto
	return p
}

func (*SelectLinesIntoContext) IsSelectLinesIntoContext() {}

func NewSelectLinesIntoContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectLinesIntoContext {
	var p = new(SelectLinesIntoContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_selectLinesInto

	return p
}

func (s *SelectLinesIntoContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectLinesIntoContext) GetStarting() antlr.Token { return s.starting }

func (s *SelectLinesIntoContext) GetTerminationLine() antlr.Token { return s.terminationLine }

func (s *SelectLinesIntoContext) SetStarting(v antlr.Token) { s.starting = v }

func (s *SelectLinesIntoContext) SetTerminationLine(v antlr.Token) { s.terminationLine = v }

func (s *SelectLinesIntoContext) STARTING() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTARTING, 0)
}

func (s *SelectLinesIntoContext) BY() antlr.TerminalNode {
	return s.GetToken(MySqlParserBY, 0)
}

func (s *SelectLinesIntoContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *SelectLinesIntoContext) TERMINATED() antlr.TerminalNode {
	return s.GetToken(MySqlParserTERMINATED, 0)
}

func (s *SelectLinesIntoContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectLinesIntoContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectLinesIntoContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSelectLinesInto(s)
	}
}

func (s *SelectLinesIntoContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSelectLinesInto(s)
	}
}

func (s *SelectLinesIntoContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSelectLinesInto(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) SelectLinesInto() (localctx ISelectLinesIntoContext) {
	localctx = NewSelectLinesIntoContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, MySqlParserRULE_selectLinesInto)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(585)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case MySqlParserSTARTING:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(579)
			p.Match(MySqlParserSTARTING)
		}
		{
			p.SetState(580)
			p.Match(MySqlParserBY)
		}
		{
			p.SetState(581)

			var _m = p.Match(MySqlParserSTRING_LITERAL)

			localctx.(*SelectLinesIntoContext).starting = _m
		}

	case MySqlParserTERMINATED:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(582)
			p.Match(MySqlParserTERMINATED)
		}
		{
			p.SetState(583)
			p.Match(MySqlParserBY)
		}
		{
			p.SetState(584)

			var _m = p.Match(MySqlParserSTRING_LITERAL)

			localctx.(*SelectLinesIntoContext).terminationLine = _m
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IFromClauseContext is an interface to support dynamic dispatch.
type IFromClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetWhereExpr returns the whereExpr rule contexts.
	GetWhereExpr() IExpressionContext

	// GetHavingExpr returns the havingExpr rule contexts.
	GetHavingExpr() IExpressionContext

	// SetWhereExpr sets the whereExpr rule contexts.
	SetWhereExpr(IExpressionContext)

	// SetHavingExpr sets the havingExpr rule contexts.
	SetHavingExpr(IExpressionContext)

	// IsFromClauseContext differentiates from other interfaces.
	IsFromClauseContext()
}

type FromClauseContext struct {
	*antlr.BaseParserRuleContext
	parser     antlr.Parser
	whereExpr  IExpressionContext
	havingExpr IExpressionContext
}

func NewEmptyFromClauseContext() *FromClauseContext {
	var p = new(FromClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_fromClause
	return p
}

func (*FromClauseContext) IsFromClauseContext() {}

func NewFromClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FromClauseContext {
	var p = new(FromClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_fromClause

	return p
}

func (s *FromClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *FromClauseContext) GetWhereExpr() IExpressionContext { return s.whereExpr }

func (s *FromClauseContext) GetHavingExpr() IExpressionContext { return s.havingExpr }

func (s *FromClauseContext) SetWhereExpr(v IExpressionContext) { s.whereExpr = v }

func (s *FromClauseContext) SetHavingExpr(v IExpressionContext) { s.havingExpr = v }

func (s *FromClauseContext) FROM() antlr.TerminalNode {
	return s.GetToken(MySqlParserFROM, 0)
}

func (s *FromClauseContext) TableSources() ITableSourcesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableSourcesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableSourcesContext)
}

func (s *FromClauseContext) WHERE() antlr.TerminalNode {
	return s.GetToken(MySqlParserWHERE, 0)
}

func (s *FromClauseContext) GROUP() antlr.TerminalNode {
	return s.GetToken(MySqlParserGROUP, 0)
}

func (s *FromClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(MySqlParserBY, 0)
}

func (s *FromClauseContext) AllGroupByItem() []IGroupByItemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IGroupByItemContext)(nil)).Elem())
	var tst = make([]IGroupByItemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IGroupByItemContext)
		}
	}

	return tst
}

func (s *FromClauseContext) GroupByItem(i int) IGroupByItemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGroupByItemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IGroupByItemContext)
}

func (s *FromClauseContext) HAVING() antlr.TerminalNode {
	return s.GetToken(MySqlParserHAVING, 0)
}

func (s *FromClauseContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *FromClauseContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *FromClauseContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *FromClauseContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *FromClauseContext) WITH() antlr.TerminalNode {
	return s.GetToken(MySqlParserWITH, 0)
}

func (s *FromClauseContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(MySqlParserROLLUP, 0)
}

func (s *FromClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FromClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FromClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterFromClause(s)
	}
}

func (s *FromClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitFromClause(s)
	}
}

func (s *FromClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitFromClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) FromClause() (localctx IFromClauseContext) {
	localctx = NewFromClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, MySqlParserRULE_fromClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(587)
		p.Match(MySqlParserFROM)
	}
	{
		p.SetState(588)
		p.TableSources()
	}
	p.SetState(591)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserWHERE {
		{
			p.SetState(589)
			p.Match(MySqlParserWHERE)
		}
		{
			p.SetState(590)

			var _x = p.expression(0)

			localctx.(*FromClauseContext).whereExpr = _x
		}

	}
	p.SetState(607)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserGROUP {
		{
			p.SetState(593)
			p.Match(MySqlParserGROUP)
		}
		{
			p.SetState(594)
			p.Match(MySqlParserBY)
		}
		{
			p.SetState(595)
			p.GroupByItem()
		}
		p.SetState(600)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(596)
				p.Match(MySqlParserCOMMA)
			}
			{
				p.SetState(597)
				p.GroupByItem()
			}

			p.SetState(602)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(605)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserWITH {
			{
				p.SetState(603)
				p.Match(MySqlParserWITH)
			}
			{
				p.SetState(604)
				p.Match(MySqlParserROLLUP)
			}

		}

	}
	p.SetState(611)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserHAVING {
		{
			p.SetState(609)
			p.Match(MySqlParserHAVING)
		}
		{
			p.SetState(610)

			var _x = p.expression(0)

			localctx.(*FromClauseContext).havingExpr = _x
		}

	}

	return localctx
}

// IGroupByItemContext is an interface to support dynamic dispatch.
type IGroupByItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOrder returns the order token.
	GetOrder() antlr.Token

	// SetOrder sets the order token.
	SetOrder(antlr.Token)

	// IsGroupByItemContext differentiates from other interfaces.
	IsGroupByItemContext()
}

type GroupByItemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	order  antlr.Token
}

func NewEmptyGroupByItemContext() *GroupByItemContext {
	var p = new(GroupByItemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_groupByItem
	return p
}

func (*GroupByItemContext) IsGroupByItemContext() {}

func NewGroupByItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupByItemContext {
	var p = new(GroupByItemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_groupByItem

	return p
}

func (s *GroupByItemContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupByItemContext) GetOrder() antlr.Token { return s.order }

func (s *GroupByItemContext) SetOrder(v antlr.Token) { s.order = v }

func (s *GroupByItemContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *GroupByItemContext) ASC() antlr.TerminalNode {
	return s.GetToken(MySqlParserASC, 0)
}

func (s *GroupByItemContext) DESC() antlr.TerminalNode {
	return s.GetToken(MySqlParserDESC, 0)
}

func (s *GroupByItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupByItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GroupByItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterGroupByItem(s)
	}
}

func (s *GroupByItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitGroupByItem(s)
	}
}

func (s *GroupByItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitGroupByItem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) GroupByItem() (localctx IGroupByItemContext) {
	localctx = NewGroupByItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, MySqlParserRULE_groupByItem)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(613)
		p.expression(0)
	}
	p.SetState(615)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserASC || _la == MySqlParserDESC {
		{
			p.SetState(614)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*GroupByItemContext).order = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserASC || _la == MySqlParserDESC) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*GroupByItemContext).order = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

	return localctx
}

// ILimitClauseContext is an interface to support dynamic dispatch.
type ILimitClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOffset returns the offset rule contexts.
	GetOffset() ILimitClauseAtomContext

	// GetLimit returns the limit rule contexts.
	GetLimit() ILimitClauseAtomContext

	// SetOffset sets the offset rule contexts.
	SetOffset(ILimitClauseAtomContext)

	// SetLimit sets the limit rule contexts.
	SetLimit(ILimitClauseAtomContext)

	// IsLimitClauseContext differentiates from other interfaces.
	IsLimitClauseContext()
}

type LimitClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	offset ILimitClauseAtomContext
	limit  ILimitClauseAtomContext
}

func NewEmptyLimitClauseContext() *LimitClauseContext {
	var p = new(LimitClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_limitClause
	return p
}

func (*LimitClauseContext) IsLimitClauseContext() {}

func NewLimitClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LimitClauseContext {
	var p = new(LimitClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_limitClause

	return p
}

func (s *LimitClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *LimitClauseContext) GetOffset() ILimitClauseAtomContext { return s.offset }

func (s *LimitClauseContext) GetLimit() ILimitClauseAtomContext { return s.limit }

func (s *LimitClauseContext) SetOffset(v ILimitClauseAtomContext) { s.offset = v }

func (s *LimitClauseContext) SetLimit(v ILimitClauseAtomContext) { s.limit = v }

func (s *LimitClauseContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(MySqlParserLIMIT, 0)
}

func (s *LimitClauseContext) OFFSET() antlr.TerminalNode {
	return s.GetToken(MySqlParserOFFSET, 0)
}

func (s *LimitClauseContext) AllLimitClauseAtom() []ILimitClauseAtomContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILimitClauseAtomContext)(nil)).Elem())
	var tst = make([]ILimitClauseAtomContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILimitClauseAtomContext)
		}
	}

	return tst
}

func (s *LimitClauseContext) LimitClauseAtom(i int) ILimitClauseAtomContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILimitClauseAtomContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILimitClauseAtomContext)
}

func (s *LimitClauseContext) COMMA() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, 0)
}

func (s *LimitClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LimitClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LimitClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterLimitClause(s)
	}
}

func (s *LimitClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitLimitClause(s)
	}
}

func (s *LimitClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitLimitClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) LimitClause() (localctx ILimitClauseContext) {
	localctx = NewLimitClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, MySqlParserRULE_limitClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(617)
		p.Match(MySqlParserLIMIT)
	}
	p.SetState(628)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 90, p.GetParserRuleContext()) {
	case 1:
		p.SetState(621)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 89, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(618)

				var _x = p.LimitClauseAtom()

				localctx.(*LimitClauseContext).offset = _x
			}
			{
				p.SetState(619)
				p.Match(MySqlParserCOMMA)
			}

		}
		{
			p.SetState(623)

			var _x = p.LimitClauseAtom()

			localctx.(*LimitClauseContext).limit = _x
		}

	case 2:
		{
			p.SetState(624)

			var _x = p.LimitClauseAtom()

			localctx.(*LimitClauseContext).limit = _x
		}
		{
			p.SetState(625)
			p.Match(MySqlParserOFFSET)
		}
		{
			p.SetState(626)

			var _x = p.LimitClauseAtom()

			localctx.(*LimitClauseContext).offset = _x
		}

	}

	return localctx
}

// ILimitClauseAtomContext is an interface to support dynamic dispatch.
type ILimitClauseAtomContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLimitClauseAtomContext differentiates from other interfaces.
	IsLimitClauseAtomContext()
}

type LimitClauseAtomContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLimitClauseAtomContext() *LimitClauseAtomContext {
	var p = new(LimitClauseAtomContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_limitClauseAtom
	return p
}

func (*LimitClauseAtomContext) IsLimitClauseAtomContext() {}

func NewLimitClauseAtomContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LimitClauseAtomContext {
	var p = new(LimitClauseAtomContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_limitClauseAtom

	return p
}

func (s *LimitClauseAtomContext) GetParser() antlr.Parser { return s.parser }

func (s *LimitClauseAtomContext) DecimalLiteral() IDecimalLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDecimalLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *LimitClauseAtomContext) MysqlVariable() IMysqlVariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMysqlVariableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMysqlVariableContext)
}

func (s *LimitClauseAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LimitClauseAtomContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LimitClauseAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterLimitClauseAtom(s)
	}
}

func (s *LimitClauseAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitLimitClauseAtom(s)
	}
}

func (s *LimitClauseAtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitLimitClauseAtom(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) LimitClauseAtom() (localctx ILimitClauseAtomContext) {
	localctx = NewLimitClauseAtomContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, MySqlParserRULE_limitClauseAtom)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(632)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case MySqlParserZERO_DECIMAL, MySqlParserONE_DECIMAL, MySqlParserTWO_DECIMAL, MySqlParserDECIMAL_LITERAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(630)
			p.DecimalLiteral()
		}

	case MySqlParserLOCAL_ID, MySqlParserGLOBAL_ID:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(631)
			p.MysqlVariable()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IFullIdContext is an interface to support dynamic dispatch.
type IFullIdContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFullIdContext differentiates from other interfaces.
	IsFullIdContext()
}

type FullIdContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFullIdContext() *FullIdContext {
	var p = new(FullIdContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_fullId
	return p
}

func (*FullIdContext) IsFullIdContext() {}

func NewFullIdContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FullIdContext {
	var p = new(FullIdContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_fullId

	return p
}

func (s *FullIdContext) GetParser() antlr.Parser { return s.parser }

func (s *FullIdContext) AllUid() []IUidContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IUidContext)(nil)).Elem())
	var tst = make([]IUidContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IUidContext)
		}
	}

	return tst
}

func (s *FullIdContext) Uid(i int) IUidContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUidContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *FullIdContext) DOT_ID() antlr.TerminalNode {
	return s.GetToken(MySqlParserDOT_ID, 0)
}

func (s *FullIdContext) DOT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDOT, 0)
}

func (s *FullIdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FullIdContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FullIdContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterFullId(s)
	}
}

func (s *FullIdContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitFullId(s)
	}
}

func (s *FullIdContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitFullId(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) FullId() (localctx IFullIdContext) {
	localctx = NewFullIdContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, MySqlParserRULE_fullId)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(634)
		p.Uid()
	}
	p.SetState(638)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 92, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(635)
			p.Match(MySqlParserDOT_ID)
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 92, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(636)
			p.Match(MySqlParserDOT)
		}
		{
			p.SetState(637)
			p.Uid()
		}

	}

	return localctx
}

// ITableNameContext is an interface to support dynamic dispatch.
type ITableNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTableNameContext differentiates from other interfaces.
	IsTableNameContext()
}

type TableNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableNameContext() *TableNameContext {
	var p = new(TableNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_tableName
	return p
}

func (*TableNameContext) IsTableNameContext() {}

func NewTableNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableNameContext {
	var p = new(TableNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_tableName

	return p
}

func (s *TableNameContext) GetParser() antlr.Parser { return s.parser }

func (s *TableNameContext) FullId() IFullIdContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFullIdContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFullIdContext)
}

func (s *TableNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTableName(s)
	}
}

func (s *TableNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTableName(s)
	}
}

func (s *TableNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTableName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) TableName() (localctx ITableNameContext) {
	localctx = NewTableNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, MySqlParserRULE_tableName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(640)
		p.FullId()
	}

	return localctx
}

// IFullColumnNameContext is an interface to support dynamic dispatch.
type IFullColumnNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFullColumnNameContext differentiates from other interfaces.
	IsFullColumnNameContext()
}

type FullColumnNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFullColumnNameContext() *FullColumnNameContext {
	var p = new(FullColumnNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_fullColumnName
	return p
}

func (*FullColumnNameContext) IsFullColumnNameContext() {}

func NewFullColumnNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FullColumnNameContext {
	var p = new(FullColumnNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_fullColumnName

	return p
}

func (s *FullColumnNameContext) GetParser() antlr.Parser { return s.parser }

func (s *FullColumnNameContext) Uid() IUidContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUidContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *FullColumnNameContext) AllDottedId() []IDottedIdContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDottedIdContext)(nil)).Elem())
	var tst = make([]IDottedIdContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDottedIdContext)
		}
	}

	return tst
}

func (s *FullColumnNameContext) DottedId(i int) IDottedIdContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDottedIdContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDottedIdContext)
}

func (s *FullColumnNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FullColumnNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FullColumnNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterFullColumnName(s)
	}
}

func (s *FullColumnNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitFullColumnName(s)
	}
}

func (s *FullColumnNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitFullColumnName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) FullColumnName() (localctx IFullColumnNameContext) {
	localctx = NewFullColumnNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, MySqlParserRULE_fullColumnName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(642)
		p.Uid()
	}
	p.SetState(647)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 94, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(643)
			p.DottedId()
		}
		p.SetState(645)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 93, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(644)
				p.DottedId()
			}

		}

	}

	return localctx
}

// IMysqlVariableContext is an interface to support dynamic dispatch.
type IMysqlVariableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMysqlVariableContext differentiates from other interfaces.
	IsMysqlVariableContext()
}

type MysqlVariableContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMysqlVariableContext() *MysqlVariableContext {
	var p = new(MysqlVariableContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_mysqlVariable
	return p
}

func (*MysqlVariableContext) IsMysqlVariableContext() {}

func NewMysqlVariableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MysqlVariableContext {
	var p = new(MysqlVariableContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_mysqlVariable

	return p
}

func (s *MysqlVariableContext) GetParser() antlr.Parser { return s.parser }

func (s *MysqlVariableContext) LOCAL_ID() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCAL_ID, 0)
}

func (s *MysqlVariableContext) GLOBAL_ID() antlr.TerminalNode {
	return s.GetToken(MySqlParserGLOBAL_ID, 0)
}

func (s *MysqlVariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MysqlVariableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MysqlVariableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterMysqlVariable(s)
	}
}

func (s *MysqlVariableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitMysqlVariable(s)
	}
}

func (s *MysqlVariableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitMysqlVariable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) MysqlVariable() (localctx IMysqlVariableContext) {
	localctx = NewMysqlVariableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, MySqlParserRULE_mysqlVariable)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(649)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserLOCAL_ID || _la == MySqlParserGLOBAL_ID) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ICharsetNameContext is an interface to support dynamic dispatch.
type ICharsetNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCharsetNameContext differentiates from other interfaces.
	IsCharsetNameContext()
}

type CharsetNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCharsetNameContext() *CharsetNameContext {
	var p = new(CharsetNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_charsetName
	return p
}

func (*CharsetNameContext) IsCharsetNameContext() {}

func NewCharsetNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CharsetNameContext {
	var p = new(CharsetNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_charsetName

	return p
}

func (s *CharsetNameContext) GetParser() antlr.Parser { return s.parser }

func (s *CharsetNameContext) BINARY() antlr.TerminalNode {
	return s.GetToken(MySqlParserBINARY, 0)
}

func (s *CharsetNameContext) CharsetNameBase() ICharsetNameBaseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICharsetNameBaseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICharsetNameBaseContext)
}

func (s *CharsetNameContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *CharsetNameContext) CHARSET_REVERSE_QOUTE_STRING() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHARSET_REVERSE_QOUTE_STRING, 0)
}

func (s *CharsetNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CharsetNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CharsetNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCharsetName(s)
	}
}

func (s *CharsetNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCharsetName(s)
	}
}

func (s *CharsetNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCharsetName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) CharsetName() (localctx ICharsetNameContext) {
	localctx = NewCharsetNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, MySqlParserRULE_charsetName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(655)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case MySqlParserBINARY:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(651)
			p.Match(MySqlParserBINARY)
		}

	case MySqlParserARMSCII8, MySqlParserASCII, MySqlParserBIG5, MySqlParserCP1250, MySqlParserCP1251, MySqlParserCP1256, MySqlParserCP1257, MySqlParserCP850, MySqlParserCP852, MySqlParserCP866, MySqlParserCP932, MySqlParserDEC8, MySqlParserEUCJPMS, MySqlParserEUCKR, MySqlParserGB2312, MySqlParserGBK, MySqlParserGEOSTD8, MySqlParserGREEK, MySqlParserHEBREW, MySqlParserHP8, MySqlParserKEYBCS2, MySqlParserKOI8R, MySqlParserKOI8U, MySqlParserLATIN1, MySqlParserLATIN2, MySqlParserLATIN5, MySqlParserLATIN7, MySqlParserMACCE, MySqlParserMACROMAN, MySqlParserSJIS, MySqlParserSWE7, MySqlParserTIS620, MySqlParserUCS2, MySqlParserUJIS, MySqlParserUTF16, MySqlParserUTF16LE, MySqlParserUTF32, MySqlParserUTF8, MySqlParserUTF8MB3, MySqlParserUTF8MB4:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(652)
			p.CharsetNameBase()
		}

	case MySqlParserSTRING_LITERAL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(653)
			p.Match(MySqlParserSTRING_LITERAL)
		}

	case MySqlParserCHARSET_REVERSE_QOUTE_STRING:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(654)
			p.Match(MySqlParserCHARSET_REVERSE_QOUTE_STRING)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IUidContext is an interface to support dynamic dispatch.
type IUidContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUidContext differentiates from other interfaces.
	IsUidContext()
}

type UidContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUidContext() *UidContext {
	var p = new(UidContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_uid
	return p
}

func (*UidContext) IsUidContext() {}

func NewUidContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UidContext {
	var p = new(UidContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_uid

	return p
}

func (s *UidContext) GetParser() antlr.Parser { return s.parser }

func (s *UidContext) SimpleId() ISimpleIdContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimpleIdContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimpleIdContext)
}

func (s *UidContext) REVERSE_QUOTE_ID() antlr.TerminalNode {
	return s.GetToken(MySqlParserREVERSE_QUOTE_ID, 0)
}

func (s *UidContext) CHARSET_REVERSE_QOUTE_STRING() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHARSET_REVERSE_QOUTE_STRING, 0)
}

func (s *UidContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UidContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UidContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterUid(s)
	}
}

func (s *UidContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitUid(s)
	}
}

func (s *UidContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitUid(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) Uid() (localctx IUidContext) {
	localctx = NewUidContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, MySqlParserRULE_uid)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(660)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 96, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(657)
			p.SimpleId()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(658)
			p.Match(MySqlParserREVERSE_QUOTE_ID)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(659)
			p.Match(MySqlParserCHARSET_REVERSE_QOUTE_STRING)
		}

	}

	return localctx
}

// IEngineNameContext is an interface to support dynamic dispatch.
type IEngineNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEngineNameContext differentiates from other interfaces.
	IsEngineNameContext()
}

type EngineNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEngineNameContext() *EngineNameContext {
	var p = new(EngineNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_engineName
	return p
}

func (*EngineNameContext) IsEngineNameContext() {}

func NewEngineNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EngineNameContext {
	var p = new(EngineNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_engineName

	return p
}

func (s *EngineNameContext) GetParser() antlr.Parser { return s.parser }

func (s *EngineNameContext) ARCHIVE() antlr.TerminalNode {
	return s.GetToken(MySqlParserARCHIVE, 0)
}

func (s *EngineNameContext) BLACKHOLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserBLACKHOLE, 0)
}

func (s *EngineNameContext) CSV() antlr.TerminalNode {
	return s.GetToken(MySqlParserCSV, 0)
}

func (s *EngineNameContext) FEDERATED() antlr.TerminalNode {
	return s.GetToken(MySqlParserFEDERATED, 0)
}

func (s *EngineNameContext) INNODB() antlr.TerminalNode {
	return s.GetToken(MySqlParserINNODB, 0)
}

func (s *EngineNameContext) MEMORY() antlr.TerminalNode {
	return s.GetToken(MySqlParserMEMORY, 0)
}

func (s *EngineNameContext) MRG_MYISAM() antlr.TerminalNode {
	return s.GetToken(MySqlParserMRG_MYISAM, 0)
}

func (s *EngineNameContext) MYISAM() antlr.TerminalNode {
	return s.GetToken(MySqlParserMYISAM, 0)
}

func (s *EngineNameContext) NDB() antlr.TerminalNode {
	return s.GetToken(MySqlParserNDB, 0)
}

func (s *EngineNameContext) NDBCLUSTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserNDBCLUSTER, 0)
}

func (s *EngineNameContext) PERFORMANCE_SCHEMA() antlr.TerminalNode {
	return s.GetToken(MySqlParserPERFORMANCE_SCHEMA, 0)
}

func (s *EngineNameContext) TOKUDB() antlr.TerminalNode {
	return s.GetToken(MySqlParserTOKUDB, 0)
}

func (s *EngineNameContext) ID() antlr.TerminalNode {
	return s.GetToken(MySqlParserID, 0)
}

func (s *EngineNameContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *EngineNameContext) REVERSE_QUOTE_ID() antlr.TerminalNode {
	return s.GetToken(MySqlParserREVERSE_QUOTE_ID, 0)
}

func (s *EngineNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EngineNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EngineNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterEngineName(s)
	}
}

func (s *EngineNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitEngineName(s)
	}
}

func (s *EngineNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitEngineName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) EngineName() (localctx IEngineNameContext) {
	localctx = NewEngineNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, MySqlParserRULE_engineName)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(662)
		_la = p.GetTokenStream().LA(1)

		if !((((_la-679)&-(0x1f+1)) == 0 && ((1<<uint((_la-679)))&((1<<(MySqlParserARCHIVE-679))|(1<<(MySqlParserBLACKHOLE-679))|(1<<(MySqlParserCSV-679))|(1<<(MySqlParserFEDERATED-679))|(1<<(MySqlParserINNODB-679))|(1<<(MySqlParserMEMORY-679))|(1<<(MySqlParserMRG_MYISAM-679))|(1<<(MySqlParserMYISAM-679))|(1<<(MySqlParserNDB-679))|(1<<(MySqlParserNDBCLUSTER-679))|(1<<(MySqlParserPERFORMANCE_SCHEMA-679))|(1<<(MySqlParserTOKUDB-679)))) != 0) || (((_la-1037)&-(0x1f+1)) == 0 && ((1<<uint((_la-1037)))&((1<<(MySqlParserSTRING_LITERAL-1037))|(1<<(MySqlParserID-1037))|(1<<(MySqlParserREVERSE_QUOTE_ID-1037)))) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ISimpleIdContext is an interface to support dynamic dispatch.
type ISimpleIdContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSimpleIdContext differentiates from other interfaces.
	IsSimpleIdContext()
}

type SimpleIdContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleIdContext() *SimpleIdContext {
	var p = new(SimpleIdContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_simpleId
	return p
}

func (*SimpleIdContext) IsSimpleIdContext() {}

func NewSimpleIdContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleIdContext {
	var p = new(SimpleIdContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_simpleId

	return p
}

func (s *SimpleIdContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleIdContext) ID() antlr.TerminalNode {
	return s.GetToken(MySqlParserID, 0)
}

func (s *SimpleIdContext) CharsetNameBase() ICharsetNameBaseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICharsetNameBaseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICharsetNameBaseContext)
}

func (s *SimpleIdContext) TransactionLevelBase() ITransactionLevelBaseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITransactionLevelBaseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITransactionLevelBaseContext)
}

func (s *SimpleIdContext) EngineName() IEngineNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEngineNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEngineNameContext)
}

func (s *SimpleIdContext) PrivilegesBase() IPrivilegesBaseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrivilegesBaseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrivilegesBaseContext)
}

func (s *SimpleIdContext) IntervalTypeBase() IIntervalTypeBaseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntervalTypeBaseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntervalTypeBaseContext)
}

func (s *SimpleIdContext) DataTypeBase() IDataTypeBaseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDataTypeBaseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDataTypeBaseContext)
}

func (s *SimpleIdContext) KeywordsCanBeId() IKeywordsCanBeIdContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IKeywordsCanBeIdContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IKeywordsCanBeIdContext)
}

func (s *SimpleIdContext) FunctionNameBase() IFunctionNameBaseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionNameBaseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionNameBaseContext)
}

func (s *SimpleIdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleIdContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleIdContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSimpleId(s)
	}
}

func (s *SimpleIdContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSimpleId(s)
	}
}

func (s *SimpleIdContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSimpleId(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) SimpleId() (localctx ISimpleIdContext) {
	localctx = NewSimpleIdContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, MySqlParserRULE_simpleId)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(673)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 97, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(664)
			p.Match(MySqlParserID)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(665)
			p.CharsetNameBase()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(666)
			p.TransactionLevelBase()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(667)
			p.EngineName()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(668)
			p.PrivilegesBase()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(669)
			p.IntervalTypeBase()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(670)
			p.DataTypeBase()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(671)
			p.KeywordsCanBeId()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(672)
			p.FunctionNameBase()
		}

	}

	return localctx
}

// IDottedIdContext is an interface to support dynamic dispatch.
type IDottedIdContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDottedIdContext differentiates from other interfaces.
	IsDottedIdContext()
}

type DottedIdContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDottedIdContext() *DottedIdContext {
	var p = new(DottedIdContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_dottedId
	return p
}

func (*DottedIdContext) IsDottedIdContext() {}

func NewDottedIdContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DottedIdContext {
	var p = new(DottedIdContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_dottedId

	return p
}

func (s *DottedIdContext) GetParser() antlr.Parser { return s.parser }

func (s *DottedIdContext) DOT_ID() antlr.TerminalNode {
	return s.GetToken(MySqlParserDOT_ID, 0)
}

func (s *DottedIdContext) DOT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDOT, 0)
}

func (s *DottedIdContext) Uid() IUidContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUidContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *DottedIdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DottedIdContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DottedIdContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDottedId(s)
	}
}

func (s *DottedIdContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDottedId(s)
	}
}

func (s *DottedIdContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitDottedId(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) DottedId() (localctx IDottedIdContext) {
	localctx = NewDottedIdContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, MySqlParserRULE_dottedId)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(678)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case MySqlParserDOT_ID:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(675)
			p.Match(MySqlParserDOT_ID)
		}

	case MySqlParserDOT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(676)
			p.Match(MySqlParserDOT)
		}
		{
			p.SetState(677)
			p.Uid()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ICollationNameContext is an interface to support dynamic dispatch.
type ICollationNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCollationNameContext differentiates from other interfaces.
	IsCollationNameContext()
}

type CollationNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollationNameContext() *CollationNameContext {
	var p = new(CollationNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_collationName
	return p
}

func (*CollationNameContext) IsCollationNameContext() {}

func NewCollationNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CollationNameContext {
	var p = new(CollationNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_collationName

	return p
}

func (s *CollationNameContext) GetParser() antlr.Parser { return s.parser }

func (s *CollationNameContext) Uid() IUidContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUidContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *CollationNameContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *CollationNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CollationNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CollationNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCollationName(s)
	}
}

func (s *CollationNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCollationName(s)
	}
}

func (s *CollationNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCollationName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) CollationName() (localctx ICollationNameContext) {
	localctx = NewCollationNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, MySqlParserRULE_collationName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(682)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 99, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(680)
			p.Uid()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(681)
			p.Match(MySqlParserSTRING_LITERAL)
		}

	}

	return localctx
}

// IDecimalLiteralContext is an interface to support dynamic dispatch.
type IDecimalLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDecimalLiteralContext differentiates from other interfaces.
	IsDecimalLiteralContext()
}

type DecimalLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDecimalLiteralContext() *DecimalLiteralContext {
	var p = new(DecimalLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_decimalLiteral
	return p
}

func (*DecimalLiteralContext) IsDecimalLiteralContext() {}

func NewDecimalLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DecimalLiteralContext {
	var p = new(DecimalLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_decimalLiteral

	return p
}

func (s *DecimalLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *DecimalLiteralContext) DECIMAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserDECIMAL_LITERAL, 0)
}

func (s *DecimalLiteralContext) ZERO_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserZERO_DECIMAL, 0)
}

func (s *DecimalLiteralContext) ONE_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserONE_DECIMAL, 0)
}

func (s *DecimalLiteralContext) TWO_DECIMAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserTWO_DECIMAL, 0)
}

func (s *DecimalLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DecimalLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DecimalLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDecimalLiteral(s)
	}
}

func (s *DecimalLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDecimalLiteral(s)
	}
}

func (s *DecimalLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitDecimalLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) DecimalLiteral() (localctx IDecimalLiteralContext) {
	localctx = NewDecimalLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, MySqlParserRULE_decimalLiteral)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(684)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-1027)&-(0x1f+1)) == 0 && ((1<<uint((_la-1027)))&((1<<(MySqlParserZERO_DECIMAL-1027))|(1<<(MySqlParserONE_DECIMAL-1027))|(1<<(MySqlParserTWO_DECIMAL-1027))|(1<<(MySqlParserDECIMAL_LITERAL-1027)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IStringLiteralContext is an interface to support dynamic dispatch.
type IStringLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStringLiteralContext differentiates from other interfaces.
	IsStringLiteralContext()
}

type StringLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringLiteralContext() *StringLiteralContext {
	var p = new(StringLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_stringLiteral
	return p
}

func (*StringLiteralContext) IsStringLiteralContext() {}

func NewStringLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringLiteralContext {
	var p = new(StringLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_stringLiteral

	return p
}

func (s *StringLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *StringLiteralContext) CopyFrom(ctx *StringLiteralContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *StringLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type StringLiteral2Context struct {
	*StringLiteralContext
}

func NewStringLiteral2Context(parser antlr.Parser, ctx antlr.ParserRuleContext) *StringLiteral2Context {
	var p = new(StringLiteral2Context)

	p.StringLiteralContext = NewEmptyStringLiteralContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StringLiteralContext))

	return p
}

func (s *StringLiteral2Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringLiteral2Context) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *StringLiteral2Context) START_NATIONAL_STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTART_NATIONAL_STRING_LITERAL, 0)
}

func (s *StringLiteral2Context) COLLATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLLATE, 0)
}

func (s *StringLiteral2Context) CollationName() ICollationNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICollationNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICollationNameContext)
}

func (s *StringLiteral2Context) STRING_CHARSET_NAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_CHARSET_NAME, 0)
}

func (s *StringLiteral2Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterStringLiteral2(s)
	}
}

func (s *StringLiteral2Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitStringLiteral2(s)
	}
}

func (s *StringLiteral2Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitStringLiteral2(s)

	default:
		return t.VisitChildren(s)
	}
}

type StringLiteral1Context struct {
	*StringLiteralContext
}

func NewStringLiteral1Context(parser antlr.Parser, ctx antlr.ParserRuleContext) *StringLiteral1Context {
	var p = new(StringLiteral1Context)

	p.StringLiteralContext = NewEmptyStringLiteralContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StringLiteralContext))

	return p
}

func (s *StringLiteral1Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringLiteral1Context) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserSTRING_LITERAL)
}

func (s *StringLiteral1Context) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, i)
}

func (s *StringLiteral1Context) START_NATIONAL_STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTART_NATIONAL_STRING_LITERAL, 0)
}

func (s *StringLiteral1Context) STRING_CHARSET_NAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_CHARSET_NAME, 0)
}

func (s *StringLiteral1Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterStringLiteral1(s)
	}
}

func (s *StringLiteral1Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitStringLiteral1(s)
	}
}

func (s *StringLiteral1Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitStringLiteral1(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) StringLiteral() (localctx IStringLiteralContext) {
	localctx = NewStringLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, MySqlParserRULE_stringLiteral)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(709)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 106, p.GetParserRuleContext()) {
	case 1:
		localctx = NewStringLiteral1Context(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(691)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case MySqlParserSTRING_LITERAL, MySqlParserSTRING_CHARSET_NAME:
			p.SetState(687)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == MySqlParserSTRING_CHARSET_NAME {
				{
					p.SetState(686)
					p.Match(MySqlParserSTRING_CHARSET_NAME)
				}

			}
			{
				p.SetState(689)
				p.Match(MySqlParserSTRING_LITERAL)
			}

		case MySqlParserSTART_NATIONAL_STRING_LITERAL:
			{
				p.SetState(690)
				p.Match(MySqlParserSTART_NATIONAL_STRING_LITERAL)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		p.SetState(694)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(693)
					p.Match(MySqlParserSTRING_LITERAL)
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(696)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 102, p.GetParserRuleContext())
		}

	case 2:
		localctx = NewStringLiteral2Context(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		p.SetState(703)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case MySqlParserSTRING_LITERAL, MySqlParserSTRING_CHARSET_NAME:
			p.SetState(699)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == MySqlParserSTRING_CHARSET_NAME {
				{
					p.SetState(698)
					p.Match(MySqlParserSTRING_CHARSET_NAME)
				}

			}
			{
				p.SetState(701)
				p.Match(MySqlParserSTRING_LITERAL)
			}

		case MySqlParserSTART_NATIONAL_STRING_LITERAL:
			{
				p.SetState(702)
				p.Match(MySqlParserSTART_NATIONAL_STRING_LITERAL)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		p.SetState(707)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 105, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(705)
				p.Match(MySqlParserCOLLATE)
			}
			{
				p.SetState(706)
				p.CollationName()
			}

		}

	}

	return localctx
}

// INullNotnullContext is an interface to support dynamic dispatch.
type INullNotnullContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNullNotnullContext differentiates from other interfaces.
	IsNullNotnullContext()
}

type NullNotnullContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNullNotnullContext() *NullNotnullContext {
	var p = new(NullNotnullContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_nullNotnull
	return p
}

func (*NullNotnullContext) IsNullNotnullContext() {}

func NewNullNotnullContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NullNotnullContext {
	var p = new(NullNotnullContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_nullNotnull

	return p
}

func (s *NullNotnullContext) GetParser() antlr.Parser { return s.parser }

func (s *NullNotnullContext) NULL_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserNULL_LITERAL, 0)
}

func (s *NullNotnullContext) NULL_SPEC_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserNULL_SPEC_LITERAL, 0)
}

func (s *NullNotnullContext) NOT() antlr.TerminalNode {
	return s.GetToken(MySqlParserNOT, 0)
}

func (s *NullNotnullContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NullNotnullContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NullNotnullContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterNullNotnull(s)
	}
}

func (s *NullNotnullContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitNullNotnull(s)
	}
}

func (s *NullNotnullContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitNullNotnull(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) NullNotnull() (localctx INullNotnullContext) {
	localctx = NewNullNotnullContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, MySqlParserRULE_nullNotnull)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(712)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserNOT {
		{
			p.SetState(711)
			p.Match(MySqlParserNOT)
		}

	}
	{
		p.SetState(714)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserNULL_LITERAL || _la == MySqlParserNULL_SPEC_LITERAL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IBooleanLiteralContext is an interface to support dynamic dispatch.
type IBooleanLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBooleanLiteralContext differentiates from other interfaces.
	IsBooleanLiteralContext()
}

type BooleanLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBooleanLiteralContext() *BooleanLiteralContext {
	var p = new(BooleanLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_booleanLiteral
	return p
}

func (*BooleanLiteralContext) IsBooleanLiteralContext() {}

func NewBooleanLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BooleanLiteralContext {
	var p = new(BooleanLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_booleanLiteral

	return p
}

func (s *BooleanLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *BooleanLiteralContext) TRUE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTRUE, 0)
}

func (s *BooleanLiteralContext) FALSE() antlr.TerminalNode {
	return s.GetToken(MySqlParserFALSE, 0)
}

func (s *BooleanLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BooleanLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterBooleanLiteral(s)
	}
}

func (s *BooleanLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitBooleanLiteral(s)
	}
}

func (s *BooleanLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitBooleanLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) BooleanLiteral() (localctx IBooleanLiteralContext) {
	localctx = NewBooleanLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, MySqlParserRULE_booleanLiteral)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(716)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserFALSE || _la == MySqlParserTRUE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IHexadecimalLiteralContext is an interface to support dynamic dispatch.
type IHexadecimalLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHexadecimalLiteralContext differentiates from other interfaces.
	IsHexadecimalLiteralContext()
}

type HexadecimalLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHexadecimalLiteralContext() *HexadecimalLiteralContext {
	var p = new(HexadecimalLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_hexadecimalLiteral
	return p
}

func (*HexadecimalLiteralContext) IsHexadecimalLiteralContext() {}

func NewHexadecimalLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HexadecimalLiteralContext {
	var p = new(HexadecimalLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_hexadecimalLiteral

	return p
}

func (s *HexadecimalLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *HexadecimalLiteralContext) HEXADECIMAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserHEXADECIMAL_LITERAL, 0)
}

func (s *HexadecimalLiteralContext) STRING_CHARSET_NAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_CHARSET_NAME, 0)
}

func (s *HexadecimalLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HexadecimalLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HexadecimalLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterHexadecimalLiteral(s)
	}
}

func (s *HexadecimalLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitHexadecimalLiteral(s)
	}
}

func (s *HexadecimalLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitHexadecimalLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) HexadecimalLiteral() (localctx IHexadecimalLiteralContext) {
	localctx = NewHexadecimalLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, MySqlParserRULE_hexadecimalLiteral)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(719)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserSTRING_CHARSET_NAME {
		{
			p.SetState(718)
			p.Match(MySqlParserSTRING_CHARSET_NAME)
		}

	}
	{
		p.SetState(721)
		p.Match(MySqlParserHEXADECIMAL_LITERAL)
	}

	return localctx
}

// IConstantContext is an interface to support dynamic dispatch.
type IConstantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstantContext differentiates from other interfaces.
	IsConstantContext()
}

type ConstantContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstantContext() *ConstantContext {
	var p = new(ConstantContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_constant
	return p
}

func (*ConstantContext) IsConstantContext() {}

func NewConstantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstantContext {
	var p = new(ConstantContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_constant

	return p
}

func (s *ConstantContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstantContext) StringLiteral() IStringLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStringLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *ConstantContext) DecimalLiteral() IDecimalLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDecimalLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *ConstantContext) MINUS() antlr.TerminalNode {
	return s.GetToken(MySqlParserMINUS, 0)
}

func (s *ConstantContext) HexadecimalLiteral() IHexadecimalLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHexadecimalLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHexadecimalLiteralContext)
}

func (s *ConstantContext) BooleanLiteral() IBooleanLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBooleanLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBooleanLiteralContext)
}

func (s *ConstantContext) REAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserREAL_LITERAL, 0)
}

func (s *ConstantContext) BIT_STRING() antlr.TerminalNode {
	return s.GetToken(MySqlParserBIT_STRING, 0)
}

func (s *ConstantContext) NullNotnull() INullNotnullContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INullNotnullContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INullNotnullContext)
}

func (s *ConstantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstantContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterConstant(s)
	}
}

func (s *ConstantContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitConstant(s)
	}
}

func (s *ConstantContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitConstant(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) Constant() (localctx IConstantContext) {
	localctx = NewConstantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, MySqlParserRULE_constant)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(732)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 109, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(723)
			p.StringLiteral()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(724)
			p.DecimalLiteral()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(725)
			p.Match(MySqlParserMINUS)
		}
		{
			p.SetState(726)
			p.DecimalLiteral()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(727)
			p.HexadecimalLiteral()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(728)
			p.BooleanLiteral()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(729)
			p.Match(MySqlParserREAL_LITERAL)
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(730)
			p.Match(MySqlParserBIT_STRING)
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(731)
			p.NullNotnull()
		}

	}

	return localctx
}

// IDataTypeContext is an interface to support dynamic dispatch.
type IDataTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataTypeContext differentiates from other interfaces.
	IsDataTypeContext()
}

type DataTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataTypeContext() *DataTypeContext {
	var p = new(DataTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_dataType
	return p
}

func (*DataTypeContext) IsDataTypeContext() {}

func NewDataTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataTypeContext {
	var p = new(DataTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_dataType

	return p
}

func (s *DataTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *DataTypeContext) CopyFrom(ctx *DataTypeContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *DataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SpatialDataTypeContext struct {
	*DataTypeContext
	typeName antlr.Token
}

func NewSpatialDataTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SpatialDataTypeContext {
	var p = new(SpatialDataTypeContext)

	p.DataTypeContext = NewEmptyDataTypeContext()
	p.parser = parser
	p.CopyFrom(ctx.(*DataTypeContext))

	return p
}

func (s *SpatialDataTypeContext) GetTypeName() antlr.Token { return s.typeName }

func (s *SpatialDataTypeContext) SetTypeName(v antlr.Token) { s.typeName = v }

func (s *SpatialDataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SpatialDataTypeContext) GEOMETRYCOLLECTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserGEOMETRYCOLLECTION, 0)
}

func (s *SpatialDataTypeContext) GEOMCOLLECTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserGEOMCOLLECTION, 0)
}

func (s *SpatialDataTypeContext) LINESTRING() antlr.TerminalNode {
	return s.GetToken(MySqlParserLINESTRING, 0)
}

func (s *SpatialDataTypeContext) MULTILINESTRING() antlr.TerminalNode {
	return s.GetToken(MySqlParserMULTILINESTRING, 0)
}

func (s *SpatialDataTypeContext) MULTIPOINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserMULTIPOINT, 0)
}

func (s *SpatialDataTypeContext) MULTIPOLYGON() antlr.TerminalNode {
	return s.GetToken(MySqlParserMULTIPOLYGON, 0)
}

func (s *SpatialDataTypeContext) POINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserPOINT, 0)
}

func (s *SpatialDataTypeContext) POLYGON() antlr.TerminalNode {
	return s.GetToken(MySqlParserPOLYGON, 0)
}

func (s *SpatialDataTypeContext) JSON() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON, 0)
}

func (s *SpatialDataTypeContext) GEOMETRY() antlr.TerminalNode {
	return s.GetToken(MySqlParserGEOMETRY, 0)
}

func (s *SpatialDataTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSpatialDataType(s)
	}
}

func (s *SpatialDataTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSpatialDataType(s)
	}
}

func (s *SpatialDataTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSpatialDataType(s)

	default:
		return t.VisitChildren(s)
	}
}

type LongVarbinaryDataTypeContext struct {
	*DataTypeContext
}

func NewLongVarbinaryDataTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LongVarbinaryDataTypeContext {
	var p = new(LongVarbinaryDataTypeContext)

	p.DataTypeContext = NewEmptyDataTypeContext()
	p.parser = parser
	p.CopyFrom(ctx.(*DataTypeContext))

	return p
}

func (s *LongVarbinaryDataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LongVarbinaryDataTypeContext) LONG() antlr.TerminalNode {
	return s.GetToken(MySqlParserLONG, 0)
}

func (s *LongVarbinaryDataTypeContext) VARBINARY() antlr.TerminalNode {
	return s.GetToken(MySqlParserVARBINARY, 0)
}

func (s *LongVarbinaryDataTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterLongVarbinaryDataType(s)
	}
}

func (s *LongVarbinaryDataTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitLongVarbinaryDataType(s)
	}
}

func (s *LongVarbinaryDataTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitLongVarbinaryDataType(s)

	default:
		return t.VisitChildren(s)
	}
}

type CollectionDataTypeContext struct {
	*DataTypeContext
	typeName antlr.Token
}

func NewCollectionDataTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CollectionDataTypeContext {
	var p = new(CollectionDataTypeContext)

	p.DataTypeContext = NewEmptyDataTypeContext()
	p.parser = parser
	p.CopyFrom(ctx.(*DataTypeContext))

	return p
}

func (s *CollectionDataTypeContext) GetTypeName() antlr.Token { return s.typeName }

func (s *CollectionDataTypeContext) SetTypeName(v antlr.Token) { s.typeName = v }

func (s *CollectionDataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CollectionDataTypeContext) CollectionOptions() ICollectionOptionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICollectionOptionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICollectionOptionsContext)
}

func (s *CollectionDataTypeContext) ENUM() antlr.TerminalNode {
	return s.GetToken(MySqlParserENUM, 0)
}

func (s *CollectionDataTypeContext) AllSET() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserSET)
}

func (s *CollectionDataTypeContext) SET(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserSET, i)
}

func (s *CollectionDataTypeContext) BINARY() antlr.TerminalNode {
	return s.GetToken(MySqlParserBINARY, 0)
}

func (s *CollectionDataTypeContext) CharsetName() ICharsetNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICharsetNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICharsetNameContext)
}

func (s *CollectionDataTypeContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHARACTER, 0)
}

func (s *CollectionDataTypeContext) CHARSET() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHARSET, 0)
}

func (s *CollectionDataTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCollectionDataType(s)
	}
}

func (s *CollectionDataTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCollectionDataType(s)
	}
}

func (s *CollectionDataTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCollectionDataType(s)

	default:
		return t.VisitChildren(s)
	}
}

type NationalVaryingStringDataTypeContext struct {
	*DataTypeContext
	typeName antlr.Token
}

func NewNationalVaryingStringDataTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NationalVaryingStringDataTypeContext {
	var p = new(NationalVaryingStringDataTypeContext)

	p.DataTypeContext = NewEmptyDataTypeContext()
	p.parser = parser
	p.CopyFrom(ctx.(*DataTypeContext))

	return p
}

func (s *NationalVaryingStringDataTypeContext) GetTypeName() antlr.Token { return s.typeName }

func (s *NationalVaryingStringDataTypeContext) SetTypeName(v antlr.Token) { s.typeName = v }

func (s *NationalVaryingStringDataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NationalVaryingStringDataTypeContext) NATIONAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserNATIONAL, 0)
}

func (s *NationalVaryingStringDataTypeContext) VARYING() antlr.TerminalNode {
	return s.GetToken(MySqlParserVARYING, 0)
}

func (s *NationalVaryingStringDataTypeContext) CHAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHAR, 0)
}

func (s *NationalVaryingStringDataTypeContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHARACTER, 0)
}

func (s *NationalVaryingStringDataTypeContext) LengthOneDimension() ILengthOneDimensionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILengthOneDimensionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILengthOneDimensionContext)
}

func (s *NationalVaryingStringDataTypeContext) BINARY() antlr.TerminalNode {
	return s.GetToken(MySqlParserBINARY, 0)
}

func (s *NationalVaryingStringDataTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterNationalVaryingStringDataType(s)
	}
}

func (s *NationalVaryingStringDataTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitNationalVaryingStringDataType(s)
	}
}

func (s *NationalVaryingStringDataTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitNationalVaryingStringDataType(s)

	default:
		return t.VisitChildren(s)
	}
}

type DimensionDataTypeContext struct {
	*DataTypeContext
	typeName antlr.Token
}

func NewDimensionDataTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DimensionDataTypeContext {
	var p = new(DimensionDataTypeContext)

	p.DataTypeContext = NewEmptyDataTypeContext()
	p.parser = parser
	p.CopyFrom(ctx.(*DataTypeContext))

	return p
}

func (s *DimensionDataTypeContext) GetTypeName() antlr.Token { return s.typeName }

func (s *DimensionDataTypeContext) SetTypeName(v antlr.Token) { s.typeName = v }

func (s *DimensionDataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DimensionDataTypeContext) TINYINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserTINYINT, 0)
}

func (s *DimensionDataTypeContext) SMALLINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserSMALLINT, 0)
}

func (s *DimensionDataTypeContext) MEDIUMINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserMEDIUMINT, 0)
}

func (s *DimensionDataTypeContext) INT() antlr.TerminalNode {
	return s.GetToken(MySqlParserINT, 0)
}

func (s *DimensionDataTypeContext) INTEGER() antlr.TerminalNode {
	return s.GetToken(MySqlParserINTEGER, 0)
}

func (s *DimensionDataTypeContext) BIGINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserBIGINT, 0)
}

func (s *DimensionDataTypeContext) MIDDLEINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserMIDDLEINT, 0)
}

func (s *DimensionDataTypeContext) INT1() antlr.TerminalNode {
	return s.GetToken(MySqlParserINT1, 0)
}

func (s *DimensionDataTypeContext) INT2() antlr.TerminalNode {
	return s.GetToken(MySqlParserINT2, 0)
}

func (s *DimensionDataTypeContext) INT3() antlr.TerminalNode {
	return s.GetToken(MySqlParserINT3, 0)
}

func (s *DimensionDataTypeContext) INT4() antlr.TerminalNode {
	return s.GetToken(MySqlParserINT4, 0)
}

func (s *DimensionDataTypeContext) INT8() antlr.TerminalNode {
	return s.GetToken(MySqlParserINT8, 0)
}

func (s *DimensionDataTypeContext) LengthOneDimension() ILengthOneDimensionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILengthOneDimensionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILengthOneDimensionContext)
}

func (s *DimensionDataTypeContext) ZEROFILL() antlr.TerminalNode {
	return s.GetToken(MySqlParserZEROFILL, 0)
}

func (s *DimensionDataTypeContext) SIGNED() antlr.TerminalNode {
	return s.GetToken(MySqlParserSIGNED, 0)
}

func (s *DimensionDataTypeContext) UNSIGNED() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNSIGNED, 0)
}

func (s *DimensionDataTypeContext) REAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserREAL, 0)
}

func (s *DimensionDataTypeContext) LengthTwoDimension() ILengthTwoDimensionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILengthTwoDimensionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILengthTwoDimensionContext)
}

func (s *DimensionDataTypeContext) DOUBLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDOUBLE, 0)
}

func (s *DimensionDataTypeContext) PRECISION() antlr.TerminalNode {
	return s.GetToken(MySqlParserPRECISION, 0)
}

func (s *DimensionDataTypeContext) DECIMAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserDECIMAL, 0)
}

func (s *DimensionDataTypeContext) DEC() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEC, 0)
}

func (s *DimensionDataTypeContext) FIXED() antlr.TerminalNode {
	return s.GetToken(MySqlParserFIXED, 0)
}

func (s *DimensionDataTypeContext) NUMERIC() antlr.TerminalNode {
	return s.GetToken(MySqlParserNUMERIC, 0)
}

func (s *DimensionDataTypeContext) FLOAT() antlr.TerminalNode {
	return s.GetToken(MySqlParserFLOAT, 0)
}

func (s *DimensionDataTypeContext) FLOAT4() antlr.TerminalNode {
	return s.GetToken(MySqlParserFLOAT4, 0)
}

func (s *DimensionDataTypeContext) FLOAT8() antlr.TerminalNode {
	return s.GetToken(MySqlParserFLOAT8, 0)
}

func (s *DimensionDataTypeContext) LengthTwoOptionalDimension() ILengthTwoOptionalDimensionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILengthTwoOptionalDimensionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILengthTwoOptionalDimensionContext)
}

func (s *DimensionDataTypeContext) BIT() antlr.TerminalNode {
	return s.GetToken(MySqlParserBIT, 0)
}

func (s *DimensionDataTypeContext) TIME() antlr.TerminalNode {
	return s.GetToken(MySqlParserTIME, 0)
}

func (s *DimensionDataTypeContext) TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(MySqlParserTIMESTAMP, 0)
}

func (s *DimensionDataTypeContext) DATETIME() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATETIME, 0)
}

func (s *DimensionDataTypeContext) BINARY() antlr.TerminalNode {
	return s.GetToken(MySqlParserBINARY, 0)
}

func (s *DimensionDataTypeContext) VARBINARY() antlr.TerminalNode {
	return s.GetToken(MySqlParserVARBINARY, 0)
}

func (s *DimensionDataTypeContext) YEAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserYEAR, 0)
}

func (s *DimensionDataTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDimensionDataType(s)
	}
}

func (s *DimensionDataTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDimensionDataType(s)
	}
}

func (s *DimensionDataTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitDimensionDataType(s)

	default:
		return t.VisitChildren(s)
	}
}

type StringDataTypeContext struct {
	*DataTypeContext
	typeName antlr.Token
}

func NewStringDataTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StringDataTypeContext {
	var p = new(StringDataTypeContext)

	p.DataTypeContext = NewEmptyDataTypeContext()
	p.parser = parser
	p.CopyFrom(ctx.(*DataTypeContext))

	return p
}

func (s *StringDataTypeContext) GetTypeName() antlr.Token { return s.typeName }

func (s *StringDataTypeContext) SetTypeName(v antlr.Token) { s.typeName = v }

func (s *StringDataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringDataTypeContext) CHAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHAR, 0)
}

func (s *StringDataTypeContext) AllCHARACTER() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCHARACTER)
}

func (s *StringDataTypeContext) CHARACTER(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCHARACTER, i)
}

func (s *StringDataTypeContext) VARCHAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserVARCHAR, 0)
}

func (s *StringDataTypeContext) TINYTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserTINYTEXT, 0)
}

func (s *StringDataTypeContext) TEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserTEXT, 0)
}

func (s *StringDataTypeContext) MEDIUMTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserMEDIUMTEXT, 0)
}

func (s *StringDataTypeContext) LONGTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserLONGTEXT, 0)
}

func (s *StringDataTypeContext) NCHAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserNCHAR, 0)
}

func (s *StringDataTypeContext) NVARCHAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserNVARCHAR, 0)
}

func (s *StringDataTypeContext) LONG() antlr.TerminalNode {
	return s.GetToken(MySqlParserLONG, 0)
}

func (s *StringDataTypeContext) LengthOneDimension() ILengthOneDimensionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILengthOneDimensionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILengthOneDimensionContext)
}

func (s *StringDataTypeContext) BINARY() antlr.TerminalNode {
	return s.GetToken(MySqlParserBINARY, 0)
}

func (s *StringDataTypeContext) CharsetName() ICharsetNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICharsetNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICharsetNameContext)
}

func (s *StringDataTypeContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLLATE, 0)
}

func (s *StringDataTypeContext) CollationName() ICollationNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICollationNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICollationNameContext)
}

func (s *StringDataTypeContext) SET() antlr.TerminalNode {
	return s.GetToken(MySqlParserSET, 0)
}

func (s *StringDataTypeContext) CHARSET() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHARSET, 0)
}

func (s *StringDataTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterStringDataType(s)
	}
}

func (s *StringDataTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitStringDataType(s)
	}
}

func (s *StringDataTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitStringDataType(s)

	default:
		return t.VisitChildren(s)
	}
}

type LongVarcharDataTypeContext struct {
	*DataTypeContext
	typeName antlr.Token
}

func NewLongVarcharDataTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LongVarcharDataTypeContext {
	var p = new(LongVarcharDataTypeContext)

	p.DataTypeContext = NewEmptyDataTypeContext()
	p.parser = parser
	p.CopyFrom(ctx.(*DataTypeContext))

	return p
}

func (s *LongVarcharDataTypeContext) GetTypeName() antlr.Token { return s.typeName }

func (s *LongVarcharDataTypeContext) SetTypeName(v antlr.Token) { s.typeName = v }

func (s *LongVarcharDataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LongVarcharDataTypeContext) LONG() antlr.TerminalNode {
	return s.GetToken(MySqlParserLONG, 0)
}

func (s *LongVarcharDataTypeContext) VARCHAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserVARCHAR, 0)
}

func (s *LongVarcharDataTypeContext) BINARY() antlr.TerminalNode {
	return s.GetToken(MySqlParserBINARY, 0)
}

func (s *LongVarcharDataTypeContext) CharsetName() ICharsetNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICharsetNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICharsetNameContext)
}

func (s *LongVarcharDataTypeContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLLATE, 0)
}

func (s *LongVarcharDataTypeContext) CollationName() ICollationNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICollationNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICollationNameContext)
}

func (s *LongVarcharDataTypeContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHARACTER, 0)
}

func (s *LongVarcharDataTypeContext) SET() antlr.TerminalNode {
	return s.GetToken(MySqlParserSET, 0)
}

func (s *LongVarcharDataTypeContext) CHARSET() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHARSET, 0)
}

func (s *LongVarcharDataTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterLongVarcharDataType(s)
	}
}

func (s *LongVarcharDataTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitLongVarcharDataType(s)
	}
}

func (s *LongVarcharDataTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitLongVarcharDataType(s)

	default:
		return t.VisitChildren(s)
	}
}

type NationalStringDataTypeContext struct {
	*DataTypeContext
	typeName antlr.Token
}

func NewNationalStringDataTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NationalStringDataTypeContext {
	var p = new(NationalStringDataTypeContext)

	p.DataTypeContext = NewEmptyDataTypeContext()
	p.parser = parser
	p.CopyFrom(ctx.(*DataTypeContext))

	return p
}

func (s *NationalStringDataTypeContext) GetTypeName() antlr.Token { return s.typeName }

func (s *NationalStringDataTypeContext) SetTypeName(v antlr.Token) { s.typeName = v }

func (s *NationalStringDataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NationalStringDataTypeContext) NATIONAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserNATIONAL, 0)
}

func (s *NationalStringDataTypeContext) VARCHAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserVARCHAR, 0)
}

func (s *NationalStringDataTypeContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHARACTER, 0)
}

func (s *NationalStringDataTypeContext) LengthOneDimension() ILengthOneDimensionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILengthOneDimensionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILengthOneDimensionContext)
}

func (s *NationalStringDataTypeContext) BINARY() antlr.TerminalNode {
	return s.GetToken(MySqlParserBINARY, 0)
}

func (s *NationalStringDataTypeContext) NCHAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserNCHAR, 0)
}

func (s *NationalStringDataTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterNationalStringDataType(s)
	}
}

func (s *NationalStringDataTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitNationalStringDataType(s)
	}
}

func (s *NationalStringDataTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitNationalStringDataType(s)

	default:
		return t.VisitChildren(s)
	}
}

type SimpleDataTypeContext struct {
	*DataTypeContext
	typeName antlr.Token
}

func NewSimpleDataTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleDataTypeContext {
	var p = new(SimpleDataTypeContext)

	p.DataTypeContext = NewEmptyDataTypeContext()
	p.parser = parser
	p.CopyFrom(ctx.(*DataTypeContext))

	return p
}

func (s *SimpleDataTypeContext) GetTypeName() antlr.Token { return s.typeName }

func (s *SimpleDataTypeContext) SetTypeName(v antlr.Token) { s.typeName = v }

func (s *SimpleDataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleDataTypeContext) DATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATE, 0)
}

func (s *SimpleDataTypeContext) TINYBLOB() antlr.TerminalNode {
	return s.GetToken(MySqlParserTINYBLOB, 0)
}

func (s *SimpleDataTypeContext) BLOB() antlr.TerminalNode {
	return s.GetToken(MySqlParserBLOB, 0)
}

func (s *SimpleDataTypeContext) MEDIUMBLOB() antlr.TerminalNode {
	return s.GetToken(MySqlParserMEDIUMBLOB, 0)
}

func (s *SimpleDataTypeContext) LONGBLOB() antlr.TerminalNode {
	return s.GetToken(MySqlParserLONGBLOB, 0)
}

func (s *SimpleDataTypeContext) BOOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserBOOL, 0)
}

func (s *SimpleDataTypeContext) BOOLEAN() antlr.TerminalNode {
	return s.GetToken(MySqlParserBOOLEAN, 0)
}

func (s *SimpleDataTypeContext) SERIAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSERIAL, 0)
}

func (s *SimpleDataTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSimpleDataType(s)
	}
}

func (s *SimpleDataTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSimpleDataType(s)
	}
}

func (s *SimpleDataTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSimpleDataType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) DataType() (localctx IDataTypeContext) {
	localctx = NewDataTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, MySqlParserRULE_dataType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(861)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 143, p.GetParserRuleContext()) {
	case 1:
		localctx = NewStringDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(734)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*StringDataTypeContext).typeName = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserCHARACTER || (((_la-204)&-(0x1f+1)) == 0 && ((1<<uint((_la-204)))&((1<<(MySqlParserCHAR-204))|(1<<(MySqlParserVARCHAR-204))|(1<<(MySqlParserNVARCHAR-204))|(1<<(MySqlParserLONG-204))|(1<<(MySqlParserTINYTEXT-204))|(1<<(MySqlParserTEXT-204))|(1<<(MySqlParserMEDIUMTEXT-204))|(1<<(MySqlParserLONGTEXT-204)))) != 0) || _la == MySqlParserNCHAR) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*StringDataTypeContext).typeName = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(736)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserLR_BRACKET {
			{
				p.SetState(735)
				p.LengthOneDimension()
			}

		}
		p.SetState(739)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserBINARY {
			{
				p.SetState(738)
				p.Match(MySqlParserBINARY)
			}

		}
		p.SetState(747)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserCHARACTER || _la == MySqlParserCHARSET {
			p.SetState(744)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case MySqlParserCHARACTER:
				{
					p.SetState(741)
					p.Match(MySqlParserCHARACTER)
				}
				{
					p.SetState(742)
					p.Match(MySqlParserSET)
				}

			case MySqlParserCHARSET:
				{
					p.SetState(743)
					p.Match(MySqlParserCHARSET)
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}
			{
				p.SetState(746)
				p.CharsetName()
			}

		}
		p.SetState(751)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserCOLLATE {
			{
				p.SetState(749)
				p.Match(MySqlParserCOLLATE)
			}
			{
				p.SetState(750)
				p.CollationName()
			}

		}

	case 2:
		localctx = NewNationalStringDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(753)
			p.Match(MySqlParserNATIONAL)
		}
		{
			p.SetState(754)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*NationalStringDataTypeContext).typeName = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserCHARACTER || _la == MySqlParserVARCHAR) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*NationalStringDataTypeContext).typeName = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(756)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserLR_BRACKET {
			{
				p.SetState(755)
				p.LengthOneDimension()
			}

		}
		p.SetState(759)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserBINARY {
			{
				p.SetState(758)
				p.Match(MySqlParserBINARY)
			}

		}

	case 3:
		localctx = NewNationalStringDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(761)
			p.Match(MySqlParserNCHAR)
		}
		{
			p.SetState(762)

			var _m = p.Match(MySqlParserVARCHAR)

			localctx.(*NationalStringDataTypeContext).typeName = _m
		}
		p.SetState(764)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserLR_BRACKET {
			{
				p.SetState(763)
				p.LengthOneDimension()
			}

		}
		p.SetState(767)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserBINARY {
			{
				p.SetState(766)
				p.Match(MySqlParserBINARY)
			}

		}

	case 4:
		localctx = NewNationalVaryingStringDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(769)
			p.Match(MySqlParserNATIONAL)
		}
		{
			p.SetState(770)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*NationalVaryingStringDataTypeContext).typeName = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserCHARACTER || _la == MySqlParserCHAR) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*NationalVaryingStringDataTypeContext).typeName = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(771)
			p.Match(MySqlParserVARYING)
		}
		p.SetState(773)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserLR_BRACKET {
			{
				p.SetState(772)
				p.LengthOneDimension()
			}

		}
		p.SetState(776)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserBINARY {
			{
				p.SetState(775)
				p.Match(MySqlParserBINARY)
			}

		}

	case 5:
		localctx = NewDimensionDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(778)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*DimensionDataTypeContext).typeName = _lt

			_la = p.GetTokenStream().LA(1)

			if !(((_la-178)&-(0x1f+1)) == 0 && ((1<<uint((_la-178)))&((1<<(MySqlParserTINYINT-178))|(1<<(MySqlParserSMALLINT-178))|(1<<(MySqlParserMEDIUMINT-178))|(1<<(MySqlParserMIDDLEINT-178))|(1<<(MySqlParserINT-178))|(1<<(MySqlParserINT1-178))|(1<<(MySqlParserINT2-178))|(1<<(MySqlParserINT3-178))|(1<<(MySqlParserINT4-178))|(1<<(MySqlParserINT8-178))|(1<<(MySqlParserINTEGER-178))|(1<<(MySqlParserBIGINT-178)))) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*DimensionDataTypeContext).typeName = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(780)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserLR_BRACKET {
			{
				p.SetState(779)
				p.LengthOneDimension()
			}

		}
		p.SetState(783)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserUNSIGNED || _la == MySqlParserSIGNED {
			{
				p.SetState(782)
				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserUNSIGNED || _la == MySqlParserSIGNED) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		p.SetState(786)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserZEROFILL {
			{
				p.SetState(785)
				p.Match(MySqlParserZEROFILL)
			}

		}

	case 6:
		localctx = NewDimensionDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(788)

			var _m = p.Match(MySqlParserREAL)

			localctx.(*DimensionDataTypeContext).typeName = _m
		}
		p.SetState(790)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserLR_BRACKET {
			{
				p.SetState(789)
				p.LengthTwoDimension()
			}

		}
		p.SetState(793)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserUNSIGNED || _la == MySqlParserSIGNED {
			{
				p.SetState(792)
				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserUNSIGNED || _la == MySqlParserSIGNED) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		p.SetState(796)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserZEROFILL {
			{
				p.SetState(795)
				p.Match(MySqlParserZEROFILL)
			}

		}

	case 7:
		localctx = NewDimensionDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(798)

			var _m = p.Match(MySqlParserDOUBLE)

			localctx.(*DimensionDataTypeContext).typeName = _m
		}
		p.SetState(800)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserPRECISION {
			{
				p.SetState(799)
				p.Match(MySqlParserPRECISION)
			}

		}
		p.SetState(803)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserLR_BRACKET {
			{
				p.SetState(802)
				p.LengthTwoDimension()
			}

		}
		p.SetState(806)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserUNSIGNED || _la == MySqlParserSIGNED {
			{
				p.SetState(805)
				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserUNSIGNED || _la == MySqlParserSIGNED) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		p.SetState(809)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserZEROFILL {
			{
				p.SetState(808)
				p.Match(MySqlParserZEROFILL)
			}

		}

	case 8:
		localctx = NewDimensionDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(811)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*DimensionDataTypeContext).typeName = _lt

			_la = p.GetTokenStream().LA(1)

			if !((((_la-193)&-(0x1f+1)) == 0 && ((1<<uint((_la-193)))&((1<<(MySqlParserFLOAT-193))|(1<<(MySqlParserFLOAT4-193))|(1<<(MySqlParserFLOAT8-193))|(1<<(MySqlParserDECIMAL-193))|(1<<(MySqlParserDEC-193))|(1<<(MySqlParserNUMERIC-193)))) != 0) || _la == MySqlParserFIXED) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*DimensionDataTypeContext).typeName = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(813)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserLR_BRACKET {
			{
				p.SetState(812)
				p.LengthTwoOptionalDimension()
			}

		}
		p.SetState(816)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserUNSIGNED || _la == MySqlParserSIGNED {
			{
				p.SetState(815)
				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserUNSIGNED || _la == MySqlParserSIGNED) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		p.SetState(819)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserZEROFILL {
			{
				p.SetState(818)
				p.Match(MySqlParserZEROFILL)
			}

		}

	case 9:
		localctx = NewSimpleDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(821)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*SimpleDataTypeContext).typeName = _lt

			_la = p.GetTokenStream().LA(1)

			if !((((_la-199)&-(0x1f+1)) == 0 && ((1<<uint((_la-199)))&((1<<(MySqlParserDATE-199))|(1<<(MySqlParserTINYBLOB-199))|(1<<(MySqlParserBLOB-199))|(1<<(MySqlParserMEDIUMBLOB-199))|(1<<(MySqlParserLONGBLOB-199))|(1<<(MySqlParserSERIAL-199)))) != 0) || _la == MySqlParserBOOL || _la == MySqlParserBOOLEAN) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*SimpleDataTypeContext).typeName = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 10:
		localctx = NewDimensionDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(822)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*DimensionDataTypeContext).typeName = _lt

			_la = p.GetTokenStream().LA(1)

			if !((((_la-200)&-(0x1f+1)) == 0 && ((1<<uint((_la-200)))&((1<<(MySqlParserTIME-200))|(1<<(MySqlParserTIMESTAMP-200))|(1<<(MySqlParserDATETIME-200))|(1<<(MySqlParserYEAR-200))|(1<<(MySqlParserBINARY-200))|(1<<(MySqlParserVARBINARY-200)))) != 0) || _la == MySqlParserBIT) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*DimensionDataTypeContext).typeName = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(824)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserLR_BRACKET {
			{
				p.SetState(823)
				p.LengthOneDimension()
			}

		}

	case 11:
		localctx = NewCollectionDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(826)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*CollectionDataTypeContext).typeName = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserSET || _la == MySqlParserENUM) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*CollectionDataTypeContext).typeName = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(827)
			p.CollectionOptions()
		}
		p.SetState(829)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserBINARY {
			{
				p.SetState(828)
				p.Match(MySqlParserBINARY)
			}

		}
		p.SetState(837)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserCHARACTER || _la == MySqlParserCHARSET {
			p.SetState(834)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case MySqlParserCHARACTER:
				{
					p.SetState(831)
					p.Match(MySqlParserCHARACTER)
				}
				{
					p.SetState(832)
					p.Match(MySqlParserSET)
				}

			case MySqlParserCHARSET:
				{
					p.SetState(833)
					p.Match(MySqlParserCHARSET)
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}
			{
				p.SetState(836)
				p.CharsetName()
			}

		}

	case 12:
		localctx = NewSpatialDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(839)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*SpatialDataTypeContext).typeName = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserJSON || (((_la-695)&-(0x1f+1)) == 0 && ((1<<uint((_la-695)))&((1<<(MySqlParserGEOMETRYCOLLECTION-695))|(1<<(MySqlParserGEOMCOLLECTION-695))|(1<<(MySqlParserGEOMETRY-695))|(1<<(MySqlParserLINESTRING-695))|(1<<(MySqlParserMULTILINESTRING-695))|(1<<(MySqlParserMULTIPOINT-695))|(1<<(MySqlParserMULTIPOLYGON-695))|(1<<(MySqlParserPOINT-695))|(1<<(MySqlParserPOLYGON-695)))) != 0)) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*SpatialDataTypeContext).typeName = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 13:
		localctx = NewLongVarcharDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(840)

			var _m = p.Match(MySqlParserLONG)

			localctx.(*LongVarcharDataTypeContext).typeName = _m
		}
		p.SetState(842)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserVARCHAR {
			{
				p.SetState(841)
				p.Match(MySqlParserVARCHAR)
			}

		}
		p.SetState(845)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserBINARY {
			{
				p.SetState(844)
				p.Match(MySqlParserBINARY)
			}

		}
		p.SetState(853)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserCHARACTER || _la == MySqlParserCHARSET {
			p.SetState(850)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case MySqlParserCHARACTER:
				{
					p.SetState(847)
					p.Match(MySqlParserCHARACTER)
				}
				{
					p.SetState(848)
					p.Match(MySqlParserSET)
				}

			case MySqlParserCHARSET:
				{
					p.SetState(849)
					p.Match(MySqlParserCHARSET)
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}
			{
				p.SetState(852)
				p.CharsetName()
			}

		}
		p.SetState(857)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserCOLLATE {
			{
				p.SetState(855)
				p.Match(MySqlParserCOLLATE)
			}
			{
				p.SetState(856)
				p.CollationName()
			}

		}

	case 14:
		localctx = NewLongVarbinaryDataTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(859)
			p.Match(MySqlParserLONG)
		}
		{
			p.SetState(860)
			p.Match(MySqlParserVARBINARY)
		}

	}

	return localctx
}

// ICollectionOptionsContext is an interface to support dynamic dispatch.
type ICollectionOptionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCollectionOptionsContext differentiates from other interfaces.
	IsCollectionOptionsContext()
}

type CollectionOptionsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollectionOptionsContext() *CollectionOptionsContext {
	var p = new(CollectionOptionsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_collectionOptions
	return p
}

func (*CollectionOptionsContext) IsCollectionOptionsContext() {}

func NewCollectionOptionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CollectionOptionsContext {
	var p = new(CollectionOptionsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_collectionOptions

	return p
}

func (s *CollectionOptionsContext) GetParser() antlr.Parser { return s.parser }

func (s *CollectionOptionsContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *CollectionOptionsContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserSTRING_LITERAL)
}

func (s *CollectionOptionsContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, i)
}

func (s *CollectionOptionsContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *CollectionOptionsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *CollectionOptionsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *CollectionOptionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CollectionOptionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CollectionOptionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCollectionOptions(s)
	}
}

func (s *CollectionOptionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCollectionOptions(s)
	}
}

func (s *CollectionOptionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCollectionOptions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) CollectionOptions() (localctx ICollectionOptionsContext) {
	localctx = NewCollectionOptionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, MySqlParserRULE_collectionOptions)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(863)
		p.Match(MySqlParserLR_BRACKET)
	}
	{
		p.SetState(864)
		p.Match(MySqlParserSTRING_LITERAL)
	}
	p.SetState(869)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == MySqlParserCOMMA {
		{
			p.SetState(865)
			p.Match(MySqlParserCOMMA)
		}
		{
			p.SetState(866)
			p.Match(MySqlParserSTRING_LITERAL)
		}

		p.SetState(871)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(872)
		p.Match(MySqlParserRR_BRACKET)
	}

	return localctx
}

// IConvertedDataTypeContext is an interface to support dynamic dispatch.
type IConvertedDataTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConvertedDataTypeContext differentiates from other interfaces.
	IsConvertedDataTypeContext()
}

type ConvertedDataTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConvertedDataTypeContext() *ConvertedDataTypeContext {
	var p = new(ConvertedDataTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_convertedDataType
	return p
}

func (*ConvertedDataTypeContext) IsConvertedDataTypeContext() {}

func NewConvertedDataTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConvertedDataTypeContext {
	var p = new(ConvertedDataTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_convertedDataType

	return p
}

func (s *ConvertedDataTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ConvertedDataTypeContext) CopyFrom(ctx *ConvertedDataTypeContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *ConvertedDataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConvertedDataTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ConvertedDataType3Context struct {
	*ConvertedDataTypeContext
	typeName antlr.Token
}

func NewConvertedDataType3Context(parser antlr.Parser, ctx antlr.ParserRuleContext) *ConvertedDataType3Context {
	var p = new(ConvertedDataType3Context)

	p.ConvertedDataTypeContext = NewEmptyConvertedDataTypeContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ConvertedDataTypeContext))

	return p
}

func (s *ConvertedDataType3Context) GetTypeName() antlr.Token { return s.typeName }

func (s *ConvertedDataType3Context) SetTypeName(v antlr.Token) { s.typeName = v }

func (s *ConvertedDataType3Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConvertedDataType3Context) DATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATE, 0)
}

func (s *ConvertedDataType3Context) DATETIME() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATETIME, 0)
}

func (s *ConvertedDataType3Context) TIME() antlr.TerminalNode {
	return s.GetToken(MySqlParserTIME, 0)
}

func (s *ConvertedDataType3Context) JSON() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON, 0)
}

func (s *ConvertedDataType3Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterConvertedDataType3(s)
	}
}

func (s *ConvertedDataType3Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitConvertedDataType3(s)
	}
}

func (s *ConvertedDataType3Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitConvertedDataType3(s)

	default:
		return t.VisitChildren(s)
	}
}

type ConvertedDataType2Context struct {
	*ConvertedDataTypeContext
	typeName antlr.Token
}

func NewConvertedDataType2Context(parser antlr.Parser, ctx antlr.ParserRuleContext) *ConvertedDataType2Context {
	var p = new(ConvertedDataType2Context)

	p.ConvertedDataTypeContext = NewEmptyConvertedDataTypeContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ConvertedDataTypeContext))

	return p
}

func (s *ConvertedDataType2Context) GetTypeName() antlr.Token { return s.typeName }

func (s *ConvertedDataType2Context) SetTypeName(v antlr.Token) { s.typeName = v }

func (s *ConvertedDataType2Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConvertedDataType2Context) CHAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHAR, 0)
}

func (s *ConvertedDataType2Context) LengthOneDimension() ILengthOneDimensionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILengthOneDimensionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILengthOneDimensionContext)
}

func (s *ConvertedDataType2Context) CharsetName() ICharsetNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICharsetNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICharsetNameContext)
}

func (s *ConvertedDataType2Context) CHARACTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHARACTER, 0)
}

func (s *ConvertedDataType2Context) SET() antlr.TerminalNode {
	return s.GetToken(MySqlParserSET, 0)
}

func (s *ConvertedDataType2Context) CHARSET() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHARSET, 0)
}

func (s *ConvertedDataType2Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterConvertedDataType2(s)
	}
}

func (s *ConvertedDataType2Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitConvertedDataType2(s)
	}
}

func (s *ConvertedDataType2Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitConvertedDataType2(s)

	default:
		return t.VisitChildren(s)
	}
}

type ConvertedDataType5Context struct {
	*ConvertedDataTypeContext
}

func NewConvertedDataType5Context(parser antlr.Parser, ctx antlr.ParserRuleContext) *ConvertedDataType5Context {
	var p = new(ConvertedDataType5Context)

	p.ConvertedDataTypeContext = NewEmptyConvertedDataTypeContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ConvertedDataTypeContext))

	return p
}

func (s *ConvertedDataType5Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConvertedDataType5Context) SIGNED() antlr.TerminalNode {
	return s.GetToken(MySqlParserSIGNED, 0)
}

func (s *ConvertedDataType5Context) UNSIGNED() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNSIGNED, 0)
}

func (s *ConvertedDataType5Context) INTEGER() antlr.TerminalNode {
	return s.GetToken(MySqlParserINTEGER, 0)
}

func (s *ConvertedDataType5Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterConvertedDataType5(s)
	}
}

func (s *ConvertedDataType5Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitConvertedDataType5(s)
	}
}

func (s *ConvertedDataType5Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitConvertedDataType5(s)

	default:
		return t.VisitChildren(s)
	}
}

type ConvertedDataType4Context struct {
	*ConvertedDataTypeContext
	typeName antlr.Token
}

func NewConvertedDataType4Context(parser antlr.Parser, ctx antlr.ParserRuleContext) *ConvertedDataType4Context {
	var p = new(ConvertedDataType4Context)

	p.ConvertedDataTypeContext = NewEmptyConvertedDataTypeContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ConvertedDataTypeContext))

	return p
}

func (s *ConvertedDataType4Context) GetTypeName() antlr.Token { return s.typeName }

func (s *ConvertedDataType4Context) SetTypeName(v antlr.Token) { s.typeName = v }

func (s *ConvertedDataType4Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConvertedDataType4Context) DECIMAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserDECIMAL, 0)
}

func (s *ConvertedDataType4Context) LengthTwoDimension() ILengthTwoDimensionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILengthTwoDimensionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILengthTwoDimensionContext)
}

func (s *ConvertedDataType4Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterConvertedDataType4(s)
	}
}

func (s *ConvertedDataType4Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitConvertedDataType4(s)
	}
}

func (s *ConvertedDataType4Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitConvertedDataType4(s)

	default:
		return t.VisitChildren(s)
	}
}

type ConvertedDataType1Context struct {
	*ConvertedDataTypeContext
	typeName antlr.Token
}

func NewConvertedDataType1Context(parser antlr.Parser, ctx antlr.ParserRuleContext) *ConvertedDataType1Context {
	var p = new(ConvertedDataType1Context)

	p.ConvertedDataTypeContext = NewEmptyConvertedDataTypeContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ConvertedDataTypeContext))

	return p
}

func (s *ConvertedDataType1Context) GetTypeName() antlr.Token { return s.typeName }

func (s *ConvertedDataType1Context) SetTypeName(v antlr.Token) { s.typeName = v }

func (s *ConvertedDataType1Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConvertedDataType1Context) BINARY() antlr.TerminalNode {
	return s.GetToken(MySqlParserBINARY, 0)
}

func (s *ConvertedDataType1Context) NCHAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserNCHAR, 0)
}

func (s *ConvertedDataType1Context) LengthOneDimension() ILengthOneDimensionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILengthOneDimensionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILengthOneDimensionContext)
}

func (s *ConvertedDataType1Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterConvertedDataType1(s)
	}
}

func (s *ConvertedDataType1Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitConvertedDataType1(s)
	}
}

func (s *ConvertedDataType1Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitConvertedDataType1(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) ConvertedDataType() (localctx IConvertedDataTypeContext) {
	localctx = NewConvertedDataTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, MySqlParserRULE_convertedDataType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(899)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case MySqlParserBINARY, MySqlParserNCHAR:
		localctx = NewConvertedDataType1Context(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(874)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ConvertedDataType1Context).typeName = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserBINARY || _la == MySqlParserNCHAR) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ConvertedDataType1Context).typeName = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(876)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserLR_BRACKET {
			{
				p.SetState(875)
				p.LengthOneDimension()
			}

		}

	case MySqlParserCHAR:
		localctx = NewConvertedDataType2Context(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(878)

			var _m = p.Match(MySqlParserCHAR)

			localctx.(*ConvertedDataType2Context).typeName = _m
		}
		p.SetState(880)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserLR_BRACKET {
			{
				p.SetState(879)
				p.LengthOneDimension()
			}

		}
		p.SetState(888)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserCHARACTER || _la == MySqlParserCHARSET {
			p.SetState(885)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case MySqlParserCHARACTER:
				{
					p.SetState(882)
					p.Match(MySqlParserCHARACTER)
				}
				{
					p.SetState(883)
					p.Match(MySqlParserSET)
				}

			case MySqlParserCHARSET:
				{
					p.SetState(884)
					p.Match(MySqlParserCHARSET)
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}
			{
				p.SetState(887)
				p.CharsetName()
			}

		}

	case MySqlParserDATE, MySqlParserTIME, MySqlParserDATETIME, MySqlParserJSON:
		localctx = NewConvertedDataType3Context(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(890)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ConvertedDataType3Context).typeName = _lt

			_la = p.GetTokenStream().LA(1)

			if !((((_la-199)&-(0x1f+1)) == 0 && ((1<<uint((_la-199)))&((1<<(MySqlParserDATE-199))|(1<<(MySqlParserTIME-199))|(1<<(MySqlParserDATETIME-199)))) != 0) || _la == MySqlParserJSON) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ConvertedDataType3Context).typeName = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case MySqlParserDECIMAL:
		localctx = NewConvertedDataType4Context(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(891)

			var _m = p.Match(MySqlParserDECIMAL)

			localctx.(*ConvertedDataType4Context).typeName = _m
		}
		p.SetState(893)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserLR_BRACKET {
			{
				p.SetState(892)
				p.LengthTwoDimension()
			}

		}

	case MySqlParserUNSIGNED, MySqlParserSIGNED:
		localctx = NewConvertedDataType5Context(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(895)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserUNSIGNED || _la == MySqlParserSIGNED) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(897)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserINTEGER {
			{
				p.SetState(896)
				p.Match(MySqlParserINTEGER)
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ILengthOneDimensionContext is an interface to support dynamic dispatch.
type ILengthOneDimensionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLengthOneDimensionContext differentiates from other interfaces.
	IsLengthOneDimensionContext()
}

type LengthOneDimensionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLengthOneDimensionContext() *LengthOneDimensionContext {
	var p = new(LengthOneDimensionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_lengthOneDimension
	return p
}

func (*LengthOneDimensionContext) IsLengthOneDimensionContext() {}

func NewLengthOneDimensionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LengthOneDimensionContext {
	var p = new(LengthOneDimensionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_lengthOneDimension

	return p
}

func (s *LengthOneDimensionContext) GetParser() antlr.Parser { return s.parser }

func (s *LengthOneDimensionContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *LengthOneDimensionContext) DecimalLiteral() IDecimalLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDecimalLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *LengthOneDimensionContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *LengthOneDimensionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LengthOneDimensionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LengthOneDimensionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterLengthOneDimension(s)
	}
}

func (s *LengthOneDimensionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitLengthOneDimension(s)
	}
}

func (s *LengthOneDimensionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitLengthOneDimension(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) LengthOneDimension() (localctx ILengthOneDimensionContext) {
	localctx = NewLengthOneDimensionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, MySqlParserRULE_lengthOneDimension)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(901)
		p.Match(MySqlParserLR_BRACKET)
	}
	{
		p.SetState(902)
		p.DecimalLiteral()
	}
	{
		p.SetState(903)
		p.Match(MySqlParserRR_BRACKET)
	}

	return localctx
}

// ILengthTwoDimensionContext is an interface to support dynamic dispatch.
type ILengthTwoDimensionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLengthTwoDimensionContext differentiates from other interfaces.
	IsLengthTwoDimensionContext()
}

type LengthTwoDimensionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLengthTwoDimensionContext() *LengthTwoDimensionContext {
	var p = new(LengthTwoDimensionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_lengthTwoDimension
	return p
}

func (*LengthTwoDimensionContext) IsLengthTwoDimensionContext() {}

func NewLengthTwoDimensionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LengthTwoDimensionContext {
	var p = new(LengthTwoDimensionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_lengthTwoDimension

	return p
}

func (s *LengthTwoDimensionContext) GetParser() antlr.Parser { return s.parser }

func (s *LengthTwoDimensionContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *LengthTwoDimensionContext) AllDecimalLiteral() []IDecimalLiteralContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDecimalLiteralContext)(nil)).Elem())
	var tst = make([]IDecimalLiteralContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDecimalLiteralContext)
		}
	}

	return tst
}

func (s *LengthTwoDimensionContext) DecimalLiteral(i int) IDecimalLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDecimalLiteralContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *LengthTwoDimensionContext) COMMA() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, 0)
}

func (s *LengthTwoDimensionContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *LengthTwoDimensionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LengthTwoDimensionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LengthTwoDimensionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterLengthTwoDimension(s)
	}
}

func (s *LengthTwoDimensionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitLengthTwoDimension(s)
	}
}

func (s *LengthTwoDimensionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitLengthTwoDimension(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) LengthTwoDimension() (localctx ILengthTwoDimensionContext) {
	localctx = NewLengthTwoDimensionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, MySqlParserRULE_lengthTwoDimension)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(905)
		p.Match(MySqlParserLR_BRACKET)
	}
	{
		p.SetState(906)
		p.DecimalLiteral()
	}
	{
		p.SetState(907)
		p.Match(MySqlParserCOMMA)
	}
	{
		p.SetState(908)
		p.DecimalLiteral()
	}
	{
		p.SetState(909)
		p.Match(MySqlParserRR_BRACKET)
	}

	return localctx
}

// ILengthTwoOptionalDimensionContext is an interface to support dynamic dispatch.
type ILengthTwoOptionalDimensionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLengthTwoOptionalDimensionContext differentiates from other interfaces.
	IsLengthTwoOptionalDimensionContext()
}

type LengthTwoOptionalDimensionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLengthTwoOptionalDimensionContext() *LengthTwoOptionalDimensionContext {
	var p = new(LengthTwoOptionalDimensionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_lengthTwoOptionalDimension
	return p
}

func (*LengthTwoOptionalDimensionContext) IsLengthTwoOptionalDimensionContext() {}

func NewLengthTwoOptionalDimensionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LengthTwoOptionalDimensionContext {
	var p = new(LengthTwoOptionalDimensionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_lengthTwoOptionalDimension

	return p
}

func (s *LengthTwoOptionalDimensionContext) GetParser() antlr.Parser { return s.parser }

func (s *LengthTwoOptionalDimensionContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *LengthTwoOptionalDimensionContext) AllDecimalLiteral() []IDecimalLiteralContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDecimalLiteralContext)(nil)).Elem())
	var tst = make([]IDecimalLiteralContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDecimalLiteralContext)
		}
	}

	return tst
}

func (s *LengthTwoOptionalDimensionContext) DecimalLiteral(i int) IDecimalLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDecimalLiteralContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *LengthTwoOptionalDimensionContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *LengthTwoOptionalDimensionContext) COMMA() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, 0)
}

func (s *LengthTwoOptionalDimensionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LengthTwoOptionalDimensionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LengthTwoOptionalDimensionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterLengthTwoOptionalDimension(s)
	}
}

func (s *LengthTwoOptionalDimensionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitLengthTwoOptionalDimension(s)
	}
}

func (s *LengthTwoOptionalDimensionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitLengthTwoOptionalDimension(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) LengthTwoOptionalDimension() (localctx ILengthTwoOptionalDimensionContext) {
	localctx = NewLengthTwoOptionalDimensionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, MySqlParserRULE_lengthTwoOptionalDimension)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(911)
		p.Match(MySqlParserLR_BRACKET)
	}
	{
		p.SetState(912)
		p.DecimalLiteral()
	}
	p.SetState(915)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserCOMMA {
		{
			p.SetState(913)
			p.Match(MySqlParserCOMMA)
		}
		{
			p.SetState(914)
			p.DecimalLiteral()
		}

	}
	{
		p.SetState(917)
		p.Match(MySqlParserRR_BRACKET)
	}

	return localctx
}

// IUidListContext is an interface to support dynamic dispatch.
type IUidListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUidListContext differentiates from other interfaces.
	IsUidListContext()
}

type UidListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUidListContext() *UidListContext {
	var p = new(UidListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_uidList
	return p
}

func (*UidListContext) IsUidListContext() {}

func NewUidListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UidListContext {
	var p = new(UidListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_uidList

	return p
}

func (s *UidListContext) GetParser() antlr.Parser { return s.parser }

func (s *UidListContext) AllUid() []IUidContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IUidContext)(nil)).Elem())
	var tst = make([]IUidContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IUidContext)
		}
	}

	return tst
}

func (s *UidListContext) Uid(i int) IUidContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUidContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IUidContext)
}

func (s *UidListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *UidListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *UidListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UidListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UidListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterUidList(s)
	}
}

func (s *UidListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitUidList(s)
	}
}

func (s *UidListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitUidList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) UidList() (localctx IUidListContext) {
	localctx = NewUidListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, MySqlParserRULE_uidList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(919)
		p.Uid()
	}
	p.SetState(924)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == MySqlParserCOMMA {
		{
			p.SetState(920)
			p.Match(MySqlParserCOMMA)
		}
		{
			p.SetState(921)
			p.Uid()
		}

		p.SetState(926)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IExpressionsContext is an interface to support dynamic dispatch.
type IExpressionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpressionsContext differentiates from other interfaces.
	IsExpressionsContext()
}

type ExpressionsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionsContext() *ExpressionsContext {
	var p = new(ExpressionsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_expressions
	return p
}

func (*ExpressionsContext) IsExpressionsContext() {}

func NewExpressionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionsContext {
	var p = new(ExpressionsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_expressions

	return p
}

func (s *ExpressionsContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionsContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *ExpressionsContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *ExpressionsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *ExpressionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterExpressions(s)
	}
}

func (s *ExpressionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitExpressions(s)
	}
}

func (s *ExpressionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitExpressions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) Expressions() (localctx IExpressionsContext) {
	localctx = NewExpressionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, MySqlParserRULE_expressions)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(927)
		p.expression(0)
	}
	p.SetState(932)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == MySqlParserCOMMA {
		{
			p.SetState(928)
			p.Match(MySqlParserCOMMA)
		}
		{
			p.SetState(929)
			p.expression(0)
		}

		p.SetState(934)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IIntervalTypeContext is an interface to support dynamic dispatch.
type IIntervalTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIntervalTypeContext differentiates from other interfaces.
	IsIntervalTypeContext()
}

type IntervalTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntervalTypeContext() *IntervalTypeContext {
	var p = new(IntervalTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_intervalType
	return p
}

func (*IntervalTypeContext) IsIntervalTypeContext() {}

func NewIntervalTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntervalTypeContext {
	var p = new(IntervalTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_intervalType

	return p
}

func (s *IntervalTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *IntervalTypeContext) IntervalTypeBase() IIntervalTypeBaseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntervalTypeBaseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntervalTypeBaseContext)
}

func (s *IntervalTypeContext) YEAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserYEAR, 0)
}

func (s *IntervalTypeContext) YEAR_MONTH() antlr.TerminalNode {
	return s.GetToken(MySqlParserYEAR_MONTH, 0)
}

func (s *IntervalTypeContext) DAY_HOUR() antlr.TerminalNode {
	return s.GetToken(MySqlParserDAY_HOUR, 0)
}

func (s *IntervalTypeContext) DAY_MINUTE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDAY_MINUTE, 0)
}

func (s *IntervalTypeContext) DAY_SECOND() antlr.TerminalNode {
	return s.GetToken(MySqlParserDAY_SECOND, 0)
}

func (s *IntervalTypeContext) HOUR_MINUTE() antlr.TerminalNode {
	return s.GetToken(MySqlParserHOUR_MINUTE, 0)
}

func (s *IntervalTypeContext) HOUR_SECOND() antlr.TerminalNode {
	return s.GetToken(MySqlParserHOUR_SECOND, 0)
}

func (s *IntervalTypeContext) MINUTE_SECOND() antlr.TerminalNode {
	return s.GetToken(MySqlParserMINUTE_SECOND, 0)
}

func (s *IntervalTypeContext) SECOND_MICROSECOND() antlr.TerminalNode {
	return s.GetToken(MySqlParserSECOND_MICROSECOND, 0)
}

func (s *IntervalTypeContext) MINUTE_MICROSECOND() antlr.TerminalNode {
	return s.GetToken(MySqlParserMINUTE_MICROSECOND, 0)
}

func (s *IntervalTypeContext) HOUR_MICROSECOND() antlr.TerminalNode {
	return s.GetToken(MySqlParserHOUR_MICROSECOND, 0)
}

func (s *IntervalTypeContext) DAY_MICROSECOND() antlr.TerminalNode {
	return s.GetToken(MySqlParserDAY_MICROSECOND, 0)
}

func (s *IntervalTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntervalTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntervalTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterIntervalType(s)
	}
}

func (s *IntervalTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitIntervalType(s)
	}
}

func (s *IntervalTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitIntervalType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) IntervalType() (localctx IIntervalTypeContext) {
	localctx = NewIntervalTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, MySqlParserRULE_intervalType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(948)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case MySqlParserQUARTER, MySqlParserMONTH, MySqlParserDAY, MySqlParserHOUR, MySqlParserMINUTE, MySqlParserWEEK, MySqlParserSECOND, MySqlParserMICROSECOND:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(935)
			p.IntervalTypeBase()
		}

	case MySqlParserYEAR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(936)
			p.Match(MySqlParserYEAR)
		}

	case MySqlParserYEAR_MONTH:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(937)
			p.Match(MySqlParserYEAR_MONTH)
		}

	case MySqlParserDAY_HOUR:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(938)
			p.Match(MySqlParserDAY_HOUR)
		}

	case MySqlParserDAY_MINUTE:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(939)
			p.Match(MySqlParserDAY_MINUTE)
		}

	case MySqlParserDAY_SECOND:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(940)
			p.Match(MySqlParserDAY_SECOND)
		}

	case MySqlParserHOUR_MINUTE:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(941)
			p.Match(MySqlParserHOUR_MINUTE)
		}

	case MySqlParserHOUR_SECOND:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(942)
			p.Match(MySqlParserHOUR_SECOND)
		}

	case MySqlParserMINUTE_SECOND:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(943)
			p.Match(MySqlParserMINUTE_SECOND)
		}

	case MySqlParserSECOND_MICROSECOND:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(944)
			p.Match(MySqlParserSECOND_MICROSECOND)
		}

	case MySqlParserMINUTE_MICROSECOND:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(945)
			p.Match(MySqlParserMINUTE_MICROSECOND)
		}

	case MySqlParserHOUR_MICROSECOND:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(946)
			p.Match(MySqlParserHOUR_MICROSECOND)
		}

	case MySqlParserDAY_MICROSECOND:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(947)
			p.Match(MySqlParserDAY_MICROSECOND)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IFunctionCallContext is an interface to support dynamic dispatch.
type IFunctionCallContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctionCallContext differentiates from other interfaces.
	IsFunctionCallContext()
}

type FunctionCallContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionCallContext() *FunctionCallContext {
	var p = new(FunctionCallContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_functionCall
	return p
}

func (*FunctionCallContext) IsFunctionCallContext() {}

func NewFunctionCallContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionCallContext {
	var p = new(FunctionCallContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_functionCall

	return p
}

func (s *FunctionCallContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionCallContext) CopyFrom(ctx *FunctionCallContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *FunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionCallContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SpecificFunctionCallContext struct {
	*FunctionCallContext
}

func NewSpecificFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SpecificFunctionCallContext {
	var p = new(SpecificFunctionCallContext)

	p.FunctionCallContext = NewEmptyFunctionCallContext()
	p.parser = parser
	p.CopyFrom(ctx.(*FunctionCallContext))

	return p
}

func (s *SpecificFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SpecificFunctionCallContext) SpecificFunction() ISpecificFunctionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpecificFunctionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISpecificFunctionContext)
}

func (s *SpecificFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSpecificFunctionCall(s)
	}
}

func (s *SpecificFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSpecificFunctionCall(s)
	}
}

func (s *SpecificFunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSpecificFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}

type PasswordFunctionCallContext struct {
	*FunctionCallContext
}

func NewPasswordFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PasswordFunctionCallContext {
	var p = new(PasswordFunctionCallContext)

	p.FunctionCallContext = NewEmptyFunctionCallContext()
	p.parser = parser
	p.CopyFrom(ctx.(*FunctionCallContext))

	return p
}

func (s *PasswordFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PasswordFunctionCallContext) PasswordFunctionClause() IPasswordFunctionClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPasswordFunctionClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPasswordFunctionClauseContext)
}

func (s *PasswordFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPasswordFunctionCall(s)
	}
}

func (s *PasswordFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPasswordFunctionCall(s)
	}
}

func (s *PasswordFunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitPasswordFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}

type UdfFunctionCallContext struct {
	*FunctionCallContext
}

func NewUdfFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UdfFunctionCallContext {
	var p = new(UdfFunctionCallContext)

	p.FunctionCallContext = NewEmptyFunctionCallContext()
	p.parser = parser
	p.CopyFrom(ctx.(*FunctionCallContext))

	return p
}

func (s *UdfFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UdfFunctionCallContext) FullId() IFullIdContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFullIdContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFullIdContext)
}

func (s *UdfFunctionCallContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *UdfFunctionCallContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *UdfFunctionCallContext) FunctionArgs() IFunctionArgsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionArgsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionArgsContext)
}

func (s *UdfFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterUdfFunctionCall(s)
	}
}

func (s *UdfFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitUdfFunctionCall(s)
	}
}

func (s *UdfFunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitUdfFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}

type AggregateFunctionCallContext struct {
	*FunctionCallContext
}

func NewAggregateFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AggregateFunctionCallContext {
	var p = new(AggregateFunctionCallContext)

	p.FunctionCallContext = NewEmptyFunctionCallContext()
	p.parser = parser
	p.CopyFrom(ctx.(*FunctionCallContext))

	return p
}

func (s *AggregateFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AggregateFunctionCallContext) AggregateWindowedFunction() IAggregateWindowedFunctionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAggregateWindowedFunctionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAggregateWindowedFunctionContext)
}

func (s *AggregateFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAggregateFunctionCall(s)
	}
}

func (s *AggregateFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAggregateFunctionCall(s)
	}
}

func (s *AggregateFunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAggregateFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}

type ScalarFunctionCallContext struct {
	*FunctionCallContext
}

func NewScalarFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ScalarFunctionCallContext {
	var p = new(ScalarFunctionCallContext)

	p.FunctionCallContext = NewEmptyFunctionCallContext()
	p.parser = parser
	p.CopyFrom(ctx.(*FunctionCallContext))

	return p
}

func (s *ScalarFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScalarFunctionCallContext) ScalarFunctionName() IScalarFunctionNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScalarFunctionNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IScalarFunctionNameContext)
}

func (s *ScalarFunctionCallContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *ScalarFunctionCallContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *ScalarFunctionCallContext) FunctionArgs() IFunctionArgsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionArgsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionArgsContext)
}

func (s *ScalarFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterScalarFunctionCall(s)
	}
}

func (s *ScalarFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitScalarFunctionCall(s)
	}
}

func (s *ScalarFunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitScalarFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) FunctionCall() (localctx IFunctionCallContext) {
	localctx = NewFunctionCallContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, MySqlParserRULE_functionCall)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(967)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 158, p.GetParserRuleContext()) {
	case 1:
		localctx = NewSpecificFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(950)
			p.SpecificFunction()
		}

	case 2:
		localctx = NewAggregateFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(951)
			p.AggregateWindowedFunction()
		}

	case 3:
		localctx = NewScalarFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(952)
			p.ScalarFunctionName()
		}
		{
			p.SetState(953)
			p.Match(MySqlParserLR_BRACKET)
		}
		p.SetState(955)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<MySqlParserCASE)|(1<<MySqlParserCAST)|(1<<MySqlParserCONVERT))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(MySqlParserCURRENT-32))|(1<<(MySqlParserCURRENT_USER-32))|(1<<(MySqlParserDATABASE-32))|(1<<(MySqlParserDIAGNOSTICS-32))|(1<<(MySqlParserEXISTS-32))|(1<<(MySqlParserFALSE-32)))) != 0) || (((_la-69)&-(0x1f+1)) == 0 && ((1<<uint((_la-69)))&((1<<(MySqlParserIF-69))|(1<<(MySqlParserINSERT-69))|(1<<(MySqlParserINTERVAL-69))|(1<<(MySqlParserLEFT-69)))) != 0) || (((_la-102)&-(0x1f+1)) == 0 && ((1<<uint((_la-102)))&((1<<(MySqlParserNOT-102))|(1<<(MySqlParserNULL_LITERAL-102))|(1<<(MySqlParserNUMBER-102))|(1<<(MySqlParserREPLACE-102))|(1<<(MySqlParserRIGHT-102)))) != 0) || (((_la-151)&-(0x1f+1)) == 0 && ((1<<uint((_la-151)))&((1<<(MySqlParserSTACKED-151))|(1<<(MySqlParserTRUE-151))|(1<<(MySqlParserVALUES-151)))) != 0) || (((_la-199)&-(0x1f+1)) == 0 && ((1<<uint((_la-199)))&((1<<(MySqlParserDATE-199))|(1<<(MySqlParserTIME-199))|(1<<(MySqlParserTIMESTAMP-199))|(1<<(MySqlParserDATETIME-199))|(1<<(MySqlParserYEAR-199))|(1<<(MySqlParserCHAR-199))|(1<<(MySqlParserBINARY-199))|(1<<(MySqlParserTEXT-199))|(1<<(MySqlParserENUM-199))|(1<<(MySqlParserSERIAL-199)))) != 0) || (((_la-233)&-(0x1f+1)) == 0 && ((1<<uint((_la-233)))&((1<<(MySqlParserJSON_VALID-233))|(1<<(MySqlParserJSON_SCHEMA_VALID-233))|(1<<(MySqlParserAVG-233))|(1<<(MySqlParserBIT_AND-233))|(1<<(MySqlParserBIT_OR-233))|(1<<(MySqlParserBIT_XOR-233))|(1<<(MySqlParserCOUNT-233))|(1<<(MySqlParserGROUP_CONCAT-233))|(1<<(MySqlParserMAX-233))|(1<<(MySqlParserMIN-233))|(1<<(MySqlParserSTD-233))|(1<<(MySqlParserSTDDEV-233))|(1<<(MySqlParserSTDDEV_POP-233))|(1<<(MySqlParserSTDDEV_SAMP-233))|(1<<(MySqlParserSUM-233))|(1<<(MySqlParserVAR_POP-233))|(1<<(MySqlParserVAR_SAMP-233))|(1<<(MySqlParserVARIANCE-233))|(1<<(MySqlParserCURRENT_DATE-233))|(1<<(MySqlParserCURRENT_TIME-233))|(1<<(MySqlParserCURRENT_TIMESTAMP-233))|(1<<(MySqlParserLOCALTIME-233))|(1<<(MySqlParserCURDATE-233))|(1<<(MySqlParserCURTIME-233))|(1<<(MySqlParserDATE_ADD-233))|(1<<(MySqlParserDATE_SUB-233))|(1<<(MySqlParserEXTRACT-233))|(1<<(MySqlParserLOCALTIMESTAMP-233))|(1<<(MySqlParserNOW-233))|(1<<(MySqlParserPOSITION-233))|(1<<(MySqlParserSUBSTR-233))|(1<<(MySqlParserSUBSTRING-233)))) != 0) || (((_la-265)&-(0x1f+1)) == 0 && ((1<<uint((_la-265)))&((1<<(MySqlParserSYSDATE-265))|(1<<(MySqlParserTRIM-265))|(1<<(MySqlParserUTC_DATE-265))|(1<<(MySqlParserUTC_TIME-265))|(1<<(MySqlParserUTC_TIMESTAMP-265))|(1<<(MySqlParserACCOUNT-265))|(1<<(MySqlParserACTION-265))|(1<<(MySqlParserAFTER-265))|(1<<(MySqlParserAGGREGATE-265))|(1<<(MySqlParserALGORITHM-265))|(1<<(MySqlParserANY-265))|(1<<(MySqlParserAT-265))|(1<<(MySqlParserAUTHORS-265))|(1<<(MySqlParserAUTOCOMMIT-265))|(1<<(MySqlParserAUTOEXTEND_SIZE-265))|(1<<(MySqlParserAUTO_INCREMENT-265))|(1<<(MySqlParserAVG_ROW_LENGTH-265))|(1<<(MySqlParserBEGIN-265))|(1<<(MySqlParserBINLOG-265))|(1<<(MySqlParserBIT-265))|(1<<(MySqlParserBLOCK-265))|(1<<(MySqlParserBOOL-265))|(1<<(MySqlParserBOOLEAN-265))|(1<<(MySqlParserBTREE-265))|(1<<(MySqlParserCACHE-265))|(1<<(MySqlParserCASCADED-265))|(1<<(MySqlParserCHAIN-265))|(1<<(MySqlParserCHANGED-265))|(1<<(MySqlParserCHANNEL-265))|(1<<(MySqlParserCHECKSUM-265))|(1<<(MySqlParserPAGE_CHECKSUM-265))|(1<<(MySqlParserCIPHER-265)))) != 0) || (((_la-297)&-(0x1f+1)) == 0 && ((1<<uint((_la-297)))&((1<<(MySqlParserCLASS_ORIGIN-297))|(1<<(MySqlParserCLIENT-297))|(1<<(MySqlParserCLOSE-297))|(1<<(MySqlParserCOALESCE-297))|(1<<(MySqlParserCODE-297))|(1<<(MySqlParserCOLUMNS-297))|(1<<(MySqlParserCOLUMN_FORMAT-297))|(1<<(MySqlParserCOLUMN_NAME-297))|(1<<(MySqlParserCOMMENT-297))|(1<<(MySqlParserCOMMIT-297))|(1<<(MySqlParserCOMPACT-297))|(1<<(MySqlParserCOMPLETION-297))|(1<<(MySqlParserCOMPRESSED-297))|(1<<(MySqlParserCOMPRESSION-297))|(1<<(MySqlParserCONCURRENT-297))|(1<<(MySqlParserCONNECTION-297))|(1<<(MySqlParserCONSISTENT-297))|(1<<(MySqlParserCONSTRAINT_CATALOG-297))|(1<<(MySqlParserCONSTRAINT_SCHEMA-297))|(1<<(MySqlParserCONSTRAINT_NAME-297))|(1<<(MySqlParserCONTAINS-297))|(1<<(MySqlParserCONTEXT-297))|(1<<(MySqlParserCONTRIBUTORS-297))|(1<<(MySqlParserCOPY-297))|(1<<(MySqlParserCPU-297))|(1<<(MySqlParserCURSOR_NAME-297))|(1<<(MySqlParserDATA-297))|(1<<(MySqlParserDATAFILE-297))|(1<<(MySqlParserDEALLOCATE-297))|(1<<(MySqlParserDEFAULT_AUTH-297))|(1<<(MySqlParserDEFINER-297))|(1<<(MySqlParserDELAY_KEY_WRITE-297)))) != 0) || (((_la-329)&-(0x1f+1)) == 0 && ((1<<uint((_la-329)))&((1<<(MySqlParserDES_KEY_FILE-329))|(1<<(MySqlParserDIRECTORY-329))|(1<<(MySqlParserDISABLE-329))|(1<<(MySqlParserDISCARD-329))|(1<<(MySqlParserDISK-329))|(1<<(MySqlParserDO-329))|(1<<(MySqlParserDUMPFILE-329))|(1<<(MySqlParserDUPLICATE-329))|(1<<(MySqlParserDYNAMIC-329))|(1<<(MySqlParserENABLE-329))|(1<<(MySqlParserENCRYPTION-329))|(1<<(MySqlParserEND-329))|(1<<(MySqlParserENDS-329))|(1<<(MySqlParserENGINE-329))|(1<<(MySqlParserENGINES-329))|(1<<(MySqlParserERROR-329))|(1<<(MySqlParserERRORS-329))|(1<<(MySqlParserESCAPE-329))|(1<<(MySqlParserEVEN-329))|(1<<(MySqlParserEVENT-329))|(1<<(MySqlParserEVENTS-329))|(1<<(MySqlParserEVERY-329))|(1<<(MySqlParserEXCHANGE-329))|(1<<(MySqlParserEXCLUSIVE-329))|(1<<(MySqlParserEXPIRE-329))|(1<<(MySqlParserEXPORT-329))|(1<<(MySqlParserEXTENDED-329))|(1<<(MySqlParserEXTENT_SIZE-329))|(1<<(MySqlParserFAST-329))|(1<<(MySqlParserFAULTS-329))|(1<<(MySqlParserFIELDS-329))|(1<<(MySqlParserFILE_BLOCK_SIZE-329)))) != 0) || (((_la-361)&-(0x1f+1)) == 0 && ((1<<uint((_la-361)))&((1<<(MySqlParserFILTER-361))|(1<<(MySqlParserFIRST-361))|(1<<(MySqlParserFIXED-361))|(1<<(MySqlParserFLUSH-361))|(1<<(MySqlParserFOLLOWS-361))|(1<<(MySqlParserFOUND-361))|(1<<(MySqlParserFULL-361))|(1<<(MySqlParserFUNCTION-361))|(1<<(MySqlParserGENERAL-361))|(1<<(MySqlParserGLOBAL-361))|(1<<(MySqlParserGRANTS-361))|(1<<(MySqlParserGROUP_REPLICATION-361))|(1<<(MySqlParserHANDLER-361))|(1<<(MySqlParserHASH-361))|(1<<(MySqlParserHELP-361))|(1<<(MySqlParserHOST-361))|(1<<(MySqlParserHOSTS-361))|(1<<(MySqlParserIDENTIFIED-361))|(1<<(MySqlParserIGNORE_SERVER_IDS-361))|(1<<(MySqlParserIMPORT-361))|(1<<(MySqlParserINDEXES-361))|(1<<(MySqlParserINITIAL_SIZE-361))|(1<<(MySqlParserINPLACE-361))|(1<<(MySqlParserINSERT_METHOD-361))|(1<<(MySqlParserINSTALL-361))|(1<<(MySqlParserINSTANCE-361))|(1<<(MySqlParserINVISIBLE-361))|(1<<(MySqlParserINVOKER-361))|(1<<(MySqlParserIO-361))|(1<<(MySqlParserIO_THREAD-361))|(1<<(MySqlParserIPC-361))|(1<<(MySqlParserISOLATION-361)))) != 0) || (((_la-393)&-(0x1f+1)) == 0 && ((1<<uint((_la-393)))&((1<<(MySqlParserISSUER-393))|(1<<(MySqlParserJSON-393))|(1<<(MySqlParserKEY_BLOCK_SIZE-393))|(1<<(MySqlParserLANGUAGE-393))|(1<<(MySqlParserLAST-393))|(1<<(MySqlParserLEAVES-393))|(1<<(MySqlParserLESS-393))|(1<<(MySqlParserLEVEL-393))|(1<<(MySqlParserLIST-393))|(1<<(MySqlParserLOCAL-393))|(1<<(MySqlParserLOGFILE-393))|(1<<(MySqlParserLOGS-393))|(1<<(MySqlParserMASTER-393))|(1<<(MySqlParserMASTER_AUTO_POSITION-393))|(1<<(MySqlParserMASTER_CONNECT_RETRY-393))|(1<<(MySqlParserMASTER_DELAY-393))|(1<<(MySqlParserMASTER_HEARTBEAT_PERIOD-393))|(1<<(MySqlParserMASTER_HOST-393))|(1<<(MySqlParserMASTER_LOG_FILE-393))|(1<<(MySqlParserMASTER_LOG_POS-393))|(1<<(MySqlParserMASTER_PASSWORD-393))|(1<<(MySqlParserMASTER_PORT-393))|(1<<(MySqlParserMASTER_RETRY_COUNT-393))|(1<<(MySqlParserMASTER_SSL-393))|(1<<(MySqlParserMASTER_SSL_CA-393))|(1<<(MySqlParserMASTER_SSL_CAPATH-393))|(1<<(MySqlParserMASTER_SSL_CERT-393))|(1<<(MySqlParserMASTER_SSL_CIPHER-393))|(1<<(MySqlParserMASTER_SSL_CRL-393))|(1<<(MySqlParserMASTER_SSL_CRLPATH-393))|(1<<(MySqlParserMASTER_SSL_KEY-393))|(1<<(MySqlParserMASTER_TLS_VERSION-393)))) != 0) || (((_la-425)&-(0x1f+1)) == 0 && ((1<<uint((_la-425)))&((1<<(MySqlParserMASTER_USER-425))|(1<<(MySqlParserMAX_CONNECTIONS_PER_HOUR-425))|(1<<(MySqlParserMAX_QUERIES_PER_HOUR-425))|(1<<(MySqlParserMAX_ROWS-425))|(1<<(MySqlParserMAX_SIZE-425))|(1<<(MySqlParserMAX_UPDATES_PER_HOUR-425))|(1<<(MySqlParserMAX_USER_CONNECTIONS-425))|(1<<(MySqlParserMEDIUM-425))|(1<<(MySqlParserMEMBER-425))|(1<<(MySqlParserMERGE-425))|(1<<(MySqlParserMESSAGE_TEXT-425))|(1<<(MySqlParserMID-425))|(1<<(MySqlParserMIGRATE-425))|(1<<(MySqlParserMIN_ROWS-425))|(1<<(MySqlParserMODE-425))|(1<<(MySqlParserMODIFY-425))|(1<<(MySqlParserMUTEX-425))|(1<<(MySqlParserMYSQL-425))|(1<<(MySqlParserMYSQL_ERRNO-425))|(1<<(MySqlParserNAME-425))|(1<<(MySqlParserNAMES-425))|(1<<(MySqlParserNCHAR-425))|(1<<(MySqlParserNEVER-425))|(1<<(MySqlParserNEXT-425))|(1<<(MySqlParserNO-425))|(1<<(MySqlParserNODEGROUP-425))|(1<<(MySqlParserNONE-425))|(1<<(MySqlParserOFFLINE-425))|(1<<(MySqlParserOFFSET-425))|(1<<(MySqlParserOF-425))|(1<<(MySqlParserOJ-425))|(1<<(MySqlParserOLD_PASSWORD-425)))) != 0) || (((_la-457)&-(0x1f+1)) == 0 && ((1<<uint((_la-457)))&((1<<(MySqlParserONE-457))|(1<<(MySqlParserONLINE-457))|(1<<(MySqlParserONLY-457))|(1<<(MySqlParserOPEN-457))|(1<<(MySqlParserOPTIMIZER_COSTS-457))|(1<<(MySqlParserOPTIONS-457))|(1<<(MySqlParserOWNER-457))|(1<<(MySqlParserPACK_KEYS-457))|(1<<(MySqlParserPAGE-457))|(1<<(MySqlParserPARSER-457))|(1<<(MySqlParserPARTIAL-457))|(1<<(MySqlParserPARTITIONING-457))|(1<<(MySqlParserPARTITIONS-457))|(1<<(MySqlParserPASSWORD-457))|(1<<(MySqlParserPHASE-457))|(1<<(MySqlParserPLUGIN-457))|(1<<(MySqlParserPLUGIN_DIR-457))|(1<<(MySqlParserPLUGINS-457))|(1<<(MySqlParserPORT-457))|(1<<(MySqlParserPRECEDES-457))|(1<<(MySqlParserPREPARE-457))|(1<<(MySqlParserPRESERVE-457))|(1<<(MySqlParserPREV-457))|(1<<(MySqlParserPROCESSLIST-457))|(1<<(MySqlParserPROFILE-457))|(1<<(MySqlParserPROFILES-457))|(1<<(MySqlParserPROXY-457))|(1<<(MySqlParserQUERY-457))|(1<<(MySqlParserQUICK-457))|(1<<(MySqlParserREBUILD-457))|(1<<(MySqlParserRECOVER-457))|(1<<(MySqlParserREDO_BUFFER_SIZE-457)))) != 0) || (((_la-489)&-(0x1f+1)) == 0 && ((1<<uint((_la-489)))&((1<<(MySqlParserREDUNDANT-489))|(1<<(MySqlParserRELAY-489))|(1<<(MySqlParserRELAY_LOG_FILE-489))|(1<<(MySqlParserRELAY_LOG_POS-489))|(1<<(MySqlParserRELAYLOG-489))|(1<<(MySqlParserREMOVE-489))|(1<<(MySqlParserREORGANIZE-489))|(1<<(MySqlParserREPAIR-489))|(1<<(MySqlParserREPLICATE_DO_DB-489))|(1<<(MySqlParserREPLICATE_DO_TABLE-489))|(1<<(MySqlParserREPLICATE_IGNORE_DB-489))|(1<<(MySqlParserREPLICATE_IGNORE_TABLE-489))|(1<<(MySqlParserREPLICATE_REWRITE_DB-489))|(1<<(MySqlParserREPLICATE_WILD_DO_TABLE-489))|(1<<(MySqlParserREPLICATE_WILD_IGNORE_TABLE-489))|(1<<(MySqlParserREPLICATION-489))|(1<<(MySqlParserRESET-489))|(1<<(MySqlParserRESUME-489))|(1<<(MySqlParserRETURNED_SQLSTATE-489))|(1<<(MySqlParserRETURNS-489))|(1<<(MySqlParserROLE-489))|(1<<(MySqlParserROLLBACK-489))|(1<<(MySqlParserROLLUP-489))|(1<<(MySqlParserROTATE-489))|(1<<(MySqlParserROW-489))|(1<<(MySqlParserROWS-489))|(1<<(MySqlParserROW_FORMAT-489))|(1<<(MySqlParserSAVEPOINT-489))|(1<<(MySqlParserSCHEDULE-489))|(1<<(MySqlParserSECURITY-489))|(1<<(MySqlParserSERVER-489))|(1<<(MySqlParserSESSION-489)))) != 0) || (((_la-521)&-(0x1f+1)) == 0 && ((1<<uint((_la-521)))&((1<<(MySqlParserSHARE-521))|(1<<(MySqlParserSHARED-521))|(1<<(MySqlParserSIGNED-521))|(1<<(MySqlParserSIMPLE-521))|(1<<(MySqlParserSLAVE-521))|(1<<(MySqlParserSLOW-521))|(1<<(MySqlParserSNAPSHOT-521))|(1<<(MySqlParserSOCKET-521))|(1<<(MySqlParserSOME-521))|(1<<(MySqlParserSONAME-521))|(1<<(MySqlParserSOUNDS-521))|(1<<(MySqlParserSOURCE-521))|(1<<(MySqlParserSQL_AFTER_GTIDS-521))|(1<<(MySqlParserSQL_AFTER_MTS_GAPS-521))|(1<<(MySqlParserSQL_BEFORE_GTIDS-521))|(1<<(MySqlParserSQL_BUFFER_RESULT-521))|(1<<(MySqlParserSQL_CACHE-521))|(1<<(MySqlParserSQL_NO_CACHE-521))|(1<<(MySqlParserSQL_THREAD-521))|(1<<(MySqlParserSTART-521))|(1<<(MySqlParserSTARTS-521))|(1<<(MySqlParserSTATS_AUTO_RECALC-521))|(1<<(MySqlParserSTATS_PERSISTENT-521))|(1<<(MySqlParserSTATS_SAMPLE_PAGES-521))|(1<<(MySqlParserSTATUS-521))|(1<<(MySqlParserSTOP-521))|(1<<(MySqlParserSTORAGE-521))|(1<<(MySqlParserSTRING-521))|(1<<(MySqlParserSUBCLASS_ORIGIN-521))|(1<<(MySqlParserSUBJECT-521))|(1<<(MySqlParserSUBPARTITION-521)))) != 0) || (((_la-553)&-(0x1f+1)) == 0 && ((1<<uint((_la-553)))&((1<<(MySqlParserSUBPARTITIONS-553))|(1<<(MySqlParserSUSPEND-553))|(1<<(MySqlParserSWAPS-553))|(1<<(MySqlParserSWITCHES-553))|(1<<(MySqlParserTABLE_NAME-553))|(1<<(MySqlParserTABLESPACE-553))|(1<<(MySqlParserTEMPORARY-553))|(1<<(MySqlParserTEMPTABLE-553))|(1<<(MySqlParserTHAN-553))|(1<<(MySqlParserTRADITIONAL-553))|(1<<(MySqlParserTRANSACTION-553))|(1<<(MySqlParserTRANSACTIONAL-553))|(1<<(MySqlParserTRIGGERS-553))|(1<<(MySqlParserTRUNCATE-553))|(1<<(MySqlParserUNDEFINED-553))|(1<<(MySqlParserUNDOFILE-553))|(1<<(MySqlParserUNDO_BUFFER_SIZE-553))|(1<<(MySqlParserUNINSTALL-553))|(1<<(MySqlParserUNKNOWN-553))|(1<<(MySqlParserUNTIL-553))|(1<<(MySqlParserUPGRADE-553))|(1<<(MySqlParserUSER-553))|(1<<(MySqlParserUSE_FRM-553))|(1<<(MySqlParserUSER_RESOURCES-553))|(1<<(MySqlParserVALIDATION-553))|(1<<(MySqlParserVALUE-553))|(1<<(MySqlParserVARIABLES-553))|(1<<(MySqlParserVIEW-553))|(1<<(MySqlParserVISIBLE-553))|(1<<(MySqlParserWAIT-553))|(1<<(MySqlParserWARNINGS-553)))) != 0) || (((_la-585)&-(0x1f+1)) == 0 && ((1<<uint((_la-585)))&((1<<(MySqlParserWITHOUT-585))|(1<<(MySqlParserWORK-585))|(1<<(MySqlParserWRAPPER-585))|(1<<(MySqlParserX509-585))|(1<<(MySqlParserXA-585))|(1<<(MySqlParserXML-585))|(1<<(MySqlParserINTERNAL-585))|(1<<(MySqlParserQUARTER-585))|(1<<(MySqlParserMONTH-585))|(1<<(MySqlParserDAY-585))|(1<<(MySqlParserHOUR-585))|(1<<(MySqlParserMINUTE-585))|(1<<(MySqlParserWEEK-585))|(1<<(MySqlParserSECOND-585))|(1<<(MySqlParserMICROSECOND-585))|(1<<(MySqlParserTABLES-585))|(1<<(MySqlParserROUTINE-585))|(1<<(MySqlParserEXECUTE-585))|(1<<(MySqlParserFILE-585))|(1<<(MySqlParserPROCESS-585))|(1<<(MySqlParserRELOAD-585))|(1<<(MySqlParserSHUTDOWN-585))|(1<<(MySqlParserSUPER-585))|(1<<(MySqlParserPRIVILEGES-585))|(1<<(MySqlParserAUDIT_ADMIN-585))|(1<<(MySqlParserBACKUP_ADMIN-585))|(1<<(MySqlParserBINLOG_ADMIN-585)))) != 0) || (((_la-617)&-(0x1f+1)) == 0 && ((1<<uint((_la-617)))&((1<<(MySqlParserBINLOG_ENCRYPTION_ADMIN-617))|(1<<(MySqlParserCLONE_ADMIN-617))|(1<<(MySqlParserCONNECTION_ADMIN-617))|(1<<(MySqlParserENCRYPTION_KEY_ADMIN-617))|(1<<(MySqlParserFIREWALL_ADMIN-617))|(1<<(MySqlParserFIREWALL_USER-617))|(1<<(MySqlParserGROUP_REPLICATION_ADMIN-617))|(1<<(MySqlParserINNODB_REDO_LOG_ARCHIVE-617))|(1<<(MySqlParserNDB_STORED_USER-617))|(1<<(MySqlParserPERSIST_RO_VARIABLES_ADMIN-617))|(1<<(MySqlParserREPLICATION_APPLIER-617))|(1<<(MySqlParserREPLICATION_SLAVE_ADMIN-617))|(1<<(MySqlParserRESOURCE_GROUP_ADMIN-617))|(1<<(MySqlParserRESOURCE_GROUP_USER-617))|(1<<(MySqlParserROLE_ADMIN-617))|(1<<(MySqlParserSESSION_VARIABLES_ADMIN-617))|(1<<(MySqlParserSET_USER_ID-617))|(1<<(MySqlParserSHOW_ROUTINE-617))|(1<<(MySqlParserSYSTEM_VARIABLES_ADMIN-617))|(1<<(MySqlParserTABLE_ENCRYPTION_ADMIN-617))|(1<<(MySqlParserVERSION_TOKEN_ADMIN-617))|(1<<(MySqlParserXA_RECOVER_ADMIN-617))|(1<<(MySqlParserARMSCII8-617))|(1<<(MySqlParserASCII-617))|(1<<(MySqlParserBIG5-617))|(1<<(MySqlParserCP1250-617))|(1<<(MySqlParserCP1251-617))|(1<<(MySqlParserCP1256-617))|(1<<(MySqlParserCP1257-617))|(1<<(MySqlParserCP850-617))|(1<<(MySqlParserCP852-617))|(1<<(MySqlParserCP866-617)))) != 0) || (((_la-649)&-(0x1f+1)) == 0 && ((1<<uint((_la-649)))&((1<<(MySqlParserCP932-649))|(1<<(MySqlParserDEC8-649))|(1<<(MySqlParserEUCJPMS-649))|(1<<(MySqlParserEUCKR-649))|(1<<(MySqlParserGB2312-649))|(1<<(MySqlParserGBK-649))|(1<<(MySqlParserGEOSTD8-649))|(1<<(MySqlParserGREEK-649))|(1<<(MySqlParserHEBREW-649))|(1<<(MySqlParserHP8-649))|(1<<(MySqlParserKEYBCS2-649))|(1<<(MySqlParserKOI8R-649))|(1<<(MySqlParserKOI8U-649))|(1<<(MySqlParserLATIN1-649))|(1<<(MySqlParserLATIN2-649))|(1<<(MySqlParserLATIN5-649))|(1<<(MySqlParserLATIN7-649))|(1<<(MySqlParserMACCE-649))|(1<<(MySqlParserMACROMAN-649))|(1<<(MySqlParserSJIS-649))|(1<<(MySqlParserSWE7-649))|(1<<(MySqlParserTIS620-649))|(1<<(MySqlParserUCS2-649))|(1<<(MySqlParserUJIS-649))|(1<<(MySqlParserUTF16-649))|(1<<(MySqlParserUTF16LE-649))|(1<<(MySqlParserUTF32-649))|(1<<(MySqlParserUTF8-649))|(1<<(MySqlParserUTF8MB3-649))|(1<<(MySqlParserUTF8MB4-649))|(1<<(MySqlParserARCHIVE-649))|(1<<(MySqlParserBLACKHOLE-649)))) != 0) || (((_la-681)&-(0x1f+1)) == 0 && ((1<<uint((_la-681)))&((1<<(MySqlParserCSV-681))|(1<<(MySqlParserFEDERATED-681))|(1<<(MySqlParserINNODB-681))|(1<<(MySqlParserMEMORY-681))|(1<<(MySqlParserMRG_MYISAM-681))|(1<<(MySqlParserMYISAM-681))|(1<<(MySqlParserNDB-681))|(1<<(MySqlParserNDBCLUSTER-681))|(1<<(MySqlParserPERFORMANCE_SCHEMA-681))|(1<<(MySqlParserTOKUDB-681))|(1<<(MySqlParserREPEATABLE-681))|(1<<(MySqlParserCOMMITTED-681))|(1<<(MySqlParserUNCOMMITTED-681))|(1<<(MySqlParserSERIALIZABLE-681))|(1<<(MySqlParserGEOMETRYCOLLECTION-681))|(1<<(MySqlParserLINESTRING-681))|(1<<(MySqlParserMULTILINESTRING-681))|(1<<(MySqlParserMULTIPOINT-681))|(1<<(MySqlParserMULTIPOLYGON-681))|(1<<(MySqlParserPOINT-681))|(1<<(MySqlParserPOLYGON-681))|(1<<(MySqlParserABS-681))|(1<<(MySqlParserACOS-681))|(1<<(MySqlParserADDDATE-681))|(1<<(MySqlParserADDTIME-681))|(1<<(MySqlParserAES_DECRYPT-681))|(1<<(MySqlParserAES_ENCRYPT-681))|(1<<(MySqlParserAREA-681))|(1<<(MySqlParserASBINARY-681))|(1<<(MySqlParserASIN-681)))) != 0) || (((_la-713)&-(0x1f+1)) == 0 && ((1<<uint((_la-713)))&((1<<(MySqlParserASTEXT-713))|(1<<(MySqlParserASWKB-713))|(1<<(MySqlParserASWKT-713))|(1<<(MySqlParserASYMMETRIC_DECRYPT-713))|(1<<(MySqlParserASYMMETRIC_DERIVE-713))|(1<<(MySqlParserASYMMETRIC_ENCRYPT-713))|(1<<(MySqlParserASYMMETRIC_SIGN-713))|(1<<(MySqlParserASYMMETRIC_VERIFY-713))|(1<<(MySqlParserATAN-713))|(1<<(MySqlParserATAN2-713))|(1<<(MySqlParserBENCHMARK-713))|(1<<(MySqlParserBIN-713))|(1<<(MySqlParserBIT_COUNT-713))|(1<<(MySqlParserBIT_LENGTH-713))|(1<<(MySqlParserBUFFER-713))|(1<<(MySqlParserCATALOG_NAME-713))|(1<<(MySqlParserCEIL-713))|(1<<(MySqlParserCEILING-713))|(1<<(MySqlParserCENTROID-713))|(1<<(MySqlParserCHARACTER_LENGTH-713))|(1<<(MySqlParserCHARSET-713))|(1<<(MySqlParserCHAR_LENGTH-713))|(1<<(MySqlParserCOERCIBILITY-713))|(1<<(MySqlParserCOLLATION-713))|(1<<(MySqlParserCOMPRESS-713))|(1<<(MySqlParserCONCAT-713))|(1<<(MySqlParserCONCAT_WS-713))|(1<<(MySqlParserCONNECTION_ID-713))|(1<<(MySqlParserCONV-713))|(1<<(MySqlParserCONVERT_TZ-713))|(1<<(MySqlParserCOS-713))|(1<<(MySqlParserCOT-713)))) != 0) || (((_la-745)&-(0x1f+1)) == 0 && ((1<<uint((_la-745)))&((1<<(MySqlParserCRC32-745))|(1<<(MySqlParserCREATE_ASYMMETRIC_PRIV_KEY-745))|(1<<(MySqlParserCREATE_ASYMMETRIC_PUB_KEY-745))|(1<<(MySqlParserCREATE_DH_PARAMETERS-745))|(1<<(MySqlParserCREATE_DIGEST-745))|(1<<(MySqlParserCROSSES-745))|(1<<(MySqlParserDATEDIFF-745))|(1<<(MySqlParserDATE_FORMAT-745))|(1<<(MySqlParserDAYNAME-745))|(1<<(MySqlParserDAYOFMONTH-745))|(1<<(MySqlParserDAYOFWEEK-745))|(1<<(MySqlParserDAYOFYEAR-745))|(1<<(MySqlParserDECODE-745))|(1<<(MySqlParserDEGREES-745))|(1<<(MySqlParserDES_DECRYPT-745))|(1<<(MySqlParserDES_ENCRYPT-745))|(1<<(MySqlParserDIMENSION-745))|(1<<(MySqlParserDISJOINT-745))|(1<<(MySqlParserELT-745))|(1<<(MySqlParserENCODE-745))|(1<<(MySqlParserENCRYPT-745))|(1<<(MySqlParserENDPOINT-745))|(1<<(MySqlParserENVELOPE-745))|(1<<(MySqlParserEQUALS-745))|(1<<(MySqlParserEXP-745))|(1<<(MySqlParserEXPORT_SET-745))|(1<<(MySqlParserEXTERIORRING-745))|(1<<(MySqlParserEXTRACTVALUE-745))|(1<<(MySqlParserFIELD-745))|(1<<(MySqlParserFIND_IN_SET-745))|(1<<(MySqlParserFLOOR-745))|(1<<(MySqlParserFORMAT-745)))) != 0) || (((_la-777)&-(0x1f+1)) == 0 && ((1<<uint((_la-777)))&((1<<(MySqlParserFOUND_ROWS-777))|(1<<(MySqlParserFROM_BASE64-777))|(1<<(MySqlParserFROM_DAYS-777))|(1<<(MySqlParserFROM_UNIXTIME-777))|(1<<(MySqlParserGEOMCOLLFROMTEXT-777))|(1<<(MySqlParserGEOMCOLLFROMWKB-777))|(1<<(MySqlParserGEOMETRYCOLLECTIONFROMTEXT-777))|(1<<(MySqlParserGEOMETRYCOLLECTIONFROMWKB-777))|(1<<(MySqlParserGEOMETRYFROMTEXT-777))|(1<<(MySqlParserGEOMETRYFROMWKB-777))|(1<<(MySqlParserGEOMETRYN-777))|(1<<(MySqlParserGEOMETRYTYPE-777))|(1<<(MySqlParserGEOMFROMTEXT-777))|(1<<(MySqlParserGEOMFROMWKB-777))|(1<<(MySqlParserGET_FORMAT-777))|(1<<(MySqlParserGET_LOCK-777))|(1<<(MySqlParserGLENGTH-777))|(1<<(MySqlParserGREATEST-777))|(1<<(MySqlParserGTID_SUBSET-777))|(1<<(MySqlParserGTID_SUBTRACT-777))|(1<<(MySqlParserHEX-777))|(1<<(MySqlParserIFNULL-777))|(1<<(MySqlParserINET6_ATON-777))|(1<<(MySqlParserINET6_NTOA-777))|(1<<(MySqlParserINET_ATON-777))|(1<<(MySqlParserINET_NTOA-777))|(1<<(MySqlParserINSTR-777))|(1<<(MySqlParserINTERIORRINGN-777))|(1<<(MySqlParserINTERSECTS-777))|(1<<(MySqlParserISCLOSED-777))|(1<<(MySqlParserISEMPTY-777))|(1<<(MySqlParserISNULL-777)))) != 0) || (((_la-809)&-(0x1f+1)) == 0 && ((1<<uint((_la-809)))&((1<<(MySqlParserISSIMPLE-809))|(1<<(MySqlParserIS_FREE_LOCK-809))|(1<<(MySqlParserIS_IPV4-809))|(1<<(MySqlParserIS_IPV4_COMPAT-809))|(1<<(MySqlParserIS_IPV4_MAPPED-809))|(1<<(MySqlParserIS_IPV6-809))|(1<<(MySqlParserIS_USED_LOCK-809))|(1<<(MySqlParserLAST_INSERT_ID-809))|(1<<(MySqlParserLCASE-809))|(1<<(MySqlParserLEAST-809))|(1<<(MySqlParserLENGTH-809))|(1<<(MySqlParserLINEFROMTEXT-809))|(1<<(MySqlParserLINEFROMWKB-809))|(1<<(MySqlParserLINESTRINGFROMTEXT-809))|(1<<(MySqlParserLINESTRINGFROMWKB-809))|(1<<(MySqlParserLN-809))|(1<<(MySqlParserLOAD_FILE-809))|(1<<(MySqlParserLOCATE-809))|(1<<(MySqlParserLOG-809))|(1<<(MySqlParserLOG10-809))|(1<<(MySqlParserLOG2-809))|(1<<(MySqlParserLOWER-809))|(1<<(MySqlParserLPAD-809))|(1<<(MySqlParserLTRIM-809))|(1<<(MySqlParserMAKEDATE-809))|(1<<(MySqlParserMAKETIME-809))|(1<<(MySqlParserMAKE_SET-809))|(1<<(MySqlParserMASTER_POS_WAIT-809))|(1<<(MySqlParserMBRCONTAINS-809))|(1<<(MySqlParserMBRDISJOINT-809))|(1<<(MySqlParserMBREQUAL-809))|(1<<(MySqlParserMBRINTERSECTS-809)))) != 0) || (((_la-841)&-(0x1f+1)) == 0 && ((1<<uint((_la-841)))&((1<<(MySqlParserMBROVERLAPS-841))|(1<<(MySqlParserMBRTOUCHES-841))|(1<<(MySqlParserMBRWITHIN-841))|(1<<(MySqlParserMD5-841))|(1<<(MySqlParserMLINEFROMTEXT-841))|(1<<(MySqlParserMLINEFROMWKB-841))|(1<<(MySqlParserMONTHNAME-841))|(1<<(MySqlParserMPOINTFROMTEXT-841))|(1<<(MySqlParserMPOINTFROMWKB-841))|(1<<(MySqlParserMPOLYFROMTEXT-841))|(1<<(MySqlParserMPOLYFROMWKB-841))|(1<<(MySqlParserMULTILINESTRINGFROMTEXT-841))|(1<<(MySqlParserMULTILINESTRINGFROMWKB-841))|(1<<(MySqlParserMULTIPOINTFROMTEXT-841))|(1<<(MySqlParserMULTIPOINTFROMWKB-841))|(1<<(MySqlParserMULTIPOLYGONFROMTEXT-841))|(1<<(MySqlParserMULTIPOLYGONFROMWKB-841))|(1<<(MySqlParserNAME_CONST-841))|(1<<(MySqlParserNULLIF-841))|(1<<(MySqlParserNUMGEOMETRIES-841))|(1<<(MySqlParserNUMINTERIORRINGS-841))|(1<<(MySqlParserNUMPOINTS-841))|(1<<(MySqlParserOCT-841))|(1<<(MySqlParserOCTET_LENGTH-841))|(1<<(MySqlParserORD-841))|(1<<(MySqlParserOVERLAPS-841))|(1<<(MySqlParserPERIOD_ADD-841))|(1<<(MySqlParserPERIOD_DIFF-841))|(1<<(MySqlParserPI-841))|(1<<(MySqlParserPOINTFROMTEXT-841))|(1<<(MySqlParserPOINTFROMWKB-841))|(1<<(MySqlParserPOINTN-841)))) != 0) || (((_la-873)&-(0x1f+1)) == 0 && ((1<<uint((_la-873)))&((1<<(MySqlParserPOLYFROMTEXT-873))|(1<<(MySqlParserPOLYFROMWKB-873))|(1<<(MySqlParserPOLYGONFROMTEXT-873))|(1<<(MySqlParserPOLYGONFROMWKB-873))|(1<<(MySqlParserPOW-873))|(1<<(MySqlParserPOWER-873))|(1<<(MySqlParserQUOTE-873))|(1<<(MySqlParserRADIANS-873))|(1<<(MySqlParserRAND-873))|(1<<(MySqlParserRANDOM_BYTES-873))|(1<<(MySqlParserRELEASE_LOCK-873))|(1<<(MySqlParserREVERSE-873))|(1<<(MySqlParserROUND-873))|(1<<(MySqlParserROW_COUNT-873))|(1<<(MySqlParserRPAD-873))|(1<<(MySqlParserRTRIM-873))|(1<<(MySqlParserSEC_TO_TIME-873))|(1<<(MySqlParserSESSION_USER-873))|(1<<(MySqlParserSHA-873))|(1<<(MySqlParserSHA1-873))|(1<<(MySqlParserSHA2-873))|(1<<(MySqlParserSCHEMA_NAME-873))|(1<<(MySqlParserSIGN-873))|(1<<(MySqlParserSIN-873))|(1<<(MySqlParserSLEEP-873))|(1<<(MySqlParserSOUNDEX-873))|(1<<(MySqlParserSQL_THREAD_WAIT_AFTER_GTIDS-873))|(1<<(MySqlParserSQRT-873))|(1<<(MySqlParserSRID-873))|(1<<(MySqlParserSTARTPOINT-873))|(1<<(MySqlParserSTRCMP-873))|(1<<(MySqlParserSTR_TO_DATE-873)))) != 0) || (((_la-905)&-(0x1f+1)) == 0 && ((1<<uint((_la-905)))&((1<<(MySqlParserST_AREA-905))|(1<<(MySqlParserST_ASBINARY-905))|(1<<(MySqlParserST_ASTEXT-905))|(1<<(MySqlParserST_ASWKB-905))|(1<<(MySqlParserST_ASWKT-905))|(1<<(MySqlParserST_BUFFER-905))|(1<<(MySqlParserST_CENTROID-905))|(1<<(MySqlParserST_CONTAINS-905))|(1<<(MySqlParserST_CROSSES-905))|(1<<(MySqlParserST_DIFFERENCE-905))|(1<<(MySqlParserST_DIMENSION-905))|(1<<(MySqlParserST_DISJOINT-905))|(1<<(MySqlParserST_DISTANCE-905))|(1<<(MySqlParserST_ENDPOINT-905))|(1<<(MySqlParserST_ENVELOPE-905))|(1<<(MySqlParserST_EQUALS-905))|(1<<(MySqlParserST_EXTERIORRING-905))|(1<<(MySqlParserST_GEOMCOLLFROMTEXT-905))|(1<<(MySqlParserST_GEOMCOLLFROMTXT-905))|(1<<(MySqlParserST_GEOMCOLLFROMWKB-905))|(1<<(MySqlParserST_GEOMETRYCOLLECTIONFROMTEXT-905))|(1<<(MySqlParserST_GEOMETRYCOLLECTIONFROMWKB-905))|(1<<(MySqlParserST_GEOMETRYFROMTEXT-905))|(1<<(MySqlParserST_GEOMETRYFROMWKB-905))|(1<<(MySqlParserST_GEOMETRYN-905))|(1<<(MySqlParserST_GEOMETRYTYPE-905))|(1<<(MySqlParserST_GEOMFROMTEXT-905))|(1<<(MySqlParserST_GEOMFROMWKB-905))|(1<<(MySqlParserST_INTERIORRINGN-905))|(1<<(MySqlParserST_INTERSECTION-905))|(1<<(MySqlParserST_INTERSECTS-905))|(1<<(MySqlParserST_ISCLOSED-905)))) != 0) || (((_la-937)&-(0x1f+1)) == 0 && ((1<<uint((_la-937)))&((1<<(MySqlParserST_ISEMPTY-937))|(1<<(MySqlParserST_ISSIMPLE-937))|(1<<(MySqlParserST_LINEFROMTEXT-937))|(1<<(MySqlParserST_LINEFROMWKB-937))|(1<<(MySqlParserST_LINESTRINGFROMTEXT-937))|(1<<(MySqlParserST_LINESTRINGFROMWKB-937))|(1<<(MySqlParserST_NUMGEOMETRIES-937))|(1<<(MySqlParserST_NUMINTERIORRING-937))|(1<<(MySqlParserST_NUMINTERIORRINGS-937))|(1<<(MySqlParserST_NUMPOINTS-937))|(1<<(MySqlParserST_OVERLAPS-937))|(1<<(MySqlParserST_POINTFROMTEXT-937))|(1<<(MySqlParserST_POINTFROMWKB-937))|(1<<(MySqlParserST_POINTN-937))|(1<<(MySqlParserST_POLYFROMTEXT-937))|(1<<(MySqlParserST_POLYFROMWKB-937))|(1<<(MySqlParserST_POLYGONFROMTEXT-937))|(1<<(MySqlParserST_POLYGONFROMWKB-937))|(1<<(MySqlParserST_SRID-937))|(1<<(MySqlParserST_STARTPOINT-937))|(1<<(MySqlParserST_SYMDIFFERENCE-937))|(1<<(MySqlParserST_TOUCHES-937))|(1<<(MySqlParserST_UNION-937))|(1<<(MySqlParserST_WITHIN-937))|(1<<(MySqlParserST_X-937))|(1<<(MySqlParserST_Y-937))|(1<<(MySqlParserSUBDATE-937))|(1<<(MySqlParserSUBSTRING_INDEX-937))|(1<<(MySqlParserSUBTIME-937))|(1<<(MySqlParserSYSTEM_USER-937))|(1<<(MySqlParserTAN-937))|(1<<(MySqlParserTIMEDIFF-937)))) != 0) || (((_la-969)&-(0x1f+1)) == 0 && ((1<<uint((_la-969)))&((1<<(MySqlParserTIMESTAMPADD-969))|(1<<(MySqlParserTIMESTAMPDIFF-969))|(1<<(MySqlParserTIME_FORMAT-969))|(1<<(MySqlParserTIME_TO_SEC-969))|(1<<(MySqlParserTOUCHES-969))|(1<<(MySqlParserTO_BASE64-969))|(1<<(MySqlParserTO_DAYS-969))|(1<<(MySqlParserTO_SECONDS-969))|(1<<(MySqlParserUCASE-969))|(1<<(MySqlParserUNCOMPRESS-969))|(1<<(MySqlParserUNCOMPRESSED_LENGTH-969))|(1<<(MySqlParserUNHEX-969))|(1<<(MySqlParserUNIX_TIMESTAMP-969))|(1<<(MySqlParserUPDATEXML-969))|(1<<(MySqlParserUPPER-969))|(1<<(MySqlParserUUID-969))|(1<<(MySqlParserUUID_SHORT-969))|(1<<(MySqlParserVALIDATE_PASSWORD_STRENGTH-969))|(1<<(MySqlParserVERSION-969))|(1<<(MySqlParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS-969))|(1<<(MySqlParserWEEKDAY-969))|(1<<(MySqlParserWEEKOFYEAR-969))|(1<<(MySqlParserWEIGHT_STRING-969))|(1<<(MySqlParserWITHIN-969))|(1<<(MySqlParserYEARWEEK-969))|(1<<(MySqlParserY_FUNCTION-969))|(1<<(MySqlParserX_FUNCTION-969)))) != 0) || (((_la-1008)&-(0x1f+1)) == 0 && ((1<<uint((_la-1008)))&((1<<(MySqlParserPLUS-1008))|(1<<(MySqlParserMINUS-1008))|(1<<(MySqlParserEXCLAMATION_SYMBOL-1008))|(1<<(MySqlParserBIT_NOT_OP-1008))|(1<<(MySqlParserLR_BRACKET-1008))|(1<<(MySqlParserZERO_DECIMAL-1008))|(1<<(MySqlParserONE_DECIMAL-1008))|(1<<(MySqlParserTWO_DECIMAL-1008))|(1<<(MySqlParserCHARSET_REVERSE_QOUTE_STRING-1008))|(1<<(MySqlParserSTART_NATIONAL_STRING_LITERAL-1008))|(1<<(MySqlParserSTRING_LITERAL-1008))|(1<<(MySqlParserDECIMAL_LITERAL-1008))|(1<<(MySqlParserHEXADECIMAL_LITERAL-1008)))) != 0) || (((_la-1040)&-(0x1f+1)) == 0 && ((1<<uint((_la-1040)))&((1<<(MySqlParserREAL_LITERAL-1040))|(1<<(MySqlParserNULL_SPEC_LITERAL-1040))|(1<<(MySqlParserBIT_STRING-1040))|(1<<(MySqlParserSTRING_CHARSET_NAME-1040))|(1<<(MySqlParserID-1040))|(1<<(MySqlParserREVERSE_QUOTE_ID-1040))|(1<<(MySqlParserLOCAL_ID-1040))|(1<<(MySqlParserGLOBAL_ID-1040)))) != 0) {
			{
				p.SetState(954)
				p.FunctionArgs()
			}

		}
		{
			p.SetState(957)
			p.Match(MySqlParserRR_BRACKET)
		}

	case 4:
		localctx = NewUdfFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(959)
			p.FullId()
		}
		{
			p.SetState(960)
			p.Match(MySqlParserLR_BRACKET)
		}
		p.SetState(962)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<MySqlParserCASE)|(1<<MySqlParserCAST)|(1<<MySqlParserCONVERT))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(MySqlParserCURRENT-32))|(1<<(MySqlParserCURRENT_USER-32))|(1<<(MySqlParserDATABASE-32))|(1<<(MySqlParserDIAGNOSTICS-32))|(1<<(MySqlParserEXISTS-32))|(1<<(MySqlParserFALSE-32)))) != 0) || (((_la-69)&-(0x1f+1)) == 0 && ((1<<uint((_la-69)))&((1<<(MySqlParserIF-69))|(1<<(MySqlParserINSERT-69))|(1<<(MySqlParserINTERVAL-69))|(1<<(MySqlParserLEFT-69)))) != 0) || (((_la-102)&-(0x1f+1)) == 0 && ((1<<uint((_la-102)))&((1<<(MySqlParserNOT-102))|(1<<(MySqlParserNULL_LITERAL-102))|(1<<(MySqlParserNUMBER-102))|(1<<(MySqlParserREPLACE-102))|(1<<(MySqlParserRIGHT-102)))) != 0) || (((_la-151)&-(0x1f+1)) == 0 && ((1<<uint((_la-151)))&((1<<(MySqlParserSTACKED-151))|(1<<(MySqlParserTRUE-151))|(1<<(MySqlParserVALUES-151)))) != 0) || (((_la-199)&-(0x1f+1)) == 0 && ((1<<uint((_la-199)))&((1<<(MySqlParserDATE-199))|(1<<(MySqlParserTIME-199))|(1<<(MySqlParserTIMESTAMP-199))|(1<<(MySqlParserDATETIME-199))|(1<<(MySqlParserYEAR-199))|(1<<(MySqlParserCHAR-199))|(1<<(MySqlParserBINARY-199))|(1<<(MySqlParserTEXT-199))|(1<<(MySqlParserENUM-199))|(1<<(MySqlParserSERIAL-199)))) != 0) || (((_la-233)&-(0x1f+1)) == 0 && ((1<<uint((_la-233)))&((1<<(MySqlParserJSON_VALID-233))|(1<<(MySqlParserJSON_SCHEMA_VALID-233))|(1<<(MySqlParserAVG-233))|(1<<(MySqlParserBIT_AND-233))|(1<<(MySqlParserBIT_OR-233))|(1<<(MySqlParserBIT_XOR-233))|(1<<(MySqlParserCOUNT-233))|(1<<(MySqlParserGROUP_CONCAT-233))|(1<<(MySqlParserMAX-233))|(1<<(MySqlParserMIN-233))|(1<<(MySqlParserSTD-233))|(1<<(MySqlParserSTDDEV-233))|(1<<(MySqlParserSTDDEV_POP-233))|(1<<(MySqlParserSTDDEV_SAMP-233))|(1<<(MySqlParserSUM-233))|(1<<(MySqlParserVAR_POP-233))|(1<<(MySqlParserVAR_SAMP-233))|(1<<(MySqlParserVARIANCE-233))|(1<<(MySqlParserCURRENT_DATE-233))|(1<<(MySqlParserCURRENT_TIME-233))|(1<<(MySqlParserCURRENT_TIMESTAMP-233))|(1<<(MySqlParserLOCALTIME-233))|(1<<(MySqlParserCURDATE-233))|(1<<(MySqlParserCURTIME-233))|(1<<(MySqlParserDATE_ADD-233))|(1<<(MySqlParserDATE_SUB-233))|(1<<(MySqlParserEXTRACT-233))|(1<<(MySqlParserLOCALTIMESTAMP-233))|(1<<(MySqlParserNOW-233))|(1<<(MySqlParserPOSITION-233))|(1<<(MySqlParserSUBSTR-233))|(1<<(MySqlParserSUBSTRING-233)))) != 0) || (((_la-265)&-(0x1f+1)) == 0 && ((1<<uint((_la-265)))&((1<<(MySqlParserSYSDATE-265))|(1<<(MySqlParserTRIM-265))|(1<<(MySqlParserUTC_DATE-265))|(1<<(MySqlParserUTC_TIME-265))|(1<<(MySqlParserUTC_TIMESTAMP-265))|(1<<(MySqlParserACCOUNT-265))|(1<<(MySqlParserACTION-265))|(1<<(MySqlParserAFTER-265))|(1<<(MySqlParserAGGREGATE-265))|(1<<(MySqlParserALGORITHM-265))|(1<<(MySqlParserANY-265))|(1<<(MySqlParserAT-265))|(1<<(MySqlParserAUTHORS-265))|(1<<(MySqlParserAUTOCOMMIT-265))|(1<<(MySqlParserAUTOEXTEND_SIZE-265))|(1<<(MySqlParserAUTO_INCREMENT-265))|(1<<(MySqlParserAVG_ROW_LENGTH-265))|(1<<(MySqlParserBEGIN-265))|(1<<(MySqlParserBINLOG-265))|(1<<(MySqlParserBIT-265))|(1<<(MySqlParserBLOCK-265))|(1<<(MySqlParserBOOL-265))|(1<<(MySqlParserBOOLEAN-265))|(1<<(MySqlParserBTREE-265))|(1<<(MySqlParserCACHE-265))|(1<<(MySqlParserCASCADED-265))|(1<<(MySqlParserCHAIN-265))|(1<<(MySqlParserCHANGED-265))|(1<<(MySqlParserCHANNEL-265))|(1<<(MySqlParserCHECKSUM-265))|(1<<(MySqlParserPAGE_CHECKSUM-265))|(1<<(MySqlParserCIPHER-265)))) != 0) || (((_la-297)&-(0x1f+1)) == 0 && ((1<<uint((_la-297)))&((1<<(MySqlParserCLASS_ORIGIN-297))|(1<<(MySqlParserCLIENT-297))|(1<<(MySqlParserCLOSE-297))|(1<<(MySqlParserCOALESCE-297))|(1<<(MySqlParserCODE-297))|(1<<(MySqlParserCOLUMNS-297))|(1<<(MySqlParserCOLUMN_FORMAT-297))|(1<<(MySqlParserCOLUMN_NAME-297))|(1<<(MySqlParserCOMMENT-297))|(1<<(MySqlParserCOMMIT-297))|(1<<(MySqlParserCOMPACT-297))|(1<<(MySqlParserCOMPLETION-297))|(1<<(MySqlParserCOMPRESSED-297))|(1<<(MySqlParserCOMPRESSION-297))|(1<<(MySqlParserCONCURRENT-297))|(1<<(MySqlParserCONNECTION-297))|(1<<(MySqlParserCONSISTENT-297))|(1<<(MySqlParserCONSTRAINT_CATALOG-297))|(1<<(MySqlParserCONSTRAINT_SCHEMA-297))|(1<<(MySqlParserCONSTRAINT_NAME-297))|(1<<(MySqlParserCONTAINS-297))|(1<<(MySqlParserCONTEXT-297))|(1<<(MySqlParserCONTRIBUTORS-297))|(1<<(MySqlParserCOPY-297))|(1<<(MySqlParserCPU-297))|(1<<(MySqlParserCURSOR_NAME-297))|(1<<(MySqlParserDATA-297))|(1<<(MySqlParserDATAFILE-297))|(1<<(MySqlParserDEALLOCATE-297))|(1<<(MySqlParserDEFAULT_AUTH-297))|(1<<(MySqlParserDEFINER-297))|(1<<(MySqlParserDELAY_KEY_WRITE-297)))) != 0) || (((_la-329)&-(0x1f+1)) == 0 && ((1<<uint((_la-329)))&((1<<(MySqlParserDES_KEY_FILE-329))|(1<<(MySqlParserDIRECTORY-329))|(1<<(MySqlParserDISABLE-329))|(1<<(MySqlParserDISCARD-329))|(1<<(MySqlParserDISK-329))|(1<<(MySqlParserDO-329))|(1<<(MySqlParserDUMPFILE-329))|(1<<(MySqlParserDUPLICATE-329))|(1<<(MySqlParserDYNAMIC-329))|(1<<(MySqlParserENABLE-329))|(1<<(MySqlParserENCRYPTION-329))|(1<<(MySqlParserEND-329))|(1<<(MySqlParserENDS-329))|(1<<(MySqlParserENGINE-329))|(1<<(MySqlParserENGINES-329))|(1<<(MySqlParserERROR-329))|(1<<(MySqlParserERRORS-329))|(1<<(MySqlParserESCAPE-329))|(1<<(MySqlParserEVEN-329))|(1<<(MySqlParserEVENT-329))|(1<<(MySqlParserEVENTS-329))|(1<<(MySqlParserEVERY-329))|(1<<(MySqlParserEXCHANGE-329))|(1<<(MySqlParserEXCLUSIVE-329))|(1<<(MySqlParserEXPIRE-329))|(1<<(MySqlParserEXPORT-329))|(1<<(MySqlParserEXTENDED-329))|(1<<(MySqlParserEXTENT_SIZE-329))|(1<<(MySqlParserFAST-329))|(1<<(MySqlParserFAULTS-329))|(1<<(MySqlParserFIELDS-329))|(1<<(MySqlParserFILE_BLOCK_SIZE-329)))) != 0) || (((_la-361)&-(0x1f+1)) == 0 && ((1<<uint((_la-361)))&((1<<(MySqlParserFILTER-361))|(1<<(MySqlParserFIRST-361))|(1<<(MySqlParserFIXED-361))|(1<<(MySqlParserFLUSH-361))|(1<<(MySqlParserFOLLOWS-361))|(1<<(MySqlParserFOUND-361))|(1<<(MySqlParserFULL-361))|(1<<(MySqlParserFUNCTION-361))|(1<<(MySqlParserGENERAL-361))|(1<<(MySqlParserGLOBAL-361))|(1<<(MySqlParserGRANTS-361))|(1<<(MySqlParserGROUP_REPLICATION-361))|(1<<(MySqlParserHANDLER-361))|(1<<(MySqlParserHASH-361))|(1<<(MySqlParserHELP-361))|(1<<(MySqlParserHOST-361))|(1<<(MySqlParserHOSTS-361))|(1<<(MySqlParserIDENTIFIED-361))|(1<<(MySqlParserIGNORE_SERVER_IDS-361))|(1<<(MySqlParserIMPORT-361))|(1<<(MySqlParserINDEXES-361))|(1<<(MySqlParserINITIAL_SIZE-361))|(1<<(MySqlParserINPLACE-361))|(1<<(MySqlParserINSERT_METHOD-361))|(1<<(MySqlParserINSTALL-361))|(1<<(MySqlParserINSTANCE-361))|(1<<(MySqlParserINVISIBLE-361))|(1<<(MySqlParserINVOKER-361))|(1<<(MySqlParserIO-361))|(1<<(MySqlParserIO_THREAD-361))|(1<<(MySqlParserIPC-361))|(1<<(MySqlParserISOLATION-361)))) != 0) || (((_la-393)&-(0x1f+1)) == 0 && ((1<<uint((_la-393)))&((1<<(MySqlParserISSUER-393))|(1<<(MySqlParserJSON-393))|(1<<(MySqlParserKEY_BLOCK_SIZE-393))|(1<<(MySqlParserLANGUAGE-393))|(1<<(MySqlParserLAST-393))|(1<<(MySqlParserLEAVES-393))|(1<<(MySqlParserLESS-393))|(1<<(MySqlParserLEVEL-393))|(1<<(MySqlParserLIST-393))|(1<<(MySqlParserLOCAL-393))|(1<<(MySqlParserLOGFILE-393))|(1<<(MySqlParserLOGS-393))|(1<<(MySqlParserMASTER-393))|(1<<(MySqlParserMASTER_AUTO_POSITION-393))|(1<<(MySqlParserMASTER_CONNECT_RETRY-393))|(1<<(MySqlParserMASTER_DELAY-393))|(1<<(MySqlParserMASTER_HEARTBEAT_PERIOD-393))|(1<<(MySqlParserMASTER_HOST-393))|(1<<(MySqlParserMASTER_LOG_FILE-393))|(1<<(MySqlParserMASTER_LOG_POS-393))|(1<<(MySqlParserMASTER_PASSWORD-393))|(1<<(MySqlParserMASTER_PORT-393))|(1<<(MySqlParserMASTER_RETRY_COUNT-393))|(1<<(MySqlParserMASTER_SSL-393))|(1<<(MySqlParserMASTER_SSL_CA-393))|(1<<(MySqlParserMASTER_SSL_CAPATH-393))|(1<<(MySqlParserMASTER_SSL_CERT-393))|(1<<(MySqlParserMASTER_SSL_CIPHER-393))|(1<<(MySqlParserMASTER_SSL_CRL-393))|(1<<(MySqlParserMASTER_SSL_CRLPATH-393))|(1<<(MySqlParserMASTER_SSL_KEY-393))|(1<<(MySqlParserMASTER_TLS_VERSION-393)))) != 0) || (((_la-425)&-(0x1f+1)) == 0 && ((1<<uint((_la-425)))&((1<<(MySqlParserMASTER_USER-425))|(1<<(MySqlParserMAX_CONNECTIONS_PER_HOUR-425))|(1<<(MySqlParserMAX_QUERIES_PER_HOUR-425))|(1<<(MySqlParserMAX_ROWS-425))|(1<<(MySqlParserMAX_SIZE-425))|(1<<(MySqlParserMAX_UPDATES_PER_HOUR-425))|(1<<(MySqlParserMAX_USER_CONNECTIONS-425))|(1<<(MySqlParserMEDIUM-425))|(1<<(MySqlParserMEMBER-425))|(1<<(MySqlParserMERGE-425))|(1<<(MySqlParserMESSAGE_TEXT-425))|(1<<(MySqlParserMID-425))|(1<<(MySqlParserMIGRATE-425))|(1<<(MySqlParserMIN_ROWS-425))|(1<<(MySqlParserMODE-425))|(1<<(MySqlParserMODIFY-425))|(1<<(MySqlParserMUTEX-425))|(1<<(MySqlParserMYSQL-425))|(1<<(MySqlParserMYSQL_ERRNO-425))|(1<<(MySqlParserNAME-425))|(1<<(MySqlParserNAMES-425))|(1<<(MySqlParserNCHAR-425))|(1<<(MySqlParserNEVER-425))|(1<<(MySqlParserNEXT-425))|(1<<(MySqlParserNO-425))|(1<<(MySqlParserNODEGROUP-425))|(1<<(MySqlParserNONE-425))|(1<<(MySqlParserOFFLINE-425))|(1<<(MySqlParserOFFSET-425))|(1<<(MySqlParserOF-425))|(1<<(MySqlParserOJ-425))|(1<<(MySqlParserOLD_PASSWORD-425)))) != 0) || (((_la-457)&-(0x1f+1)) == 0 && ((1<<uint((_la-457)))&((1<<(MySqlParserONE-457))|(1<<(MySqlParserONLINE-457))|(1<<(MySqlParserONLY-457))|(1<<(MySqlParserOPEN-457))|(1<<(MySqlParserOPTIMIZER_COSTS-457))|(1<<(MySqlParserOPTIONS-457))|(1<<(MySqlParserOWNER-457))|(1<<(MySqlParserPACK_KEYS-457))|(1<<(MySqlParserPAGE-457))|(1<<(MySqlParserPARSER-457))|(1<<(MySqlParserPARTIAL-457))|(1<<(MySqlParserPARTITIONING-457))|(1<<(MySqlParserPARTITIONS-457))|(1<<(MySqlParserPASSWORD-457))|(1<<(MySqlParserPHASE-457))|(1<<(MySqlParserPLUGIN-457))|(1<<(MySqlParserPLUGIN_DIR-457))|(1<<(MySqlParserPLUGINS-457))|(1<<(MySqlParserPORT-457))|(1<<(MySqlParserPRECEDES-457))|(1<<(MySqlParserPREPARE-457))|(1<<(MySqlParserPRESERVE-457))|(1<<(MySqlParserPREV-457))|(1<<(MySqlParserPROCESSLIST-457))|(1<<(MySqlParserPROFILE-457))|(1<<(MySqlParserPROFILES-457))|(1<<(MySqlParserPROXY-457))|(1<<(MySqlParserQUERY-457))|(1<<(MySqlParserQUICK-457))|(1<<(MySqlParserREBUILD-457))|(1<<(MySqlParserRECOVER-457))|(1<<(MySqlParserREDO_BUFFER_SIZE-457)))) != 0) || (((_la-489)&-(0x1f+1)) == 0 && ((1<<uint((_la-489)))&((1<<(MySqlParserREDUNDANT-489))|(1<<(MySqlParserRELAY-489))|(1<<(MySqlParserRELAY_LOG_FILE-489))|(1<<(MySqlParserRELAY_LOG_POS-489))|(1<<(MySqlParserRELAYLOG-489))|(1<<(MySqlParserREMOVE-489))|(1<<(MySqlParserREORGANIZE-489))|(1<<(MySqlParserREPAIR-489))|(1<<(MySqlParserREPLICATE_DO_DB-489))|(1<<(MySqlParserREPLICATE_DO_TABLE-489))|(1<<(MySqlParserREPLICATE_IGNORE_DB-489))|(1<<(MySqlParserREPLICATE_IGNORE_TABLE-489))|(1<<(MySqlParserREPLICATE_REWRITE_DB-489))|(1<<(MySqlParserREPLICATE_WILD_DO_TABLE-489))|(1<<(MySqlParserREPLICATE_WILD_IGNORE_TABLE-489))|(1<<(MySqlParserREPLICATION-489))|(1<<(MySqlParserRESET-489))|(1<<(MySqlParserRESUME-489))|(1<<(MySqlParserRETURNED_SQLSTATE-489))|(1<<(MySqlParserRETURNS-489))|(1<<(MySqlParserROLE-489))|(1<<(MySqlParserROLLBACK-489))|(1<<(MySqlParserROLLUP-489))|(1<<(MySqlParserROTATE-489))|(1<<(MySqlParserROW-489))|(1<<(MySqlParserROWS-489))|(1<<(MySqlParserROW_FORMAT-489))|(1<<(MySqlParserSAVEPOINT-489))|(1<<(MySqlParserSCHEDULE-489))|(1<<(MySqlParserSECURITY-489))|(1<<(MySqlParserSERVER-489))|(1<<(MySqlParserSESSION-489)))) != 0) || (((_la-521)&-(0x1f+1)) == 0 && ((1<<uint((_la-521)))&((1<<(MySqlParserSHARE-521))|(1<<(MySqlParserSHARED-521))|(1<<(MySqlParserSIGNED-521))|(1<<(MySqlParserSIMPLE-521))|(1<<(MySqlParserSLAVE-521))|(1<<(MySqlParserSLOW-521))|(1<<(MySqlParserSNAPSHOT-521))|(1<<(MySqlParserSOCKET-521))|(1<<(MySqlParserSOME-521))|(1<<(MySqlParserSONAME-521))|(1<<(MySqlParserSOUNDS-521))|(1<<(MySqlParserSOURCE-521))|(1<<(MySqlParserSQL_AFTER_GTIDS-521))|(1<<(MySqlParserSQL_AFTER_MTS_GAPS-521))|(1<<(MySqlParserSQL_BEFORE_GTIDS-521))|(1<<(MySqlParserSQL_BUFFER_RESULT-521))|(1<<(MySqlParserSQL_CACHE-521))|(1<<(MySqlParserSQL_NO_CACHE-521))|(1<<(MySqlParserSQL_THREAD-521))|(1<<(MySqlParserSTART-521))|(1<<(MySqlParserSTARTS-521))|(1<<(MySqlParserSTATS_AUTO_RECALC-521))|(1<<(MySqlParserSTATS_PERSISTENT-521))|(1<<(MySqlParserSTATS_SAMPLE_PAGES-521))|(1<<(MySqlParserSTATUS-521))|(1<<(MySqlParserSTOP-521))|(1<<(MySqlParserSTORAGE-521))|(1<<(MySqlParserSTRING-521))|(1<<(MySqlParserSUBCLASS_ORIGIN-521))|(1<<(MySqlParserSUBJECT-521))|(1<<(MySqlParserSUBPARTITION-521)))) != 0) || (((_la-553)&-(0x1f+1)) == 0 && ((1<<uint((_la-553)))&((1<<(MySqlParserSUBPARTITIONS-553))|(1<<(MySqlParserSUSPEND-553))|(1<<(MySqlParserSWAPS-553))|(1<<(MySqlParserSWITCHES-553))|(1<<(MySqlParserTABLE_NAME-553))|(1<<(MySqlParserTABLESPACE-553))|(1<<(MySqlParserTEMPORARY-553))|(1<<(MySqlParserTEMPTABLE-553))|(1<<(MySqlParserTHAN-553))|(1<<(MySqlParserTRADITIONAL-553))|(1<<(MySqlParserTRANSACTION-553))|(1<<(MySqlParserTRANSACTIONAL-553))|(1<<(MySqlParserTRIGGERS-553))|(1<<(MySqlParserTRUNCATE-553))|(1<<(MySqlParserUNDEFINED-553))|(1<<(MySqlParserUNDOFILE-553))|(1<<(MySqlParserUNDO_BUFFER_SIZE-553))|(1<<(MySqlParserUNINSTALL-553))|(1<<(MySqlParserUNKNOWN-553))|(1<<(MySqlParserUNTIL-553))|(1<<(MySqlParserUPGRADE-553))|(1<<(MySqlParserUSER-553))|(1<<(MySqlParserUSE_FRM-553))|(1<<(MySqlParserUSER_RESOURCES-553))|(1<<(MySqlParserVALIDATION-553))|(1<<(MySqlParserVALUE-553))|(1<<(MySqlParserVARIABLES-553))|(1<<(MySqlParserVIEW-553))|(1<<(MySqlParserVISIBLE-553))|(1<<(MySqlParserWAIT-553))|(1<<(MySqlParserWARNINGS-553)))) != 0) || (((_la-585)&-(0x1f+1)) == 0 && ((1<<uint((_la-585)))&((1<<(MySqlParserWITHOUT-585))|(1<<(MySqlParserWORK-585))|(1<<(MySqlParserWRAPPER-585))|(1<<(MySqlParserX509-585))|(1<<(MySqlParserXA-585))|(1<<(MySqlParserXML-585))|(1<<(MySqlParserINTERNAL-585))|(1<<(MySqlParserQUARTER-585))|(1<<(MySqlParserMONTH-585))|(1<<(MySqlParserDAY-585))|(1<<(MySqlParserHOUR-585))|(1<<(MySqlParserMINUTE-585))|(1<<(MySqlParserWEEK-585))|(1<<(MySqlParserSECOND-585))|(1<<(MySqlParserMICROSECOND-585))|(1<<(MySqlParserTABLES-585))|(1<<(MySqlParserROUTINE-585))|(1<<(MySqlParserEXECUTE-585))|(1<<(MySqlParserFILE-585))|(1<<(MySqlParserPROCESS-585))|(1<<(MySqlParserRELOAD-585))|(1<<(MySqlParserSHUTDOWN-585))|(1<<(MySqlParserSUPER-585))|(1<<(MySqlParserPRIVILEGES-585))|(1<<(MySqlParserAUDIT_ADMIN-585))|(1<<(MySqlParserBACKUP_ADMIN-585))|(1<<(MySqlParserBINLOG_ADMIN-585)))) != 0) || (((_la-617)&-(0x1f+1)) == 0 && ((1<<uint((_la-617)))&((1<<(MySqlParserBINLOG_ENCRYPTION_ADMIN-617))|(1<<(MySqlParserCLONE_ADMIN-617))|(1<<(MySqlParserCONNECTION_ADMIN-617))|(1<<(MySqlParserENCRYPTION_KEY_ADMIN-617))|(1<<(MySqlParserFIREWALL_ADMIN-617))|(1<<(MySqlParserFIREWALL_USER-617))|(1<<(MySqlParserGROUP_REPLICATION_ADMIN-617))|(1<<(MySqlParserINNODB_REDO_LOG_ARCHIVE-617))|(1<<(MySqlParserNDB_STORED_USER-617))|(1<<(MySqlParserPERSIST_RO_VARIABLES_ADMIN-617))|(1<<(MySqlParserREPLICATION_APPLIER-617))|(1<<(MySqlParserREPLICATION_SLAVE_ADMIN-617))|(1<<(MySqlParserRESOURCE_GROUP_ADMIN-617))|(1<<(MySqlParserRESOURCE_GROUP_USER-617))|(1<<(MySqlParserROLE_ADMIN-617))|(1<<(MySqlParserSESSION_VARIABLES_ADMIN-617))|(1<<(MySqlParserSET_USER_ID-617))|(1<<(MySqlParserSHOW_ROUTINE-617))|(1<<(MySqlParserSYSTEM_VARIABLES_ADMIN-617))|(1<<(MySqlParserTABLE_ENCRYPTION_ADMIN-617))|(1<<(MySqlParserVERSION_TOKEN_ADMIN-617))|(1<<(MySqlParserXA_RECOVER_ADMIN-617))|(1<<(MySqlParserARMSCII8-617))|(1<<(MySqlParserASCII-617))|(1<<(MySqlParserBIG5-617))|(1<<(MySqlParserCP1250-617))|(1<<(MySqlParserCP1251-617))|(1<<(MySqlParserCP1256-617))|(1<<(MySqlParserCP1257-617))|(1<<(MySqlParserCP850-617))|(1<<(MySqlParserCP852-617))|(1<<(MySqlParserCP866-617)))) != 0) || (((_la-649)&-(0x1f+1)) == 0 && ((1<<uint((_la-649)))&((1<<(MySqlParserCP932-649))|(1<<(MySqlParserDEC8-649))|(1<<(MySqlParserEUCJPMS-649))|(1<<(MySqlParserEUCKR-649))|(1<<(MySqlParserGB2312-649))|(1<<(MySqlParserGBK-649))|(1<<(MySqlParserGEOSTD8-649))|(1<<(MySqlParserGREEK-649))|(1<<(MySqlParserHEBREW-649))|(1<<(MySqlParserHP8-649))|(1<<(MySqlParserKEYBCS2-649))|(1<<(MySqlParserKOI8R-649))|(1<<(MySqlParserKOI8U-649))|(1<<(MySqlParserLATIN1-649))|(1<<(MySqlParserLATIN2-649))|(1<<(MySqlParserLATIN5-649))|(1<<(MySqlParserLATIN7-649))|(1<<(MySqlParserMACCE-649))|(1<<(MySqlParserMACROMAN-649))|(1<<(MySqlParserSJIS-649))|(1<<(MySqlParserSWE7-649))|(1<<(MySqlParserTIS620-649))|(1<<(MySqlParserUCS2-649))|(1<<(MySqlParserUJIS-649))|(1<<(MySqlParserUTF16-649))|(1<<(MySqlParserUTF16LE-649))|(1<<(MySqlParserUTF32-649))|(1<<(MySqlParserUTF8-649))|(1<<(MySqlParserUTF8MB3-649))|(1<<(MySqlParserUTF8MB4-649))|(1<<(MySqlParserARCHIVE-649))|(1<<(MySqlParserBLACKHOLE-649)))) != 0) || (((_la-681)&-(0x1f+1)) == 0 && ((1<<uint((_la-681)))&((1<<(MySqlParserCSV-681))|(1<<(MySqlParserFEDERATED-681))|(1<<(MySqlParserINNODB-681))|(1<<(MySqlParserMEMORY-681))|(1<<(MySqlParserMRG_MYISAM-681))|(1<<(MySqlParserMYISAM-681))|(1<<(MySqlParserNDB-681))|(1<<(MySqlParserNDBCLUSTER-681))|(1<<(MySqlParserPERFORMANCE_SCHEMA-681))|(1<<(MySqlParserTOKUDB-681))|(1<<(MySqlParserREPEATABLE-681))|(1<<(MySqlParserCOMMITTED-681))|(1<<(MySqlParserUNCOMMITTED-681))|(1<<(MySqlParserSERIALIZABLE-681))|(1<<(MySqlParserGEOMETRYCOLLECTION-681))|(1<<(MySqlParserLINESTRING-681))|(1<<(MySqlParserMULTILINESTRING-681))|(1<<(MySqlParserMULTIPOINT-681))|(1<<(MySqlParserMULTIPOLYGON-681))|(1<<(MySqlParserPOINT-681))|(1<<(MySqlParserPOLYGON-681))|(1<<(MySqlParserABS-681))|(1<<(MySqlParserACOS-681))|(1<<(MySqlParserADDDATE-681))|(1<<(MySqlParserADDTIME-681))|(1<<(MySqlParserAES_DECRYPT-681))|(1<<(MySqlParserAES_ENCRYPT-681))|(1<<(MySqlParserAREA-681))|(1<<(MySqlParserASBINARY-681))|(1<<(MySqlParserASIN-681)))) != 0) || (((_la-713)&-(0x1f+1)) == 0 && ((1<<uint((_la-713)))&((1<<(MySqlParserASTEXT-713))|(1<<(MySqlParserASWKB-713))|(1<<(MySqlParserASWKT-713))|(1<<(MySqlParserASYMMETRIC_DECRYPT-713))|(1<<(MySqlParserASYMMETRIC_DERIVE-713))|(1<<(MySqlParserASYMMETRIC_ENCRYPT-713))|(1<<(MySqlParserASYMMETRIC_SIGN-713))|(1<<(MySqlParserASYMMETRIC_VERIFY-713))|(1<<(MySqlParserATAN-713))|(1<<(MySqlParserATAN2-713))|(1<<(MySqlParserBENCHMARK-713))|(1<<(MySqlParserBIN-713))|(1<<(MySqlParserBIT_COUNT-713))|(1<<(MySqlParserBIT_LENGTH-713))|(1<<(MySqlParserBUFFER-713))|(1<<(MySqlParserCATALOG_NAME-713))|(1<<(MySqlParserCEIL-713))|(1<<(MySqlParserCEILING-713))|(1<<(MySqlParserCENTROID-713))|(1<<(MySqlParserCHARACTER_LENGTH-713))|(1<<(MySqlParserCHARSET-713))|(1<<(MySqlParserCHAR_LENGTH-713))|(1<<(MySqlParserCOERCIBILITY-713))|(1<<(MySqlParserCOLLATION-713))|(1<<(MySqlParserCOMPRESS-713))|(1<<(MySqlParserCONCAT-713))|(1<<(MySqlParserCONCAT_WS-713))|(1<<(MySqlParserCONNECTION_ID-713))|(1<<(MySqlParserCONV-713))|(1<<(MySqlParserCONVERT_TZ-713))|(1<<(MySqlParserCOS-713))|(1<<(MySqlParserCOT-713)))) != 0) || (((_la-745)&-(0x1f+1)) == 0 && ((1<<uint((_la-745)))&((1<<(MySqlParserCRC32-745))|(1<<(MySqlParserCREATE_ASYMMETRIC_PRIV_KEY-745))|(1<<(MySqlParserCREATE_ASYMMETRIC_PUB_KEY-745))|(1<<(MySqlParserCREATE_DH_PARAMETERS-745))|(1<<(MySqlParserCREATE_DIGEST-745))|(1<<(MySqlParserCROSSES-745))|(1<<(MySqlParserDATEDIFF-745))|(1<<(MySqlParserDATE_FORMAT-745))|(1<<(MySqlParserDAYNAME-745))|(1<<(MySqlParserDAYOFMONTH-745))|(1<<(MySqlParserDAYOFWEEK-745))|(1<<(MySqlParserDAYOFYEAR-745))|(1<<(MySqlParserDECODE-745))|(1<<(MySqlParserDEGREES-745))|(1<<(MySqlParserDES_DECRYPT-745))|(1<<(MySqlParserDES_ENCRYPT-745))|(1<<(MySqlParserDIMENSION-745))|(1<<(MySqlParserDISJOINT-745))|(1<<(MySqlParserELT-745))|(1<<(MySqlParserENCODE-745))|(1<<(MySqlParserENCRYPT-745))|(1<<(MySqlParserENDPOINT-745))|(1<<(MySqlParserENVELOPE-745))|(1<<(MySqlParserEQUALS-745))|(1<<(MySqlParserEXP-745))|(1<<(MySqlParserEXPORT_SET-745))|(1<<(MySqlParserEXTERIORRING-745))|(1<<(MySqlParserEXTRACTVALUE-745))|(1<<(MySqlParserFIELD-745))|(1<<(MySqlParserFIND_IN_SET-745))|(1<<(MySqlParserFLOOR-745))|(1<<(MySqlParserFORMAT-745)))) != 0) || (((_la-777)&-(0x1f+1)) == 0 && ((1<<uint((_la-777)))&((1<<(MySqlParserFOUND_ROWS-777))|(1<<(MySqlParserFROM_BASE64-777))|(1<<(MySqlParserFROM_DAYS-777))|(1<<(MySqlParserFROM_UNIXTIME-777))|(1<<(MySqlParserGEOMCOLLFROMTEXT-777))|(1<<(MySqlParserGEOMCOLLFROMWKB-777))|(1<<(MySqlParserGEOMETRYCOLLECTIONFROMTEXT-777))|(1<<(MySqlParserGEOMETRYCOLLECTIONFROMWKB-777))|(1<<(MySqlParserGEOMETRYFROMTEXT-777))|(1<<(MySqlParserGEOMETRYFROMWKB-777))|(1<<(MySqlParserGEOMETRYN-777))|(1<<(MySqlParserGEOMETRYTYPE-777))|(1<<(MySqlParserGEOMFROMTEXT-777))|(1<<(MySqlParserGEOMFROMWKB-777))|(1<<(MySqlParserGET_FORMAT-777))|(1<<(MySqlParserGET_LOCK-777))|(1<<(MySqlParserGLENGTH-777))|(1<<(MySqlParserGREATEST-777))|(1<<(MySqlParserGTID_SUBSET-777))|(1<<(MySqlParserGTID_SUBTRACT-777))|(1<<(MySqlParserHEX-777))|(1<<(MySqlParserIFNULL-777))|(1<<(MySqlParserINET6_ATON-777))|(1<<(MySqlParserINET6_NTOA-777))|(1<<(MySqlParserINET_ATON-777))|(1<<(MySqlParserINET_NTOA-777))|(1<<(MySqlParserINSTR-777))|(1<<(MySqlParserINTERIORRINGN-777))|(1<<(MySqlParserINTERSECTS-777))|(1<<(MySqlParserISCLOSED-777))|(1<<(MySqlParserISEMPTY-777))|(1<<(MySqlParserISNULL-777)))) != 0) || (((_la-809)&-(0x1f+1)) == 0 && ((1<<uint((_la-809)))&((1<<(MySqlParserISSIMPLE-809))|(1<<(MySqlParserIS_FREE_LOCK-809))|(1<<(MySqlParserIS_IPV4-809))|(1<<(MySqlParserIS_IPV4_COMPAT-809))|(1<<(MySqlParserIS_IPV4_MAPPED-809))|(1<<(MySqlParserIS_IPV6-809))|(1<<(MySqlParserIS_USED_LOCK-809))|(1<<(MySqlParserLAST_INSERT_ID-809))|(1<<(MySqlParserLCASE-809))|(1<<(MySqlParserLEAST-809))|(1<<(MySqlParserLENGTH-809))|(1<<(MySqlParserLINEFROMTEXT-809))|(1<<(MySqlParserLINEFROMWKB-809))|(1<<(MySqlParserLINESTRINGFROMTEXT-809))|(1<<(MySqlParserLINESTRINGFROMWKB-809))|(1<<(MySqlParserLN-809))|(1<<(MySqlParserLOAD_FILE-809))|(1<<(MySqlParserLOCATE-809))|(1<<(MySqlParserLOG-809))|(1<<(MySqlParserLOG10-809))|(1<<(MySqlParserLOG2-809))|(1<<(MySqlParserLOWER-809))|(1<<(MySqlParserLPAD-809))|(1<<(MySqlParserLTRIM-809))|(1<<(MySqlParserMAKEDATE-809))|(1<<(MySqlParserMAKETIME-809))|(1<<(MySqlParserMAKE_SET-809))|(1<<(MySqlParserMASTER_POS_WAIT-809))|(1<<(MySqlParserMBRCONTAINS-809))|(1<<(MySqlParserMBRDISJOINT-809))|(1<<(MySqlParserMBREQUAL-809))|(1<<(MySqlParserMBRINTERSECTS-809)))) != 0) || (((_la-841)&-(0x1f+1)) == 0 && ((1<<uint((_la-841)))&((1<<(MySqlParserMBROVERLAPS-841))|(1<<(MySqlParserMBRTOUCHES-841))|(1<<(MySqlParserMBRWITHIN-841))|(1<<(MySqlParserMD5-841))|(1<<(MySqlParserMLINEFROMTEXT-841))|(1<<(MySqlParserMLINEFROMWKB-841))|(1<<(MySqlParserMONTHNAME-841))|(1<<(MySqlParserMPOINTFROMTEXT-841))|(1<<(MySqlParserMPOINTFROMWKB-841))|(1<<(MySqlParserMPOLYFROMTEXT-841))|(1<<(MySqlParserMPOLYFROMWKB-841))|(1<<(MySqlParserMULTILINESTRINGFROMTEXT-841))|(1<<(MySqlParserMULTILINESTRINGFROMWKB-841))|(1<<(MySqlParserMULTIPOINTFROMTEXT-841))|(1<<(MySqlParserMULTIPOINTFROMWKB-841))|(1<<(MySqlParserMULTIPOLYGONFROMTEXT-841))|(1<<(MySqlParserMULTIPOLYGONFROMWKB-841))|(1<<(MySqlParserNAME_CONST-841))|(1<<(MySqlParserNULLIF-841))|(1<<(MySqlParserNUMGEOMETRIES-841))|(1<<(MySqlParserNUMINTERIORRINGS-841))|(1<<(MySqlParserNUMPOINTS-841))|(1<<(MySqlParserOCT-841))|(1<<(MySqlParserOCTET_LENGTH-841))|(1<<(MySqlParserORD-841))|(1<<(MySqlParserOVERLAPS-841))|(1<<(MySqlParserPERIOD_ADD-841))|(1<<(MySqlParserPERIOD_DIFF-841))|(1<<(MySqlParserPI-841))|(1<<(MySqlParserPOINTFROMTEXT-841))|(1<<(MySqlParserPOINTFROMWKB-841))|(1<<(MySqlParserPOINTN-841)))) != 0) || (((_la-873)&-(0x1f+1)) == 0 && ((1<<uint((_la-873)))&((1<<(MySqlParserPOLYFROMTEXT-873))|(1<<(MySqlParserPOLYFROMWKB-873))|(1<<(MySqlParserPOLYGONFROMTEXT-873))|(1<<(MySqlParserPOLYGONFROMWKB-873))|(1<<(MySqlParserPOW-873))|(1<<(MySqlParserPOWER-873))|(1<<(MySqlParserQUOTE-873))|(1<<(MySqlParserRADIANS-873))|(1<<(MySqlParserRAND-873))|(1<<(MySqlParserRANDOM_BYTES-873))|(1<<(MySqlParserRELEASE_LOCK-873))|(1<<(MySqlParserREVERSE-873))|(1<<(MySqlParserROUND-873))|(1<<(MySqlParserROW_COUNT-873))|(1<<(MySqlParserRPAD-873))|(1<<(MySqlParserRTRIM-873))|(1<<(MySqlParserSEC_TO_TIME-873))|(1<<(MySqlParserSESSION_USER-873))|(1<<(MySqlParserSHA-873))|(1<<(MySqlParserSHA1-873))|(1<<(MySqlParserSHA2-873))|(1<<(MySqlParserSCHEMA_NAME-873))|(1<<(MySqlParserSIGN-873))|(1<<(MySqlParserSIN-873))|(1<<(MySqlParserSLEEP-873))|(1<<(MySqlParserSOUNDEX-873))|(1<<(MySqlParserSQL_THREAD_WAIT_AFTER_GTIDS-873))|(1<<(MySqlParserSQRT-873))|(1<<(MySqlParserSRID-873))|(1<<(MySqlParserSTARTPOINT-873))|(1<<(MySqlParserSTRCMP-873))|(1<<(MySqlParserSTR_TO_DATE-873)))) != 0) || (((_la-905)&-(0x1f+1)) == 0 && ((1<<uint((_la-905)))&((1<<(MySqlParserST_AREA-905))|(1<<(MySqlParserST_ASBINARY-905))|(1<<(MySqlParserST_ASTEXT-905))|(1<<(MySqlParserST_ASWKB-905))|(1<<(MySqlParserST_ASWKT-905))|(1<<(MySqlParserST_BUFFER-905))|(1<<(MySqlParserST_CENTROID-905))|(1<<(MySqlParserST_CONTAINS-905))|(1<<(MySqlParserST_CROSSES-905))|(1<<(MySqlParserST_DIFFERENCE-905))|(1<<(MySqlParserST_DIMENSION-905))|(1<<(MySqlParserST_DISJOINT-905))|(1<<(MySqlParserST_DISTANCE-905))|(1<<(MySqlParserST_ENDPOINT-905))|(1<<(MySqlParserST_ENVELOPE-905))|(1<<(MySqlParserST_EQUALS-905))|(1<<(MySqlParserST_EXTERIORRING-905))|(1<<(MySqlParserST_GEOMCOLLFROMTEXT-905))|(1<<(MySqlParserST_GEOMCOLLFROMTXT-905))|(1<<(MySqlParserST_GEOMCOLLFROMWKB-905))|(1<<(MySqlParserST_GEOMETRYCOLLECTIONFROMTEXT-905))|(1<<(MySqlParserST_GEOMETRYCOLLECTIONFROMWKB-905))|(1<<(MySqlParserST_GEOMETRYFROMTEXT-905))|(1<<(MySqlParserST_GEOMETRYFROMWKB-905))|(1<<(MySqlParserST_GEOMETRYN-905))|(1<<(MySqlParserST_GEOMETRYTYPE-905))|(1<<(MySqlParserST_GEOMFROMTEXT-905))|(1<<(MySqlParserST_GEOMFROMWKB-905))|(1<<(MySqlParserST_INTERIORRINGN-905))|(1<<(MySqlParserST_INTERSECTION-905))|(1<<(MySqlParserST_INTERSECTS-905))|(1<<(MySqlParserST_ISCLOSED-905)))) != 0) || (((_la-937)&-(0x1f+1)) == 0 && ((1<<uint((_la-937)))&((1<<(MySqlParserST_ISEMPTY-937))|(1<<(MySqlParserST_ISSIMPLE-937))|(1<<(MySqlParserST_LINEFROMTEXT-937))|(1<<(MySqlParserST_LINEFROMWKB-937))|(1<<(MySqlParserST_LINESTRINGFROMTEXT-937))|(1<<(MySqlParserST_LINESTRINGFROMWKB-937))|(1<<(MySqlParserST_NUMGEOMETRIES-937))|(1<<(MySqlParserST_NUMINTERIORRING-937))|(1<<(MySqlParserST_NUMINTERIORRINGS-937))|(1<<(MySqlParserST_NUMPOINTS-937))|(1<<(MySqlParserST_OVERLAPS-937))|(1<<(MySqlParserST_POINTFROMTEXT-937))|(1<<(MySqlParserST_POINTFROMWKB-937))|(1<<(MySqlParserST_POINTN-937))|(1<<(MySqlParserST_POLYFROMTEXT-937))|(1<<(MySqlParserST_POLYFROMWKB-937))|(1<<(MySqlParserST_POLYGONFROMTEXT-937))|(1<<(MySqlParserST_POLYGONFROMWKB-937))|(1<<(MySqlParserST_SRID-937))|(1<<(MySqlParserST_STARTPOINT-937))|(1<<(MySqlParserST_SYMDIFFERENCE-937))|(1<<(MySqlParserST_TOUCHES-937))|(1<<(MySqlParserST_UNION-937))|(1<<(MySqlParserST_WITHIN-937))|(1<<(MySqlParserST_X-937))|(1<<(MySqlParserST_Y-937))|(1<<(MySqlParserSUBDATE-937))|(1<<(MySqlParserSUBSTRING_INDEX-937))|(1<<(MySqlParserSUBTIME-937))|(1<<(MySqlParserSYSTEM_USER-937))|(1<<(MySqlParserTAN-937))|(1<<(MySqlParserTIMEDIFF-937)))) != 0) || (((_la-969)&-(0x1f+1)) == 0 && ((1<<uint((_la-969)))&((1<<(MySqlParserTIMESTAMPADD-969))|(1<<(MySqlParserTIMESTAMPDIFF-969))|(1<<(MySqlParserTIME_FORMAT-969))|(1<<(MySqlParserTIME_TO_SEC-969))|(1<<(MySqlParserTOUCHES-969))|(1<<(MySqlParserTO_BASE64-969))|(1<<(MySqlParserTO_DAYS-969))|(1<<(MySqlParserTO_SECONDS-969))|(1<<(MySqlParserUCASE-969))|(1<<(MySqlParserUNCOMPRESS-969))|(1<<(MySqlParserUNCOMPRESSED_LENGTH-969))|(1<<(MySqlParserUNHEX-969))|(1<<(MySqlParserUNIX_TIMESTAMP-969))|(1<<(MySqlParserUPDATEXML-969))|(1<<(MySqlParserUPPER-969))|(1<<(MySqlParserUUID-969))|(1<<(MySqlParserUUID_SHORT-969))|(1<<(MySqlParserVALIDATE_PASSWORD_STRENGTH-969))|(1<<(MySqlParserVERSION-969))|(1<<(MySqlParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS-969))|(1<<(MySqlParserWEEKDAY-969))|(1<<(MySqlParserWEEKOFYEAR-969))|(1<<(MySqlParserWEIGHT_STRING-969))|(1<<(MySqlParserWITHIN-969))|(1<<(MySqlParserYEARWEEK-969))|(1<<(MySqlParserY_FUNCTION-969))|(1<<(MySqlParserX_FUNCTION-969)))) != 0) || (((_la-1008)&-(0x1f+1)) == 0 && ((1<<uint((_la-1008)))&((1<<(MySqlParserPLUS-1008))|(1<<(MySqlParserMINUS-1008))|(1<<(MySqlParserEXCLAMATION_SYMBOL-1008))|(1<<(MySqlParserBIT_NOT_OP-1008))|(1<<(MySqlParserLR_BRACKET-1008))|(1<<(MySqlParserZERO_DECIMAL-1008))|(1<<(MySqlParserONE_DECIMAL-1008))|(1<<(MySqlParserTWO_DECIMAL-1008))|(1<<(MySqlParserCHARSET_REVERSE_QOUTE_STRING-1008))|(1<<(MySqlParserSTART_NATIONAL_STRING_LITERAL-1008))|(1<<(MySqlParserSTRING_LITERAL-1008))|(1<<(MySqlParserDECIMAL_LITERAL-1008))|(1<<(MySqlParserHEXADECIMAL_LITERAL-1008)))) != 0) || (((_la-1040)&-(0x1f+1)) == 0 && ((1<<uint((_la-1040)))&((1<<(MySqlParserREAL_LITERAL-1040))|(1<<(MySqlParserNULL_SPEC_LITERAL-1040))|(1<<(MySqlParserBIT_STRING-1040))|(1<<(MySqlParserSTRING_CHARSET_NAME-1040))|(1<<(MySqlParserID-1040))|(1<<(MySqlParserREVERSE_QUOTE_ID-1040))|(1<<(MySqlParserLOCAL_ID-1040))|(1<<(MySqlParserGLOBAL_ID-1040)))) != 0) {
			{
				p.SetState(961)
				p.FunctionArgs()
			}

		}
		{
			p.SetState(964)
			p.Match(MySqlParserRR_BRACKET)
		}

	case 5:
		localctx = NewPasswordFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(966)
			p.PasswordFunctionClause()
		}

	}

	return localctx
}

// ISpecificFunctionContext is an interface to support dynamic dispatch.
type ISpecificFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSpecificFunctionContext differentiates from other interfaces.
	IsSpecificFunctionContext()
}

type SpecificFunctionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySpecificFunctionContext() *SpecificFunctionContext {
	var p = new(SpecificFunctionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_specificFunction
	return p
}

func (*SpecificFunctionContext) IsSpecificFunctionContext() {}

func NewSpecificFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SpecificFunctionContext {
	var p = new(SpecificFunctionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_specificFunction

	return p
}

func (s *SpecificFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *SpecificFunctionContext) CopyFrom(ctx *SpecificFunctionContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *SpecificFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SpecificFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type PositionFunctionCallContext struct {
	*SpecificFunctionContext
	positionString     IStringLiteralContext
	positionExpression IExpressionContext
	inString           IStringLiteralContext
	inExpression       IExpressionContext
}

func NewPositionFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PositionFunctionCallContext {
	var p = new(PositionFunctionCallContext)

	p.SpecificFunctionContext = NewEmptySpecificFunctionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SpecificFunctionContext))

	return p
}

func (s *PositionFunctionCallContext) GetPositionString() IStringLiteralContext {
	return s.positionString
}

func (s *PositionFunctionCallContext) GetPositionExpression() IExpressionContext {
	return s.positionExpression
}

func (s *PositionFunctionCallContext) GetInString() IStringLiteralContext { return s.inString }

func (s *PositionFunctionCallContext) GetInExpression() IExpressionContext { return s.inExpression }

func (s *PositionFunctionCallContext) SetPositionString(v IStringLiteralContext) {
	s.positionString = v
}

func (s *PositionFunctionCallContext) SetPositionExpression(v IExpressionContext) {
	s.positionExpression = v
}

func (s *PositionFunctionCallContext) SetInString(v IStringLiteralContext) { s.inString = v }

func (s *PositionFunctionCallContext) SetInExpression(v IExpressionContext) { s.inExpression = v }

func (s *PositionFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PositionFunctionCallContext) POSITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserPOSITION, 0)
}

func (s *PositionFunctionCallContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *PositionFunctionCallContext) IN() antlr.TerminalNode {
	return s.GetToken(MySqlParserIN, 0)
}

func (s *PositionFunctionCallContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *PositionFunctionCallContext) AllStringLiteral() []IStringLiteralContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStringLiteralContext)(nil)).Elem())
	var tst = make([]IStringLiteralContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStringLiteralContext)
		}
	}

	return tst
}

func (s *PositionFunctionCallContext) StringLiteral(i int) IStringLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStringLiteralContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *PositionFunctionCallContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *PositionFunctionCallContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PositionFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPositionFunctionCall(s)
	}
}

func (s *PositionFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPositionFunctionCall(s)
	}
}

func (s *PositionFunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitPositionFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}

type TrimFunctionCallContext struct {
	*SpecificFunctionContext
	positioinForm    antlr.Token
	sourceString     IStringLiteralContext
	sourceExpression IExpressionContext
	fromString       IStringLiteralContext
	fromExpression   IExpressionContext
}

func NewTrimFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TrimFunctionCallContext {
	var p = new(TrimFunctionCallContext)

	p.SpecificFunctionContext = NewEmptySpecificFunctionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SpecificFunctionContext))

	return p
}

func (s *TrimFunctionCallContext) GetPositioinForm() antlr.Token { return s.positioinForm }

func (s *TrimFunctionCallContext) SetPositioinForm(v antlr.Token) { s.positioinForm = v }

func (s *TrimFunctionCallContext) GetSourceString() IStringLiteralContext { return s.sourceString }

func (s *TrimFunctionCallContext) GetSourceExpression() IExpressionContext { return s.sourceExpression }

func (s *TrimFunctionCallContext) GetFromString() IStringLiteralContext { return s.fromString }

func (s *TrimFunctionCallContext) GetFromExpression() IExpressionContext { return s.fromExpression }

func (s *TrimFunctionCallContext) SetSourceString(v IStringLiteralContext) { s.sourceString = v }

func (s *TrimFunctionCallContext) SetSourceExpression(v IExpressionContext) { s.sourceExpression = v }

func (s *TrimFunctionCallContext) SetFromString(v IStringLiteralContext) { s.fromString = v }

func (s *TrimFunctionCallContext) SetFromExpression(v IExpressionContext) { s.fromExpression = v }

func (s *TrimFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TrimFunctionCallContext) TRIM() antlr.TerminalNode {
	return s.GetToken(MySqlParserTRIM, 0)
}

func (s *TrimFunctionCallContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *TrimFunctionCallContext) FROM() antlr.TerminalNode {
	return s.GetToken(MySqlParserFROM, 0)
}

func (s *TrimFunctionCallContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *TrimFunctionCallContext) BOTH() antlr.TerminalNode {
	return s.GetToken(MySqlParserBOTH, 0)
}

func (s *TrimFunctionCallContext) LEADING() antlr.TerminalNode {
	return s.GetToken(MySqlParserLEADING, 0)
}

func (s *TrimFunctionCallContext) TRAILING() antlr.TerminalNode {
	return s.GetToken(MySqlParserTRAILING, 0)
}

func (s *TrimFunctionCallContext) AllStringLiteral() []IStringLiteralContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStringLiteralContext)(nil)).Elem())
	var tst = make([]IStringLiteralContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStringLiteralContext)
		}
	}

	return tst
}

func (s *TrimFunctionCallContext) StringLiteral(i int) IStringLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStringLiteralContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *TrimFunctionCallContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *TrimFunctionCallContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *TrimFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTrimFunctionCall(s)
	}
}

func (s *TrimFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTrimFunctionCall(s)
	}
}

func (s *TrimFunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTrimFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}

type SimpleFunctionCallContext struct {
	*SpecificFunctionContext
}

func NewSimpleFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleFunctionCallContext {
	var p = new(SimpleFunctionCallContext)

	p.SpecificFunctionContext = NewEmptySpecificFunctionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SpecificFunctionContext))

	return p
}

func (s *SimpleFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleFunctionCallContext) CURRENT_DATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCURRENT_DATE, 0)
}

func (s *SimpleFunctionCallContext) CURRENT_TIME() antlr.TerminalNode {
	return s.GetToken(MySqlParserCURRENT_TIME, 0)
}

func (s *SimpleFunctionCallContext) CURRENT_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(MySqlParserCURRENT_TIMESTAMP, 0)
}

func (s *SimpleFunctionCallContext) CURRENT_USER() antlr.TerminalNode {
	return s.GetToken(MySqlParserCURRENT_USER, 0)
}

func (s *SimpleFunctionCallContext) LOCALTIME() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCALTIME, 0)
}

func (s *SimpleFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSimpleFunctionCall(s)
	}
}

func (s *SimpleFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSimpleFunctionCall(s)
	}
}

func (s *SimpleFunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSimpleFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}

type CharFunctionCallContext struct {
	*SpecificFunctionContext
}

func NewCharFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CharFunctionCallContext {
	var p = new(CharFunctionCallContext)

	p.SpecificFunctionContext = NewEmptySpecificFunctionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SpecificFunctionContext))

	return p
}

func (s *CharFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CharFunctionCallContext) CHAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHAR, 0)
}

func (s *CharFunctionCallContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *CharFunctionCallContext) FunctionArgs() IFunctionArgsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionArgsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionArgsContext)
}

func (s *CharFunctionCallContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *CharFunctionCallContext) USING() antlr.TerminalNode {
	return s.GetToken(MySqlParserUSING, 0)
}

func (s *CharFunctionCallContext) CharsetName() ICharsetNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICharsetNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICharsetNameContext)
}

func (s *CharFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCharFunctionCall(s)
	}
}

func (s *CharFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCharFunctionCall(s)
	}
}

func (s *CharFunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCharFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}

type WeightFunctionCallContext struct {
	*SpecificFunctionContext
	stringFormat antlr.Token
}

func NewWeightFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *WeightFunctionCallContext {
	var p = new(WeightFunctionCallContext)

	p.SpecificFunctionContext = NewEmptySpecificFunctionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SpecificFunctionContext))

	return p
}

func (s *WeightFunctionCallContext) GetStringFormat() antlr.Token { return s.stringFormat }

func (s *WeightFunctionCallContext) SetStringFormat(v antlr.Token) { s.stringFormat = v }

func (s *WeightFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WeightFunctionCallContext) WEIGHT_STRING() antlr.TerminalNode {
	return s.GetToken(MySqlParserWEIGHT_STRING, 0)
}

func (s *WeightFunctionCallContext) AllLR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserLR_BRACKET)
}

func (s *WeightFunctionCallContext) LR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, i)
}

func (s *WeightFunctionCallContext) AllRR_BRACKET() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserRR_BRACKET)
}

func (s *WeightFunctionCallContext) RR_BRACKET(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, i)
}

func (s *WeightFunctionCallContext) StringLiteral() IStringLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStringLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *WeightFunctionCallContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WeightFunctionCallContext) AS() antlr.TerminalNode {
	return s.GetToken(MySqlParserAS, 0)
}

func (s *WeightFunctionCallContext) DecimalLiteral() IDecimalLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDecimalLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *WeightFunctionCallContext) LevelsInWeightString() ILevelsInWeightStringContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILevelsInWeightStringContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILevelsInWeightStringContext)
}

func (s *WeightFunctionCallContext) CHAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHAR, 0)
}

func (s *WeightFunctionCallContext) BINARY() antlr.TerminalNode {
	return s.GetToken(MySqlParserBINARY, 0)
}

func (s *WeightFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterWeightFunctionCall(s)
	}
}

func (s *WeightFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitWeightFunctionCall(s)
	}
}

func (s *WeightFunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitWeightFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}

type GetFormatFunctionCallContext struct {
	*SpecificFunctionContext
	datetimeFormat antlr.Token
}

func NewGetFormatFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GetFormatFunctionCallContext {
	var p = new(GetFormatFunctionCallContext)

	p.SpecificFunctionContext = NewEmptySpecificFunctionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SpecificFunctionContext))

	return p
}

func (s *GetFormatFunctionCallContext) GetDatetimeFormat() antlr.Token { return s.datetimeFormat }

func (s *GetFormatFunctionCallContext) SetDatetimeFormat(v antlr.Token) { s.datetimeFormat = v }

func (s *GetFormatFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GetFormatFunctionCallContext) GET_FORMAT() antlr.TerminalNode {
	return s.GetToken(MySqlParserGET_FORMAT, 0)
}

func (s *GetFormatFunctionCallContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *GetFormatFunctionCallContext) COMMA() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, 0)
}

func (s *GetFormatFunctionCallContext) StringLiteral() IStringLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStringLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *GetFormatFunctionCallContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *GetFormatFunctionCallContext) DATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATE, 0)
}

func (s *GetFormatFunctionCallContext) TIME() antlr.TerminalNode {
	return s.GetToken(MySqlParserTIME, 0)
}

func (s *GetFormatFunctionCallContext) DATETIME() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATETIME, 0)
}

func (s *GetFormatFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterGetFormatFunctionCall(s)
	}
}

func (s *GetFormatFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitGetFormatFunctionCall(s)
	}
}

func (s *GetFormatFunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitGetFormatFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}

type CaseFunctionCallContext struct {
	*SpecificFunctionContext
	elseArg IFunctionArgContext
}

func NewCaseFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CaseFunctionCallContext {
	var p = new(CaseFunctionCallContext)

	p.SpecificFunctionContext = NewEmptySpecificFunctionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SpecificFunctionContext))

	return p
}

func (s *CaseFunctionCallContext) GetElseArg() IFunctionArgContext { return s.elseArg }

func (s *CaseFunctionCallContext) SetElseArg(v IFunctionArgContext) { s.elseArg = v }

func (s *CaseFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseFunctionCallContext) CASE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCASE, 0)
}

func (s *CaseFunctionCallContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CaseFunctionCallContext) END() antlr.TerminalNode {
	return s.GetToken(MySqlParserEND, 0)
}

func (s *CaseFunctionCallContext) AllCaseFuncAlternative() []ICaseFuncAlternativeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICaseFuncAlternativeContext)(nil)).Elem())
	var tst = make([]ICaseFuncAlternativeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICaseFuncAlternativeContext)
		}
	}

	return tst
}

func (s *CaseFunctionCallContext) CaseFuncAlternative(i int) ICaseFuncAlternativeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICaseFuncAlternativeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICaseFuncAlternativeContext)
}

func (s *CaseFunctionCallContext) ELSE() antlr.TerminalNode {
	return s.GetToken(MySqlParserELSE, 0)
}

func (s *CaseFunctionCallContext) FunctionArg() IFunctionArgContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionArgContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionArgContext)
}

func (s *CaseFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCaseFunctionCall(s)
	}
}

func (s *CaseFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCaseFunctionCall(s)
	}
}

func (s *CaseFunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCaseFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExtractFunctionCallContext struct {
	*SpecificFunctionContext
	sourceString     IStringLiteralContext
	sourceExpression IExpressionContext
}

func NewExtractFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExtractFunctionCallContext {
	var p = new(ExtractFunctionCallContext)

	p.SpecificFunctionContext = NewEmptySpecificFunctionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SpecificFunctionContext))

	return p
}

func (s *ExtractFunctionCallContext) GetSourceString() IStringLiteralContext { return s.sourceString }

func (s *ExtractFunctionCallContext) GetSourceExpression() IExpressionContext {
	return s.sourceExpression
}

func (s *ExtractFunctionCallContext) SetSourceString(v IStringLiteralContext) { s.sourceString = v }

func (s *ExtractFunctionCallContext) SetSourceExpression(v IExpressionContext) {
	s.sourceExpression = v
}

func (s *ExtractFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtractFunctionCallContext) EXTRACT() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXTRACT, 0)
}

func (s *ExtractFunctionCallContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *ExtractFunctionCallContext) IntervalType() IIntervalTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntervalTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntervalTypeContext)
}

func (s *ExtractFunctionCallContext) FROM() antlr.TerminalNode {
	return s.GetToken(MySqlParserFROM, 0)
}

func (s *ExtractFunctionCallContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *ExtractFunctionCallContext) StringLiteral() IStringLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStringLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *ExtractFunctionCallContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExtractFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterExtractFunctionCall(s)
	}
}

func (s *ExtractFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitExtractFunctionCall(s)
	}
}

func (s *ExtractFunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitExtractFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}

type DataTypeFunctionCallContext struct {
	*SpecificFunctionContext
	separator antlr.Token
}

func NewDataTypeFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DataTypeFunctionCallContext {
	var p = new(DataTypeFunctionCallContext)

	p.SpecificFunctionContext = NewEmptySpecificFunctionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SpecificFunctionContext))

	return p
}

func (s *DataTypeFunctionCallContext) GetSeparator() antlr.Token { return s.separator }

func (s *DataTypeFunctionCallContext) SetSeparator(v antlr.Token) { s.separator = v }

func (s *DataTypeFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataTypeFunctionCallContext) CONVERT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONVERT, 0)
}

func (s *DataTypeFunctionCallContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *DataTypeFunctionCallContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *DataTypeFunctionCallContext) ConvertedDataType() IConvertedDataTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConvertedDataTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConvertedDataTypeContext)
}

func (s *DataTypeFunctionCallContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *DataTypeFunctionCallContext) COMMA() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, 0)
}

func (s *DataTypeFunctionCallContext) USING() antlr.TerminalNode {
	return s.GetToken(MySqlParserUSING, 0)
}

func (s *DataTypeFunctionCallContext) CharsetName() ICharsetNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICharsetNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICharsetNameContext)
}

func (s *DataTypeFunctionCallContext) CAST() antlr.TerminalNode {
	return s.GetToken(MySqlParserCAST, 0)
}

func (s *DataTypeFunctionCallContext) AS() antlr.TerminalNode {
	return s.GetToken(MySqlParserAS, 0)
}

func (s *DataTypeFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDataTypeFunctionCall(s)
	}
}

func (s *DataTypeFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDataTypeFunctionCall(s)
	}
}

func (s *DataTypeFunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitDataTypeFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}

type ValuesFunctionCallContext struct {
	*SpecificFunctionContext
}

func NewValuesFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ValuesFunctionCallContext {
	var p = new(ValuesFunctionCallContext)

	p.SpecificFunctionContext = NewEmptySpecificFunctionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SpecificFunctionContext))

	return p
}

func (s *ValuesFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValuesFunctionCallContext) VALUES() antlr.TerminalNode {
	return s.GetToken(MySqlParserVALUES, 0)
}

func (s *ValuesFunctionCallContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *ValuesFunctionCallContext) FullColumnName() IFullColumnNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFullColumnNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFullColumnNameContext)
}

func (s *ValuesFunctionCallContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *ValuesFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterValuesFunctionCall(s)
	}
}

func (s *ValuesFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitValuesFunctionCall(s)
	}
}

func (s *ValuesFunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitValuesFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}

type SubstrFunctionCallContext struct {
	*SpecificFunctionContext
	sub              antlr.Token
	sourceString     IStringLiteralContext
	sourceExpression IExpressionContext
	fromDecimal      IDecimalLiteralContext
	fromExpression   IExpressionContext
	forDecimal       IDecimalLiteralContext
	forExpression    IExpressionContext
}

func NewSubstrFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SubstrFunctionCallContext {
	var p = new(SubstrFunctionCallContext)

	p.SpecificFunctionContext = NewEmptySpecificFunctionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SpecificFunctionContext))

	return p
}

func (s *SubstrFunctionCallContext) GetSub() antlr.Token { return s.sub }

func (s *SubstrFunctionCallContext) SetSub(v antlr.Token) { s.sub = v }

func (s *SubstrFunctionCallContext) GetSourceString() IStringLiteralContext { return s.sourceString }

func (s *SubstrFunctionCallContext) GetSourceExpression() IExpressionContext {
	return s.sourceExpression
}

func (s *SubstrFunctionCallContext) GetFromDecimal() IDecimalLiteralContext { return s.fromDecimal }

func (s *SubstrFunctionCallContext) GetFromExpression() IExpressionContext { return s.fromExpression }

func (s *SubstrFunctionCallContext) GetForDecimal() IDecimalLiteralContext { return s.forDecimal }

func (s *SubstrFunctionCallContext) GetForExpression() IExpressionContext { return s.forExpression }

func (s *SubstrFunctionCallContext) SetSourceString(v IStringLiteralContext) { s.sourceString = v }

func (s *SubstrFunctionCallContext) SetSourceExpression(v IExpressionContext) { s.sourceExpression = v }

func (s *SubstrFunctionCallContext) SetFromDecimal(v IDecimalLiteralContext) { s.fromDecimal = v }

func (s *SubstrFunctionCallContext) SetFromExpression(v IExpressionContext) { s.fromExpression = v }

func (s *SubstrFunctionCallContext) SetForDecimal(v IDecimalLiteralContext) { s.forDecimal = v }

func (s *SubstrFunctionCallContext) SetForExpression(v IExpressionContext) { s.forExpression = v }

func (s *SubstrFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubstrFunctionCallContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *SubstrFunctionCallContext) FROM() antlr.TerminalNode {
	return s.GetToken(MySqlParserFROM, 0)
}

func (s *SubstrFunctionCallContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *SubstrFunctionCallContext) SUBSTR() antlr.TerminalNode {
	return s.GetToken(MySqlParserSUBSTR, 0)
}

func (s *SubstrFunctionCallContext) SUBSTRING() antlr.TerminalNode {
	return s.GetToken(MySqlParserSUBSTRING, 0)
}

func (s *SubstrFunctionCallContext) StringLiteral() IStringLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStringLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *SubstrFunctionCallContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *SubstrFunctionCallContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SubstrFunctionCallContext) AllDecimalLiteral() []IDecimalLiteralContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDecimalLiteralContext)(nil)).Elem())
	var tst = make([]IDecimalLiteralContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDecimalLiteralContext)
		}
	}

	return tst
}

func (s *SubstrFunctionCallContext) DecimalLiteral(i int) IDecimalLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDecimalLiteralContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *SubstrFunctionCallContext) FOR() antlr.TerminalNode {
	return s.GetToken(MySqlParserFOR, 0)
}

func (s *SubstrFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSubstrFunctionCall(s)
	}
}

func (s *SubstrFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSubstrFunctionCall(s)
	}
}

func (s *SubstrFunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSubstrFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) SpecificFunction() (localctx ISpecificFunctionContext) {
	localctx = NewSpecificFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, MySqlParserRULE_specificFunction)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1126)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 178, p.GetParserRuleContext()) {
	case 1:
		localctx = NewSimpleFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(969)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserCURRENT_USER || (((_la-251)&-(0x1f+1)) == 0 && ((1<<uint((_la-251)))&((1<<(MySqlParserCURRENT_DATE-251))|(1<<(MySqlParserCURRENT_TIME-251))|(1<<(MySqlParserCURRENT_TIMESTAMP-251))|(1<<(MySqlParserLOCALTIME-251)))) != 0)) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 2:
		localctx = NewDataTypeFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(970)
			p.Match(MySqlParserCONVERT)
		}
		{
			p.SetState(971)
			p.Match(MySqlParserLR_BRACKET)
		}
		{
			p.SetState(972)
			p.expression(0)
		}
		{
			p.SetState(973)

			var _m = p.Match(MySqlParserCOMMA)

			localctx.(*DataTypeFunctionCallContext).separator = _m
		}
		{
			p.SetState(974)
			p.ConvertedDataType()
		}
		{
			p.SetState(975)
			p.Match(MySqlParserRR_BRACKET)
		}

	case 3:
		localctx = NewDataTypeFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(977)
			p.Match(MySqlParserCONVERT)
		}
		{
			p.SetState(978)
			p.Match(MySqlParserLR_BRACKET)
		}
		{
			p.SetState(979)
			p.expression(0)
		}
		{
			p.SetState(980)
			p.Match(MySqlParserUSING)
		}
		{
			p.SetState(981)
			p.CharsetName()
		}
		{
			p.SetState(982)
			p.Match(MySqlParserRR_BRACKET)
		}

	case 4:
		localctx = NewDataTypeFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(984)
			p.Match(MySqlParserCAST)
		}
		{
			p.SetState(985)
			p.Match(MySqlParserLR_BRACKET)
		}
		{
			p.SetState(986)
			p.expression(0)
		}
		{
			p.SetState(987)
			p.Match(MySqlParserAS)
		}
		{
			p.SetState(988)
			p.ConvertedDataType()
		}
		{
			p.SetState(989)
			p.Match(MySqlParserRR_BRACKET)
		}

	case 5:
		localctx = NewValuesFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(991)
			p.Match(MySqlParserVALUES)
		}
		{
			p.SetState(992)
			p.Match(MySqlParserLR_BRACKET)
		}
		{
			p.SetState(993)
			p.FullColumnName()
		}
		{
			p.SetState(994)
			p.Match(MySqlParserRR_BRACKET)
		}

	case 6:
		localctx = NewCaseFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(996)
			p.Match(MySqlParserCASE)
		}
		{
			p.SetState(997)
			p.expression(0)
		}
		p.SetState(999)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == MySqlParserWHEN {
			{
				p.SetState(998)
				p.CaseFuncAlternative()
			}

			p.SetState(1001)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(1005)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserELSE {
			{
				p.SetState(1003)
				p.Match(MySqlParserELSE)
			}
			{
				p.SetState(1004)

				var _x = p.FunctionArg()

				localctx.(*CaseFunctionCallContext).elseArg = _x
			}

		}
		{
			p.SetState(1007)
			p.Match(MySqlParserEND)
		}

	case 7:
		localctx = NewCaseFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1009)
			p.Match(MySqlParserCASE)
		}
		p.SetState(1011)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == MySqlParserWHEN {
			{
				p.SetState(1010)
				p.CaseFuncAlternative()
			}

			p.SetState(1013)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(1017)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserELSE {
			{
				p.SetState(1015)
				p.Match(MySqlParserELSE)
			}
			{
				p.SetState(1016)

				var _x = p.FunctionArg()

				localctx.(*CaseFunctionCallContext).elseArg = _x
			}

		}
		{
			p.SetState(1019)
			p.Match(MySqlParserEND)
		}

	case 8:
		localctx = NewCharFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1021)
			p.Match(MySqlParserCHAR)
		}
		{
			p.SetState(1022)
			p.Match(MySqlParserLR_BRACKET)
		}
		{
			p.SetState(1023)
			p.FunctionArgs()
		}
		p.SetState(1026)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserUSING {
			{
				p.SetState(1024)
				p.Match(MySqlParserUSING)
			}
			{
				p.SetState(1025)
				p.CharsetName()
			}

		}
		{
			p.SetState(1028)
			p.Match(MySqlParserRR_BRACKET)
		}

	case 9:
		localctx = NewPositionFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1030)
			p.Match(MySqlParserPOSITION)
		}
		{
			p.SetState(1031)
			p.Match(MySqlParserLR_BRACKET)
		}
		p.SetState(1034)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 164, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1032)

				var _x = p.StringLiteral()

				localctx.(*PositionFunctionCallContext).positionString = _x
			}

		case 2:
			{
				p.SetState(1033)

				var _x = p.expression(0)

				localctx.(*PositionFunctionCallContext).positionExpression = _x
			}

		}
		{
			p.SetState(1036)
			p.Match(MySqlParserIN)
		}
		p.SetState(1039)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 165, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1037)

				var _x = p.StringLiteral()

				localctx.(*PositionFunctionCallContext).inString = _x
			}

		case 2:
			{
				p.SetState(1038)

				var _x = p.expression(0)

				localctx.(*PositionFunctionCallContext).inExpression = _x
			}

		}
		{
			p.SetState(1041)
			p.Match(MySqlParserRR_BRACKET)
		}

	case 10:
		localctx = NewSubstrFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1043)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*SubstrFunctionCallContext).sub = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserSUBSTR || _la == MySqlParserSUBSTRING) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*SubstrFunctionCallContext).sub = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1044)
			p.Match(MySqlParserLR_BRACKET)
		}
		p.SetState(1047)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 166, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1045)

				var _x = p.StringLiteral()

				localctx.(*SubstrFunctionCallContext).sourceString = _x
			}

		case 2:
			{
				p.SetState(1046)

				var _x = p.expression(0)

				localctx.(*SubstrFunctionCallContext).sourceExpression = _x
			}

		}
		{
			p.SetState(1049)
			p.Match(MySqlParserFROM)
		}
		p.SetState(1052)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 167, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1050)

				var _x = p.DecimalLiteral()

				localctx.(*SubstrFunctionCallContext).fromDecimal = _x
			}

		case 2:
			{
				p.SetState(1051)

				var _x = p.expression(0)

				localctx.(*SubstrFunctionCallContext).fromExpression = _x
			}

		}
		p.SetState(1059)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserFOR {
			{
				p.SetState(1054)
				p.Match(MySqlParserFOR)
			}
			p.SetState(1057)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 168, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(1055)

					var _x = p.DecimalLiteral()

					localctx.(*SubstrFunctionCallContext).forDecimal = _x
				}

			case 2:
				{
					p.SetState(1056)

					var _x = p.expression(0)

					localctx.(*SubstrFunctionCallContext).forExpression = _x
				}

			}

		}
		{
			p.SetState(1061)
			p.Match(MySqlParserRR_BRACKET)
		}

	case 11:
		localctx = NewTrimFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1063)
			p.Match(MySqlParserTRIM)
		}
		{
			p.SetState(1064)
			p.Match(MySqlParserLR_BRACKET)
		}
		{
			p.SetState(1065)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*TrimFunctionCallContext).positioinForm = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserBOTH || _la == MySqlParserLEADING || _la == MySqlParserTRAILING) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*TrimFunctionCallContext).positioinForm = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(1068)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 170, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1066)

				var _x = p.StringLiteral()

				localctx.(*TrimFunctionCallContext).sourceString = _x
			}

		} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 170, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(1067)

				var _x = p.expression(0)

				localctx.(*TrimFunctionCallContext).sourceExpression = _x
			}

		}
		{
			p.SetState(1070)
			p.Match(MySqlParserFROM)
		}
		p.SetState(1073)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 171, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1071)

				var _x = p.StringLiteral()

				localctx.(*TrimFunctionCallContext).fromString = _x
			}

		case 2:
			{
				p.SetState(1072)

				var _x = p.expression(0)

				localctx.(*TrimFunctionCallContext).fromExpression = _x
			}

		}
		{
			p.SetState(1075)
			p.Match(MySqlParserRR_BRACKET)
		}

	case 12:
		localctx = NewTrimFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1077)
			p.Match(MySqlParserTRIM)
		}
		{
			p.SetState(1078)
			p.Match(MySqlParserLR_BRACKET)
		}
		p.SetState(1081)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 172, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1079)

				var _x = p.StringLiteral()

				localctx.(*TrimFunctionCallContext).sourceString = _x
			}

		case 2:
			{
				p.SetState(1080)

				var _x = p.expression(0)

				localctx.(*TrimFunctionCallContext).sourceExpression = _x
			}

		}
		{
			p.SetState(1083)
			p.Match(MySqlParserFROM)
		}
		p.SetState(1086)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 173, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1084)

				var _x = p.StringLiteral()

				localctx.(*TrimFunctionCallContext).fromString = _x
			}

		case 2:
			{
				p.SetState(1085)

				var _x = p.expression(0)

				localctx.(*TrimFunctionCallContext).fromExpression = _x
			}

		}
		{
			p.SetState(1088)
			p.Match(MySqlParserRR_BRACKET)
		}

	case 13:
		localctx = NewWeightFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(1090)
			p.Match(MySqlParserWEIGHT_STRING)
		}
		{
			p.SetState(1091)
			p.Match(MySqlParserLR_BRACKET)
		}
		p.SetState(1094)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 174, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1092)
				p.StringLiteral()
			}

		case 2:
			{
				p.SetState(1093)
				p.expression(0)
			}

		}
		p.SetState(1102)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserAS {
			{
				p.SetState(1096)
				p.Match(MySqlParserAS)
			}
			{
				p.SetState(1097)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*WeightFunctionCallContext).stringFormat = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserCHAR || _la == MySqlParserBINARY) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*WeightFunctionCallContext).stringFormat = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(1098)
				p.Match(MySqlParserLR_BRACKET)
			}
			{
				p.SetState(1099)
				p.DecimalLiteral()
			}
			{
				p.SetState(1100)
				p.Match(MySqlParserRR_BRACKET)
			}

		}
		p.SetState(1105)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserLEVEL {
			{
				p.SetState(1104)
				p.LevelsInWeightString()
			}

		}
		{
			p.SetState(1107)
			p.Match(MySqlParserRR_BRACKET)
		}

	case 14:
		localctx = NewExtractFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(1109)
			p.Match(MySqlParserEXTRACT)
		}
		{
			p.SetState(1110)
			p.Match(MySqlParserLR_BRACKET)
		}
		{
			p.SetState(1111)
			p.IntervalType()
		}
		{
			p.SetState(1112)
			p.Match(MySqlParserFROM)
		}
		p.SetState(1115)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 177, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1113)

				var _x = p.StringLiteral()

				localctx.(*ExtractFunctionCallContext).sourceString = _x
			}

		case 2:
			{
				p.SetState(1114)

				var _x = p.expression(0)

				localctx.(*ExtractFunctionCallContext).sourceExpression = _x
			}

		}
		{
			p.SetState(1117)
			p.Match(MySqlParserRR_BRACKET)
		}

	case 15:
		localctx = NewGetFormatFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(1119)
			p.Match(MySqlParserGET_FORMAT)
		}
		{
			p.SetState(1120)
			p.Match(MySqlParserLR_BRACKET)
		}
		{
			p.SetState(1121)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*GetFormatFunctionCallContext).datetimeFormat = _lt

			_la = p.GetTokenStream().LA(1)

			if !(((_la-199)&-(0x1f+1)) == 0 && ((1<<uint((_la-199)))&((1<<(MySqlParserDATE-199))|(1<<(MySqlParserTIME-199))|(1<<(MySqlParserDATETIME-199)))) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*GetFormatFunctionCallContext).datetimeFormat = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1122)
			p.Match(MySqlParserCOMMA)
		}
		{
			p.SetState(1123)
			p.StringLiteral()
		}
		{
			p.SetState(1124)
			p.Match(MySqlParserRR_BRACKET)
		}

	}

	return localctx
}

// ICaseFuncAlternativeContext is an interface to support dynamic dispatch.
type ICaseFuncAlternativeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCondition returns the condition rule contexts.
	GetCondition() IFunctionArgContext

	// GetConsequent returns the consequent rule contexts.
	GetConsequent() IFunctionArgContext

	// SetCondition sets the condition rule contexts.
	SetCondition(IFunctionArgContext)

	// SetConsequent sets the consequent rule contexts.
	SetConsequent(IFunctionArgContext)

	// IsCaseFuncAlternativeContext differentiates from other interfaces.
	IsCaseFuncAlternativeContext()
}

type CaseFuncAlternativeContext struct {
	*antlr.BaseParserRuleContext
	parser     antlr.Parser
	condition  IFunctionArgContext
	consequent IFunctionArgContext
}

func NewEmptyCaseFuncAlternativeContext() *CaseFuncAlternativeContext {
	var p = new(CaseFuncAlternativeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_caseFuncAlternative
	return p
}

func (*CaseFuncAlternativeContext) IsCaseFuncAlternativeContext() {}

func NewCaseFuncAlternativeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CaseFuncAlternativeContext {
	var p = new(CaseFuncAlternativeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_caseFuncAlternative

	return p
}

func (s *CaseFuncAlternativeContext) GetParser() antlr.Parser { return s.parser }

func (s *CaseFuncAlternativeContext) GetCondition() IFunctionArgContext { return s.condition }

func (s *CaseFuncAlternativeContext) GetConsequent() IFunctionArgContext { return s.consequent }

func (s *CaseFuncAlternativeContext) SetCondition(v IFunctionArgContext) { s.condition = v }

func (s *CaseFuncAlternativeContext) SetConsequent(v IFunctionArgContext) { s.consequent = v }

func (s *CaseFuncAlternativeContext) WHEN() antlr.TerminalNode {
	return s.GetToken(MySqlParserWHEN, 0)
}

func (s *CaseFuncAlternativeContext) THEN() antlr.TerminalNode {
	return s.GetToken(MySqlParserTHEN, 0)
}

func (s *CaseFuncAlternativeContext) AllFunctionArg() []IFunctionArgContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFunctionArgContext)(nil)).Elem())
	var tst = make([]IFunctionArgContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFunctionArgContext)
		}
	}

	return tst
}

func (s *CaseFuncAlternativeContext) FunctionArg(i int) IFunctionArgContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionArgContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFunctionArgContext)
}

func (s *CaseFuncAlternativeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseFuncAlternativeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CaseFuncAlternativeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCaseFuncAlternative(s)
	}
}

func (s *CaseFuncAlternativeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCaseFuncAlternative(s)
	}
}

func (s *CaseFuncAlternativeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCaseFuncAlternative(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) CaseFuncAlternative() (localctx ICaseFuncAlternativeContext) {
	localctx = NewCaseFuncAlternativeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, MySqlParserRULE_caseFuncAlternative)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1128)
		p.Match(MySqlParserWHEN)
	}
	{
		p.SetState(1129)

		var _x = p.FunctionArg()

		localctx.(*CaseFuncAlternativeContext).condition = _x
	}
	{
		p.SetState(1130)
		p.Match(MySqlParserTHEN)
	}
	{
		p.SetState(1131)

		var _x = p.FunctionArg()

		localctx.(*CaseFuncAlternativeContext).consequent = _x
	}

	return localctx
}

// ILevelsInWeightStringContext is an interface to support dynamic dispatch.
type ILevelsInWeightStringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLevelsInWeightStringContext differentiates from other interfaces.
	IsLevelsInWeightStringContext()
}

type LevelsInWeightStringContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLevelsInWeightStringContext() *LevelsInWeightStringContext {
	var p = new(LevelsInWeightStringContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_levelsInWeightString
	return p
}

func (*LevelsInWeightStringContext) IsLevelsInWeightStringContext() {}

func NewLevelsInWeightStringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LevelsInWeightStringContext {
	var p = new(LevelsInWeightStringContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_levelsInWeightString

	return p
}

func (s *LevelsInWeightStringContext) GetParser() antlr.Parser { return s.parser }

func (s *LevelsInWeightStringContext) CopyFrom(ctx *LevelsInWeightStringContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *LevelsInWeightStringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LevelsInWeightStringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type LevelWeightRangeContext struct {
	*LevelsInWeightStringContext
	firstLevel IDecimalLiteralContext
	lastLevel  IDecimalLiteralContext
}

func NewLevelWeightRangeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LevelWeightRangeContext {
	var p = new(LevelWeightRangeContext)

	p.LevelsInWeightStringContext = NewEmptyLevelsInWeightStringContext()
	p.parser = parser
	p.CopyFrom(ctx.(*LevelsInWeightStringContext))

	return p
}

func (s *LevelWeightRangeContext) GetFirstLevel() IDecimalLiteralContext { return s.firstLevel }

func (s *LevelWeightRangeContext) GetLastLevel() IDecimalLiteralContext { return s.lastLevel }

func (s *LevelWeightRangeContext) SetFirstLevel(v IDecimalLiteralContext) { s.firstLevel = v }

func (s *LevelWeightRangeContext) SetLastLevel(v IDecimalLiteralContext) { s.lastLevel = v }

func (s *LevelWeightRangeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LevelWeightRangeContext) LEVEL() antlr.TerminalNode {
	return s.GetToken(MySqlParserLEVEL, 0)
}

func (s *LevelWeightRangeContext) MINUS() antlr.TerminalNode {
	return s.GetToken(MySqlParserMINUS, 0)
}

func (s *LevelWeightRangeContext) AllDecimalLiteral() []IDecimalLiteralContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDecimalLiteralContext)(nil)).Elem())
	var tst = make([]IDecimalLiteralContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDecimalLiteralContext)
		}
	}

	return tst
}

func (s *LevelWeightRangeContext) DecimalLiteral(i int) IDecimalLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDecimalLiteralContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *LevelWeightRangeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterLevelWeightRange(s)
	}
}

func (s *LevelWeightRangeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitLevelWeightRange(s)
	}
}

func (s *LevelWeightRangeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitLevelWeightRange(s)

	default:
		return t.VisitChildren(s)
	}
}

type LevelWeightListContext struct {
	*LevelsInWeightStringContext
}

func NewLevelWeightListContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LevelWeightListContext {
	var p = new(LevelWeightListContext)

	p.LevelsInWeightStringContext = NewEmptyLevelsInWeightStringContext()
	p.parser = parser
	p.CopyFrom(ctx.(*LevelsInWeightStringContext))

	return p
}

func (s *LevelWeightListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LevelWeightListContext) LEVEL() antlr.TerminalNode {
	return s.GetToken(MySqlParserLEVEL, 0)
}

func (s *LevelWeightListContext) AllLevelInWeightListElement() []ILevelInWeightListElementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILevelInWeightListElementContext)(nil)).Elem())
	var tst = make([]ILevelInWeightListElementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILevelInWeightListElementContext)
		}
	}

	return tst
}

func (s *LevelWeightListContext) LevelInWeightListElement(i int) ILevelInWeightListElementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILevelInWeightListElementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILevelInWeightListElementContext)
}

func (s *LevelWeightListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *LevelWeightListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *LevelWeightListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterLevelWeightList(s)
	}
}

func (s *LevelWeightListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitLevelWeightList(s)
	}
}

func (s *LevelWeightListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitLevelWeightList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) LevelsInWeightString() (localctx ILevelsInWeightStringContext) {
	localctx = NewLevelsInWeightStringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, MySqlParserRULE_levelsInWeightString)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1147)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 180, p.GetParserRuleContext()) {
	case 1:
		localctx = NewLevelWeightListContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1133)
			p.Match(MySqlParserLEVEL)
		}
		{
			p.SetState(1134)
			p.LevelInWeightListElement()
		}
		p.SetState(1139)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(1135)
				p.Match(MySqlParserCOMMA)
			}
			{
				p.SetState(1136)
				p.LevelInWeightListElement()
			}

			p.SetState(1141)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		localctx = NewLevelWeightRangeContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1142)
			p.Match(MySqlParserLEVEL)
		}
		{
			p.SetState(1143)

			var _x = p.DecimalLiteral()

			localctx.(*LevelWeightRangeContext).firstLevel = _x
		}
		{
			p.SetState(1144)
			p.Match(MySqlParserMINUS)
		}
		{
			p.SetState(1145)

			var _x = p.DecimalLiteral()

			localctx.(*LevelWeightRangeContext).lastLevel = _x
		}

	}

	return localctx
}

// ILevelInWeightListElementContext is an interface to support dynamic dispatch.
type ILevelInWeightListElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOrderType returns the orderType token.
	GetOrderType() antlr.Token

	// SetOrderType sets the orderType token.
	SetOrderType(antlr.Token)

	// IsLevelInWeightListElementContext differentiates from other interfaces.
	IsLevelInWeightListElementContext()
}

type LevelInWeightListElementContext struct {
	*antlr.BaseParserRuleContext
	parser    antlr.Parser
	orderType antlr.Token
}

func NewEmptyLevelInWeightListElementContext() *LevelInWeightListElementContext {
	var p = new(LevelInWeightListElementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_levelInWeightListElement
	return p
}

func (*LevelInWeightListElementContext) IsLevelInWeightListElementContext() {}

func NewLevelInWeightListElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LevelInWeightListElementContext {
	var p = new(LevelInWeightListElementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_levelInWeightListElement

	return p
}

func (s *LevelInWeightListElementContext) GetParser() antlr.Parser { return s.parser }

func (s *LevelInWeightListElementContext) GetOrderType() antlr.Token { return s.orderType }

func (s *LevelInWeightListElementContext) SetOrderType(v antlr.Token) { s.orderType = v }

func (s *LevelInWeightListElementContext) DecimalLiteral() IDecimalLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDecimalLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDecimalLiteralContext)
}

func (s *LevelInWeightListElementContext) ASC() antlr.TerminalNode {
	return s.GetToken(MySqlParserASC, 0)
}

func (s *LevelInWeightListElementContext) DESC() antlr.TerminalNode {
	return s.GetToken(MySqlParserDESC, 0)
}

func (s *LevelInWeightListElementContext) REVERSE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREVERSE, 0)
}

func (s *LevelInWeightListElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LevelInWeightListElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LevelInWeightListElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterLevelInWeightListElement(s)
	}
}

func (s *LevelInWeightListElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitLevelInWeightListElement(s)
	}
}

func (s *LevelInWeightListElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitLevelInWeightListElement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) LevelInWeightListElement() (localctx ILevelInWeightListElementContext) {
	localctx = NewLevelInWeightListElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, MySqlParserRULE_levelInWeightListElement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1149)
		p.DecimalLiteral()
	}
	p.SetState(1151)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == MySqlParserASC || _la == MySqlParserDESC || _la == MySqlParserREVERSE {
		{
			p.SetState(1150)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*LevelInWeightListElementContext).orderType = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserASC || _la == MySqlParserDESC || _la == MySqlParserREVERSE) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*LevelInWeightListElementContext).orderType = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

	return localctx
}

// IAggregateWindowedFunctionContext is an interface to support dynamic dispatch.
type IAggregateWindowedFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAggregateWindowedFunctionContext differentiates from other interfaces.
	IsAggregateWindowedFunctionContext()
}

type AggregateWindowedFunctionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAggregateWindowedFunctionContext() *AggregateWindowedFunctionContext {
	var p = new(AggregateWindowedFunctionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_aggregateWindowedFunction
	return p
}

func (*AggregateWindowedFunctionContext) IsAggregateWindowedFunctionContext() {}

func NewAggregateWindowedFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AggregateWindowedFunctionContext {
	var p = new(AggregateWindowedFunctionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_aggregateWindowedFunction

	return p
}

func (s *AggregateWindowedFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *AggregateWindowedFunctionContext) CopyFrom(ctx *AggregateWindowedFunctionContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *AggregateWindowedFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AggregateWindowedFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type AggregateWindowedFunction1Context struct {
	*AggregateWindowedFunctionContext
	operateName antlr.Token
	aggregator  antlr.Token
}

func NewAggregateWindowedFunction1Context(parser antlr.Parser, ctx antlr.ParserRuleContext) *AggregateWindowedFunction1Context {
	var p = new(AggregateWindowedFunction1Context)

	p.AggregateWindowedFunctionContext = NewEmptyAggregateWindowedFunctionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AggregateWindowedFunctionContext))

	return p
}

func (s *AggregateWindowedFunction1Context) GetOperateName() antlr.Token { return s.operateName }

func (s *AggregateWindowedFunction1Context) GetAggregator() antlr.Token { return s.aggregator }

func (s *AggregateWindowedFunction1Context) SetOperateName(v antlr.Token) { s.operateName = v }

func (s *AggregateWindowedFunction1Context) SetAggregator(v antlr.Token) { s.aggregator = v }

func (s *AggregateWindowedFunction1Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AggregateWindowedFunction1Context) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *AggregateWindowedFunction1Context) FunctionArg() IFunctionArgContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionArgContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionArgContext)
}

func (s *AggregateWindowedFunction1Context) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *AggregateWindowedFunction1Context) AVG() antlr.TerminalNode {
	return s.GetToken(MySqlParserAVG, 0)
}

func (s *AggregateWindowedFunction1Context) MAX() antlr.TerminalNode {
	return s.GetToken(MySqlParserMAX, 0)
}

func (s *AggregateWindowedFunction1Context) MIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserMIN, 0)
}

func (s *AggregateWindowedFunction1Context) SUM() antlr.TerminalNode {
	return s.GetToken(MySqlParserSUM, 0)
}

func (s *AggregateWindowedFunction1Context) ALL() antlr.TerminalNode {
	return s.GetToken(MySqlParserALL, 0)
}

func (s *AggregateWindowedFunction1Context) DISTINCT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDISTINCT, 0)
}

func (s *AggregateWindowedFunction1Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAggregateWindowedFunction1(s)
	}
}

func (s *AggregateWindowedFunction1Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAggregateWindowedFunction1(s)
	}
}

func (s *AggregateWindowedFunction1Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAggregateWindowedFunction1(s)

	default:
		return t.VisitChildren(s)
	}
}

type AggregateWindowedFunction2Context struct {
	*AggregateWindowedFunctionContext
	starArg    antlr.Token
	aggregator antlr.Token
}

func NewAggregateWindowedFunction2Context(parser antlr.Parser, ctx antlr.ParserRuleContext) *AggregateWindowedFunction2Context {
	var p = new(AggregateWindowedFunction2Context)

	p.AggregateWindowedFunctionContext = NewEmptyAggregateWindowedFunctionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AggregateWindowedFunctionContext))

	return p
}

func (s *AggregateWindowedFunction2Context) GetStarArg() antlr.Token { return s.starArg }

func (s *AggregateWindowedFunction2Context) GetAggregator() antlr.Token { return s.aggregator }

func (s *AggregateWindowedFunction2Context) SetStarArg(v antlr.Token) { s.starArg = v }

func (s *AggregateWindowedFunction2Context) SetAggregator(v antlr.Token) { s.aggregator = v }

func (s *AggregateWindowedFunction2Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AggregateWindowedFunction2Context) COUNT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOUNT, 0)
}

func (s *AggregateWindowedFunction2Context) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *AggregateWindowedFunction2Context) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *AggregateWindowedFunction2Context) FunctionArg() IFunctionArgContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionArgContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionArgContext)
}

func (s *AggregateWindowedFunction2Context) STAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTAR, 0)
}

func (s *AggregateWindowedFunction2Context) ALL() antlr.TerminalNode {
	return s.GetToken(MySqlParserALL, 0)
}

func (s *AggregateWindowedFunction2Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAggregateWindowedFunction2(s)
	}
}

func (s *AggregateWindowedFunction2Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAggregateWindowedFunction2(s)
	}
}

func (s *AggregateWindowedFunction2Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAggregateWindowedFunction2(s)

	default:
		return t.VisitChildren(s)
	}
}

type AggregateWindowedFunction3Context struct {
	*AggregateWindowedFunctionContext
	aggregator antlr.Token
}

func NewAggregateWindowedFunction3Context(parser antlr.Parser, ctx antlr.ParserRuleContext) *AggregateWindowedFunction3Context {
	var p = new(AggregateWindowedFunction3Context)

	p.AggregateWindowedFunctionContext = NewEmptyAggregateWindowedFunctionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AggregateWindowedFunctionContext))

	return p
}

func (s *AggregateWindowedFunction3Context) GetAggregator() antlr.Token { return s.aggregator }

func (s *AggregateWindowedFunction3Context) SetAggregator(v antlr.Token) { s.aggregator = v }

func (s *AggregateWindowedFunction3Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AggregateWindowedFunction3Context) COUNT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOUNT, 0)
}

func (s *AggregateWindowedFunction3Context) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *AggregateWindowedFunction3Context) FunctionArgs() IFunctionArgsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionArgsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionArgsContext)
}

func (s *AggregateWindowedFunction3Context) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *AggregateWindowedFunction3Context) DISTINCT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDISTINCT, 0)
}

func (s *AggregateWindowedFunction3Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAggregateWindowedFunction3(s)
	}
}

func (s *AggregateWindowedFunction3Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAggregateWindowedFunction3(s)
	}
}

func (s *AggregateWindowedFunction3Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAggregateWindowedFunction3(s)

	default:
		return t.VisitChildren(s)
	}
}

type AggregateWindowedFunction4Context struct {
	*AggregateWindowedFunctionContext
	linkName   antlr.Token
	aggregator antlr.Token
}

func NewAggregateWindowedFunction4Context(parser antlr.Parser, ctx antlr.ParserRuleContext) *AggregateWindowedFunction4Context {
	var p = new(AggregateWindowedFunction4Context)

	p.AggregateWindowedFunctionContext = NewEmptyAggregateWindowedFunctionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AggregateWindowedFunctionContext))

	return p
}

func (s *AggregateWindowedFunction4Context) GetLinkName() antlr.Token { return s.linkName }

func (s *AggregateWindowedFunction4Context) GetAggregator() antlr.Token { return s.aggregator }

func (s *AggregateWindowedFunction4Context) SetLinkName(v antlr.Token) { s.linkName = v }

func (s *AggregateWindowedFunction4Context) SetAggregator(v antlr.Token) { s.aggregator = v }

func (s *AggregateWindowedFunction4Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AggregateWindowedFunction4Context) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *AggregateWindowedFunction4Context) FunctionArg() IFunctionArgContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionArgContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionArgContext)
}

func (s *AggregateWindowedFunction4Context) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *AggregateWindowedFunction4Context) BIT_AND() antlr.TerminalNode {
	return s.GetToken(MySqlParserBIT_AND, 0)
}

func (s *AggregateWindowedFunction4Context) BIT_OR() antlr.TerminalNode {
	return s.GetToken(MySqlParserBIT_OR, 0)
}

func (s *AggregateWindowedFunction4Context) BIT_XOR() antlr.TerminalNode {
	return s.GetToken(MySqlParserBIT_XOR, 0)
}

func (s *AggregateWindowedFunction4Context) STD() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTD, 0)
}

func (s *AggregateWindowedFunction4Context) STDDEV() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTDDEV, 0)
}

func (s *AggregateWindowedFunction4Context) STDDEV_POP() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTDDEV_POP, 0)
}

func (s *AggregateWindowedFunction4Context) STDDEV_SAMP() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTDDEV_SAMP, 0)
}

func (s *AggregateWindowedFunction4Context) VAR_POP() antlr.TerminalNode {
	return s.GetToken(MySqlParserVAR_POP, 0)
}

func (s *AggregateWindowedFunction4Context) VAR_SAMP() antlr.TerminalNode {
	return s.GetToken(MySqlParserVAR_SAMP, 0)
}

func (s *AggregateWindowedFunction4Context) VARIANCE() antlr.TerminalNode {
	return s.GetToken(MySqlParserVARIANCE, 0)
}

func (s *AggregateWindowedFunction4Context) ALL() antlr.TerminalNode {
	return s.GetToken(MySqlParserALL, 0)
}

func (s *AggregateWindowedFunction4Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAggregateWindowedFunction4(s)
	}
}

func (s *AggregateWindowedFunction4Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAggregateWindowedFunction4(s)
	}
}

func (s *AggregateWindowedFunction4Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAggregateWindowedFunction4(s)

	default:
		return t.VisitChildren(s)
	}
}

type AggregateWindowedFunction5Context struct {
	*AggregateWindowedFunctionContext
	aggregator antlr.Token
	separator  antlr.Token
}

func NewAggregateWindowedFunction5Context(parser antlr.Parser, ctx antlr.ParserRuleContext) *AggregateWindowedFunction5Context {
	var p = new(AggregateWindowedFunction5Context)

	p.AggregateWindowedFunctionContext = NewEmptyAggregateWindowedFunctionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AggregateWindowedFunctionContext))

	return p
}

func (s *AggregateWindowedFunction5Context) GetAggregator() antlr.Token { return s.aggregator }

func (s *AggregateWindowedFunction5Context) GetSeparator() antlr.Token { return s.separator }

func (s *AggregateWindowedFunction5Context) SetAggregator(v antlr.Token) { s.aggregator = v }

func (s *AggregateWindowedFunction5Context) SetSeparator(v antlr.Token) { s.separator = v }

func (s *AggregateWindowedFunction5Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AggregateWindowedFunction5Context) GROUP_CONCAT() antlr.TerminalNode {
	return s.GetToken(MySqlParserGROUP_CONCAT, 0)
}

func (s *AggregateWindowedFunction5Context) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *AggregateWindowedFunction5Context) FunctionArgs() IFunctionArgsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionArgsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionArgsContext)
}

func (s *AggregateWindowedFunction5Context) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *AggregateWindowedFunction5Context) ORDER() antlr.TerminalNode {
	return s.GetToken(MySqlParserORDER, 0)
}

func (s *AggregateWindowedFunction5Context) BY() antlr.TerminalNode {
	return s.GetToken(MySqlParserBY, 0)
}

func (s *AggregateWindowedFunction5Context) AllOrderByExpression() []IOrderByExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOrderByExpressionContext)(nil)).Elem())
	var tst = make([]IOrderByExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOrderByExpressionContext)
		}
	}

	return tst
}

func (s *AggregateWindowedFunction5Context) OrderByExpression(i int) IOrderByExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOrderByExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOrderByExpressionContext)
}

func (s *AggregateWindowedFunction5Context) SEPARATOR() antlr.TerminalNode {
	return s.GetToken(MySqlParserSEPARATOR, 0)
}

func (s *AggregateWindowedFunction5Context) DISTINCT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDISTINCT, 0)
}

func (s *AggregateWindowedFunction5Context) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *AggregateWindowedFunction5Context) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *AggregateWindowedFunction5Context) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *AggregateWindowedFunction5Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterAggregateWindowedFunction5(s)
	}
}

func (s *AggregateWindowedFunction5Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitAggregateWindowedFunction5(s)
	}
}

func (s *AggregateWindowedFunction5Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitAggregateWindowedFunction5(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) AggregateWindowedFunction() (localctx IAggregateWindowedFunctionContext) {
	localctx = NewAggregateWindowedFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, MySqlParserRULE_aggregateWindowedFunction)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1209)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 190, p.GetParserRuleContext()) {
	case 1:
		localctx = NewAggregateWindowedFunction1Context(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1153)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*AggregateWindowedFunction1Context).operateName = _lt

			_la = p.GetTokenStream().LA(1)

			if !(((_la-235)&-(0x1f+1)) == 0 && ((1<<uint((_la-235)))&((1<<(MySqlParserAVG-235))|(1<<(MySqlParserMAX-235))|(1<<(MySqlParserMIN-235))|(1<<(MySqlParserSUM-235)))) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*AggregateWindowedFunction1Context).operateName = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1154)
			p.Match(MySqlParserLR_BRACKET)
		}
		p.SetState(1156)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserALL || _la == MySqlParserDISTINCT {
			{
				p.SetState(1155)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*AggregateWindowedFunction1Context).aggregator = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == MySqlParserALL || _la == MySqlParserDISTINCT) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*AggregateWindowedFunction1Context).aggregator = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(1158)
			p.FunctionArg()
		}
		{
			p.SetState(1159)
			p.Match(MySqlParserRR_BRACKET)
		}

	case 2:
		localctx = NewAggregateWindowedFunction2Context(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1161)
			p.Match(MySqlParserCOUNT)
		}
		{
			p.SetState(1162)
			p.Match(MySqlParserLR_BRACKET)
		}
		p.SetState(1168)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case MySqlParserSTAR:
			{
				p.SetState(1163)

				var _m = p.Match(MySqlParserSTAR)

				localctx.(*AggregateWindowedFunction2Context).starArg = _m
			}

		case MySqlParserALL, MySqlParserCASE, MySqlParserCAST, MySqlParserCONVERT, MySqlParserCURRENT, MySqlParserCURRENT_USER, MySqlParserDATABASE, MySqlParserDIAGNOSTICS, MySqlParserEXISTS, MySqlParserFALSE, MySqlParserIF, MySqlParserINSERT, MySqlParserINTERVAL, MySqlParserLEFT, MySqlParserNOT, MySqlParserNULL_LITERAL, MySqlParserNUMBER, MySqlParserREPLACE, MySqlParserRIGHT, MySqlParserSTACKED, MySqlParserTRUE, MySqlParserVALUES, MySqlParserDATE, MySqlParserTIME, MySqlParserTIMESTAMP, MySqlParserDATETIME, MySqlParserYEAR, MySqlParserCHAR, MySqlParserBINARY, MySqlParserTEXT, MySqlParserENUM, MySqlParserSERIAL, MySqlParserJSON_VALID, MySqlParserJSON_SCHEMA_VALID, MySqlParserAVG, MySqlParserBIT_AND, MySqlParserBIT_OR, MySqlParserBIT_XOR, MySqlParserCOUNT, MySqlParserGROUP_CONCAT, MySqlParserMAX, MySqlParserMIN, MySqlParserSTD, MySqlParserSTDDEV, MySqlParserSTDDEV_POP, MySqlParserSTDDEV_SAMP, MySqlParserSUM, MySqlParserVAR_POP, MySqlParserVAR_SAMP, MySqlParserVARIANCE, MySqlParserCURRENT_DATE, MySqlParserCURRENT_TIME, MySqlParserCURRENT_TIMESTAMP, MySqlParserLOCALTIME, MySqlParserCURDATE, MySqlParserCURTIME, MySqlParserDATE_ADD, MySqlParserDATE_SUB, MySqlParserEXTRACT, MySqlParserLOCALTIMESTAMP, MySqlParserNOW, MySqlParserPOSITION, MySqlParserSUBSTR, MySqlParserSUBSTRING, MySqlParserSYSDATE, MySqlParserTRIM, MySqlParserUTC_DATE, MySqlParserUTC_TIME, MySqlParserUTC_TIMESTAMP, MySqlParserACCOUNT, MySqlParserACTION, MySqlParserAFTER, MySqlParserAGGREGATE, MySqlParserALGORITHM, MySqlParserANY, MySqlParserAT, MySqlParserAUTHORS, MySqlParserAUTOCOMMIT, MySqlParserAUTOEXTEND_SIZE, MySqlParserAUTO_INCREMENT, MySqlParserAVG_ROW_LENGTH, MySqlParserBEGIN, MySqlParserBINLOG, MySqlParserBIT, MySqlParserBLOCK, MySqlParserBOOL, MySqlParserBOOLEAN, MySqlParserBTREE, MySqlParserCACHE, MySqlParserCASCADED, MySqlParserCHAIN, MySqlParserCHANGED, MySqlParserCHANNEL, MySqlParserCHECKSUM, MySqlParserPAGE_CHECKSUM, MySqlParserCIPHER, MySqlParserCLASS_ORIGIN, MySqlParserCLIENT, MySqlParserCLOSE, MySqlParserCOALESCE, MySqlParserCODE, MySqlParserCOLUMNS, MySqlParserCOLUMN_FORMAT, MySqlParserCOLUMN_NAME, MySqlParserCOMMENT, MySqlParserCOMMIT, MySqlParserCOMPACT, MySqlParserCOMPLETION, MySqlParserCOMPRESSED, MySqlParserCOMPRESSION, MySqlParserCONCURRENT, MySqlParserCONNECTION, MySqlParserCONSISTENT, MySqlParserCONSTRAINT_CATALOG, MySqlParserCONSTRAINT_SCHEMA, MySqlParserCONSTRAINT_NAME, MySqlParserCONTAINS, MySqlParserCONTEXT, MySqlParserCONTRIBUTORS, MySqlParserCOPY, MySqlParserCPU, MySqlParserCURSOR_NAME, MySqlParserDATA, MySqlParserDATAFILE, MySqlParserDEALLOCATE, MySqlParserDEFAULT_AUTH, MySqlParserDEFINER, MySqlParserDELAY_KEY_WRITE, MySqlParserDES_KEY_FILE, MySqlParserDIRECTORY, MySqlParserDISABLE, MySqlParserDISCARD, MySqlParserDISK, MySqlParserDO, MySqlParserDUMPFILE, MySqlParserDUPLICATE, MySqlParserDYNAMIC, MySqlParserENABLE, MySqlParserENCRYPTION, MySqlParserEND, MySqlParserENDS, MySqlParserENGINE, MySqlParserENGINES, MySqlParserERROR, MySqlParserERRORS, MySqlParserESCAPE, MySqlParserEVEN, MySqlParserEVENT, MySqlParserEVENTS, MySqlParserEVERY, MySqlParserEXCHANGE, MySqlParserEXCLUSIVE, MySqlParserEXPIRE, MySqlParserEXPORT, MySqlParserEXTENDED, MySqlParserEXTENT_SIZE, MySqlParserFAST, MySqlParserFAULTS, MySqlParserFIELDS, MySqlParserFILE_BLOCK_SIZE, MySqlParserFILTER, MySqlParserFIRST, MySqlParserFIXED, MySqlParserFLUSH, MySqlParserFOLLOWS, MySqlParserFOUND, MySqlParserFULL, MySqlParserFUNCTION, MySqlParserGENERAL, MySqlParserGLOBAL, MySqlParserGRANTS, MySqlParserGROUP_REPLICATION, MySqlParserHANDLER, MySqlParserHASH, MySqlParserHELP, MySqlParserHOST, MySqlParserHOSTS, MySqlParserIDENTIFIED, MySqlParserIGNORE_SERVER_IDS, MySqlParserIMPORT, MySqlParserINDEXES, MySqlParserINITIAL_SIZE, MySqlParserINPLACE, MySqlParserINSERT_METHOD, MySqlParserINSTALL, MySqlParserINSTANCE, MySqlParserINVISIBLE, MySqlParserINVOKER, MySqlParserIO, MySqlParserIO_THREAD, MySqlParserIPC, MySqlParserISOLATION, MySqlParserISSUER, MySqlParserJSON, MySqlParserKEY_BLOCK_SIZE, MySqlParserLANGUAGE, MySqlParserLAST, MySqlParserLEAVES, MySqlParserLESS, MySqlParserLEVEL, MySqlParserLIST, MySqlParserLOCAL, MySqlParserLOGFILE, MySqlParserLOGS, MySqlParserMASTER, MySqlParserMASTER_AUTO_POSITION, MySqlParserMASTER_CONNECT_RETRY, MySqlParserMASTER_DELAY, MySqlParserMASTER_HEARTBEAT_PERIOD, MySqlParserMASTER_HOST, MySqlParserMASTER_LOG_FILE, MySqlParserMASTER_LOG_POS, MySqlParserMASTER_PASSWORD, MySqlParserMASTER_PORT, MySqlParserMASTER_RETRY_COUNT, MySqlParserMASTER_SSL, MySqlParserMASTER_SSL_CA, MySqlParserMASTER_SSL_CAPATH, MySqlParserMASTER_SSL_CERT, MySqlParserMASTER_SSL_CIPHER, MySqlParserMASTER_SSL_CRL, MySqlParserMASTER_SSL_CRLPATH, MySqlParserMASTER_SSL_KEY, MySqlParserMASTER_TLS_VERSION, MySqlParserMASTER_USER, MySqlParserMAX_CONNECTIONS_PER_HOUR, MySqlParserMAX_QUERIES_PER_HOUR, MySqlParserMAX_ROWS, MySqlParserMAX_SIZE, MySqlParserMAX_UPDATES_PER_HOUR, MySqlParserMAX_USER_CONNECTIONS, MySqlParserMEDIUM, MySqlParserMEMBER, MySqlParserMERGE, MySqlParserMESSAGE_TEXT, MySqlParserMID, MySqlParserMIGRATE, MySqlParserMIN_ROWS, MySqlParserMODE, MySqlParserMODIFY, MySqlParserMUTEX, MySqlParserMYSQL, MySqlParserMYSQL_ERRNO, MySqlParserNAME, MySqlParserNAMES, MySqlParserNCHAR, MySqlParserNEVER, MySqlParserNEXT, MySqlParserNO, MySqlParserNODEGROUP, MySqlParserNONE, MySqlParserOFFLINE, MySqlParserOFFSET, MySqlParserOF, MySqlParserOJ, MySqlParserOLD_PASSWORD, MySqlParserONE, MySqlParserONLINE, MySqlParserONLY, MySqlParserOPEN, MySqlParserOPTIMIZER_COSTS, MySqlParserOPTIONS, MySqlParserOWNER, MySqlParserPACK_KEYS, MySqlParserPAGE, MySqlParserPARSER, MySqlParserPARTIAL, MySqlParserPARTITIONING, MySqlParserPARTITIONS, MySqlParserPASSWORD, MySqlParserPHASE, MySqlParserPLUGIN, MySqlParserPLUGIN_DIR, MySqlParserPLUGINS, MySqlParserPORT, MySqlParserPRECEDES, MySqlParserPREPARE, MySqlParserPRESERVE, MySqlParserPREV, MySqlParserPROCESSLIST, MySqlParserPROFILE, MySqlParserPROFILES, MySqlParserPROXY, MySqlParserQUERY, MySqlParserQUICK, MySqlParserREBUILD, MySqlParserRECOVER, MySqlParserREDO_BUFFER_SIZE, MySqlParserREDUNDANT, MySqlParserRELAY, MySqlParserRELAY_LOG_FILE, MySqlParserRELAY_LOG_POS, MySqlParserRELAYLOG, MySqlParserREMOVE, MySqlParserREORGANIZE, MySqlParserREPAIR, MySqlParserREPLICATE_DO_DB, MySqlParserREPLICATE_DO_TABLE, MySqlParserREPLICATE_IGNORE_DB, MySqlParserREPLICATE_IGNORE_TABLE, MySqlParserREPLICATE_REWRITE_DB, MySqlParserREPLICATE_WILD_DO_TABLE, MySqlParserREPLICATE_WILD_IGNORE_TABLE, MySqlParserREPLICATION, MySqlParserRESET, MySqlParserRESUME, MySqlParserRETURNED_SQLSTATE, MySqlParserRETURNS, MySqlParserROLE, MySqlParserROLLBACK, MySqlParserROLLUP, MySqlParserROTATE, MySqlParserROW, MySqlParserROWS, MySqlParserROW_FORMAT, MySqlParserSAVEPOINT, MySqlParserSCHEDULE, MySqlParserSECURITY, MySqlParserSERVER, MySqlParserSESSION, MySqlParserSHARE, MySqlParserSHARED, MySqlParserSIGNED, MySqlParserSIMPLE, MySqlParserSLAVE, MySqlParserSLOW, MySqlParserSNAPSHOT, MySqlParserSOCKET, MySqlParserSOME, MySqlParserSONAME, MySqlParserSOUNDS, MySqlParserSOURCE, MySqlParserSQL_AFTER_GTIDS, MySqlParserSQL_AFTER_MTS_GAPS, MySqlParserSQL_BEFORE_GTIDS, MySqlParserSQL_BUFFER_RESULT, MySqlParserSQL_CACHE, MySqlParserSQL_NO_CACHE, MySqlParserSQL_THREAD, MySqlParserSTART, MySqlParserSTARTS, MySqlParserSTATS_AUTO_RECALC, MySqlParserSTATS_PERSISTENT, MySqlParserSTATS_SAMPLE_PAGES, MySqlParserSTATUS, MySqlParserSTOP, MySqlParserSTORAGE, MySqlParserSTRING, MySqlParserSUBCLASS_ORIGIN, MySqlParserSUBJECT, MySqlParserSUBPARTITION, MySqlParserSUBPARTITIONS, MySqlParserSUSPEND, MySqlParserSWAPS, MySqlParserSWITCHES, MySqlParserTABLE_NAME, MySqlParserTABLESPACE, MySqlParserTEMPORARY, MySqlParserTEMPTABLE, MySqlParserTHAN, MySqlParserTRADITIONAL, MySqlParserTRANSACTION, MySqlParserTRANSACTIONAL, MySqlParserTRIGGERS, MySqlParserTRUNCATE, MySqlParserUNDEFINED, MySqlParserUNDOFILE, MySqlParserUNDO_BUFFER_SIZE, MySqlParserUNINSTALL, MySqlParserUNKNOWN, MySqlParserUNTIL, MySqlParserUPGRADE, MySqlParserUSER, MySqlParserUSE_FRM, MySqlParserUSER_RESOURCES, MySqlParserVALIDATION, MySqlParserVALUE, MySqlParserVARIABLES, MySqlParserVIEW, MySqlParserVISIBLE, MySqlParserWAIT, MySqlParserWARNINGS, MySqlParserWITHOUT, MySqlParserWORK, MySqlParserWRAPPER, MySqlParserX509, MySqlParserXA, MySqlParserXML, MySqlParserINTERNAL, MySqlParserQUARTER, MySqlParserMONTH, MySqlParserDAY, MySqlParserHOUR, MySqlParserMINUTE, MySqlParserWEEK, MySqlParserSECOND, MySqlParserMICROSECOND, MySqlParserTABLES, MySqlParserROUTINE, MySqlParserEXECUTE, MySqlParserFILE, MySqlParserPROCESS, MySqlParserRELOAD, MySqlParserSHUTDOWN, MySqlParserSUPER, MySqlParserPRIVILEGES, MySqlParserAUDIT_ADMIN, MySqlParserBACKUP_ADMIN, MySqlParserBINLOG_ADMIN, MySqlParserBINLOG_ENCRYPTION_ADMIN, MySqlParserCLONE_ADMIN, MySqlParserCONNECTION_ADMIN, MySqlParserENCRYPTION_KEY_ADMIN, MySqlParserFIREWALL_ADMIN, MySqlParserFIREWALL_USER, MySqlParserGROUP_REPLICATION_ADMIN, MySqlParserINNODB_REDO_LOG_ARCHIVE, MySqlParserNDB_STORED_USER, MySqlParserPERSIST_RO_VARIABLES_ADMIN, MySqlParserREPLICATION_APPLIER, MySqlParserREPLICATION_SLAVE_ADMIN, MySqlParserRESOURCE_GROUP_ADMIN, MySqlParserRESOURCE_GROUP_USER, MySqlParserROLE_ADMIN, MySqlParserSESSION_VARIABLES_ADMIN, MySqlParserSET_USER_ID, MySqlParserSHOW_ROUTINE, MySqlParserSYSTEM_VARIABLES_ADMIN, MySqlParserTABLE_ENCRYPTION_ADMIN, MySqlParserVERSION_TOKEN_ADMIN, MySqlParserXA_RECOVER_ADMIN, MySqlParserARMSCII8, MySqlParserASCII, MySqlParserBIG5, MySqlParserCP1250, MySqlParserCP1251, MySqlParserCP1256, MySqlParserCP1257, MySqlParserCP850, MySqlParserCP852, MySqlParserCP866, MySqlParserCP932, MySqlParserDEC8, MySqlParserEUCJPMS, MySqlParserEUCKR, MySqlParserGB2312, MySqlParserGBK, MySqlParserGEOSTD8, MySqlParserGREEK, MySqlParserHEBREW, MySqlParserHP8, MySqlParserKEYBCS2, MySqlParserKOI8R, MySqlParserKOI8U, MySqlParserLATIN1, MySqlParserLATIN2, MySqlParserLATIN5, MySqlParserLATIN7, MySqlParserMACCE, MySqlParserMACROMAN, MySqlParserSJIS, MySqlParserSWE7, MySqlParserTIS620, MySqlParserUCS2, MySqlParserUJIS, MySqlParserUTF16, MySqlParserUTF16LE, MySqlParserUTF32, MySqlParserUTF8, MySqlParserUTF8MB3, MySqlParserUTF8MB4, MySqlParserARCHIVE, MySqlParserBLACKHOLE, MySqlParserCSV, MySqlParserFEDERATED, MySqlParserINNODB, MySqlParserMEMORY, MySqlParserMRG_MYISAM, MySqlParserMYISAM, MySqlParserNDB, MySqlParserNDBCLUSTER, MySqlParserPERFORMANCE_SCHEMA, MySqlParserTOKUDB, MySqlParserREPEATABLE, MySqlParserCOMMITTED, MySqlParserUNCOMMITTED, MySqlParserSERIALIZABLE, MySqlParserGEOMETRYCOLLECTION, MySqlParserLINESTRING, MySqlParserMULTILINESTRING, MySqlParserMULTIPOINT, MySqlParserMULTIPOLYGON, MySqlParserPOINT, MySqlParserPOLYGON, MySqlParserABS, MySqlParserACOS, MySqlParserADDDATE, MySqlParserADDTIME, MySqlParserAES_DECRYPT, MySqlParserAES_ENCRYPT, MySqlParserAREA, MySqlParserASBINARY, MySqlParserASIN, MySqlParserASTEXT, MySqlParserASWKB, MySqlParserASWKT, MySqlParserASYMMETRIC_DECRYPT, MySqlParserASYMMETRIC_DERIVE, MySqlParserASYMMETRIC_ENCRYPT, MySqlParserASYMMETRIC_SIGN, MySqlParserASYMMETRIC_VERIFY, MySqlParserATAN, MySqlParserATAN2, MySqlParserBENCHMARK, MySqlParserBIN, MySqlParserBIT_COUNT, MySqlParserBIT_LENGTH, MySqlParserBUFFER, MySqlParserCATALOG_NAME, MySqlParserCEIL, MySqlParserCEILING, MySqlParserCENTROID, MySqlParserCHARACTER_LENGTH, MySqlParserCHARSET, MySqlParserCHAR_LENGTH, MySqlParserCOERCIBILITY, MySqlParserCOLLATION, MySqlParserCOMPRESS, MySqlParserCONCAT, MySqlParserCONCAT_WS, MySqlParserCONNECTION_ID, MySqlParserCONV, MySqlParserCONVERT_TZ, MySqlParserCOS, MySqlParserCOT, MySqlParserCRC32, MySqlParserCREATE_ASYMMETRIC_PRIV_KEY, MySqlParserCREATE_ASYMMETRIC_PUB_KEY, MySqlParserCREATE_DH_PARAMETERS, MySqlParserCREATE_DIGEST, MySqlParserCROSSES, MySqlParserDATEDIFF, MySqlParserDATE_FORMAT, MySqlParserDAYNAME, MySqlParserDAYOFMONTH, MySqlParserDAYOFWEEK, MySqlParserDAYOFYEAR, MySqlParserDECODE, MySqlParserDEGREES, MySqlParserDES_DECRYPT, MySqlParserDES_ENCRYPT, MySqlParserDIMENSION, MySqlParserDISJOINT, MySqlParserELT, MySqlParserENCODE, MySqlParserENCRYPT, MySqlParserENDPOINT, MySqlParserENVELOPE, MySqlParserEQUALS, MySqlParserEXP, MySqlParserEXPORT_SET, MySqlParserEXTERIORRING, MySqlParserEXTRACTVALUE, MySqlParserFIELD, MySqlParserFIND_IN_SET, MySqlParserFLOOR, MySqlParserFORMAT, MySqlParserFOUND_ROWS, MySqlParserFROM_BASE64, MySqlParserFROM_DAYS, MySqlParserFROM_UNIXTIME, MySqlParserGEOMCOLLFROMTEXT, MySqlParserGEOMCOLLFROMWKB, MySqlParserGEOMETRYCOLLECTIONFROMTEXT, MySqlParserGEOMETRYCOLLECTIONFROMWKB, MySqlParserGEOMETRYFROMTEXT, MySqlParserGEOMETRYFROMWKB, MySqlParserGEOMETRYN, MySqlParserGEOMETRYTYPE, MySqlParserGEOMFROMTEXT, MySqlParserGEOMFROMWKB, MySqlParserGET_FORMAT, MySqlParserGET_LOCK, MySqlParserGLENGTH, MySqlParserGREATEST, MySqlParserGTID_SUBSET, MySqlParserGTID_SUBTRACT, MySqlParserHEX, MySqlParserIFNULL, MySqlParserINET6_ATON, MySqlParserINET6_NTOA, MySqlParserINET_ATON, MySqlParserINET_NTOA, MySqlParserINSTR, MySqlParserINTERIORRINGN, MySqlParserINTERSECTS, MySqlParserISCLOSED, MySqlParserISEMPTY, MySqlParserISNULL, MySqlParserISSIMPLE, MySqlParserIS_FREE_LOCK, MySqlParserIS_IPV4, MySqlParserIS_IPV4_COMPAT, MySqlParserIS_IPV4_MAPPED, MySqlParserIS_IPV6, MySqlParserIS_USED_LOCK, MySqlParserLAST_INSERT_ID, MySqlParserLCASE, MySqlParserLEAST, MySqlParserLENGTH, MySqlParserLINEFROMTEXT, MySqlParserLINEFROMWKB, MySqlParserLINESTRINGFROMTEXT, MySqlParserLINESTRINGFROMWKB, MySqlParserLN, MySqlParserLOAD_FILE, MySqlParserLOCATE, MySqlParserLOG, MySqlParserLOG10, MySqlParserLOG2, MySqlParserLOWER, MySqlParserLPAD, MySqlParserLTRIM, MySqlParserMAKEDATE, MySqlParserMAKETIME, MySqlParserMAKE_SET, MySqlParserMASTER_POS_WAIT, MySqlParserMBRCONTAINS, MySqlParserMBRDISJOINT, MySqlParserMBREQUAL, MySqlParserMBRINTERSECTS, MySqlParserMBROVERLAPS, MySqlParserMBRTOUCHES, MySqlParserMBRWITHIN, MySqlParserMD5, MySqlParserMLINEFROMTEXT, MySqlParserMLINEFROMWKB, MySqlParserMONTHNAME, MySqlParserMPOINTFROMTEXT, MySqlParserMPOINTFROMWKB, MySqlParserMPOLYFROMTEXT, MySqlParserMPOLYFROMWKB, MySqlParserMULTILINESTRINGFROMTEXT, MySqlParserMULTILINESTRINGFROMWKB, MySqlParserMULTIPOINTFROMTEXT, MySqlParserMULTIPOINTFROMWKB, MySqlParserMULTIPOLYGONFROMTEXT, MySqlParserMULTIPOLYGONFROMWKB, MySqlParserNAME_CONST, MySqlParserNULLIF, MySqlParserNUMGEOMETRIES, MySqlParserNUMINTERIORRINGS, MySqlParserNUMPOINTS, MySqlParserOCT, MySqlParserOCTET_LENGTH, MySqlParserORD, MySqlParserOVERLAPS, MySqlParserPERIOD_ADD, MySqlParserPERIOD_DIFF, MySqlParserPI, MySqlParserPOINTFROMTEXT, MySqlParserPOINTFROMWKB, MySqlParserPOINTN, MySqlParserPOLYFROMTEXT, MySqlParserPOLYFROMWKB, MySqlParserPOLYGONFROMTEXT, MySqlParserPOLYGONFROMWKB, MySqlParserPOW, MySqlParserPOWER, MySqlParserQUOTE, MySqlParserRADIANS, MySqlParserRAND, MySqlParserRANDOM_BYTES, MySqlParserRELEASE_LOCK, MySqlParserREVERSE, MySqlParserROUND, MySqlParserROW_COUNT, MySqlParserRPAD, MySqlParserRTRIM, MySqlParserSEC_TO_TIME, MySqlParserSESSION_USER, MySqlParserSHA, MySqlParserSHA1, MySqlParserSHA2, MySqlParserSCHEMA_NAME, MySqlParserSIGN, MySqlParserSIN, MySqlParserSLEEP, MySqlParserSOUNDEX, MySqlParserSQL_THREAD_WAIT_AFTER_GTIDS, MySqlParserSQRT, MySqlParserSRID, MySqlParserSTARTPOINT, MySqlParserSTRCMP, MySqlParserSTR_TO_DATE, MySqlParserST_AREA, MySqlParserST_ASBINARY, MySqlParserST_ASTEXT, MySqlParserST_ASWKB, MySqlParserST_ASWKT, MySqlParserST_BUFFER, MySqlParserST_CENTROID, MySqlParserST_CONTAINS, MySqlParserST_CROSSES, MySqlParserST_DIFFERENCE, MySqlParserST_DIMENSION, MySqlParserST_DISJOINT, MySqlParserST_DISTANCE, MySqlParserST_ENDPOINT, MySqlParserST_ENVELOPE, MySqlParserST_EQUALS, MySqlParserST_EXTERIORRING, MySqlParserST_GEOMCOLLFROMTEXT, MySqlParserST_GEOMCOLLFROMTXT, MySqlParserST_GEOMCOLLFROMWKB, MySqlParserST_GEOMETRYCOLLECTIONFROMTEXT, MySqlParserST_GEOMETRYCOLLECTIONFROMWKB, MySqlParserST_GEOMETRYFROMTEXT, MySqlParserST_GEOMETRYFROMWKB, MySqlParserST_GEOMETRYN, MySqlParserST_GEOMETRYTYPE, MySqlParserST_GEOMFROMTEXT, MySqlParserST_GEOMFROMWKB, MySqlParserST_INTERIORRINGN, MySqlParserST_INTERSECTION, MySqlParserST_INTERSECTS, MySqlParserST_ISCLOSED, MySqlParserST_ISEMPTY, MySqlParserST_ISSIMPLE, MySqlParserST_LINEFROMTEXT, MySqlParserST_LINEFROMWKB, MySqlParserST_LINESTRINGFROMTEXT, MySqlParserST_LINESTRINGFROMWKB, MySqlParserST_NUMGEOMETRIES, MySqlParserST_NUMINTERIORRING, MySqlParserST_NUMINTERIORRINGS, MySqlParserST_NUMPOINTS, MySqlParserST_OVERLAPS, MySqlParserST_POINTFROMTEXT, MySqlParserST_POINTFROMWKB, MySqlParserST_POINTN, MySqlParserST_POLYFROMTEXT, MySqlParserST_POLYFROMWKB, MySqlParserST_POLYGONFROMTEXT, MySqlParserST_POLYGONFROMWKB, MySqlParserST_SRID, MySqlParserST_STARTPOINT, MySqlParserST_SYMDIFFERENCE, MySqlParserST_TOUCHES, MySqlParserST_UNION, MySqlParserST_WITHIN, MySqlParserST_X, MySqlParserST_Y, MySqlParserSUBDATE, MySqlParserSUBSTRING_INDEX, MySqlParserSUBTIME, MySqlParserSYSTEM_USER, MySqlParserTAN, MySqlParserTIMEDIFF, MySqlParserTIMESTAMPADD, MySqlParserTIMESTAMPDIFF, MySqlParserTIME_FORMAT, MySqlParserTIME_TO_SEC, MySqlParserTOUCHES, MySqlParserTO_BASE64, MySqlParserTO_DAYS, MySqlParserTO_SECONDS, MySqlParserUCASE, MySqlParserUNCOMPRESS, MySqlParserUNCOMPRESSED_LENGTH, MySqlParserUNHEX, MySqlParserUNIX_TIMESTAMP, MySqlParserUPDATEXML, MySqlParserUPPER, MySqlParserUUID, MySqlParserUUID_SHORT, MySqlParserVALIDATE_PASSWORD_STRENGTH, MySqlParserVERSION, MySqlParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS, MySqlParserWEEKDAY, MySqlParserWEEKOFYEAR, MySqlParserWEIGHT_STRING, MySqlParserWITHIN, MySqlParserYEARWEEK, MySqlParserY_FUNCTION, MySqlParserX_FUNCTION, MySqlParserPLUS, MySqlParserMINUS, MySqlParserEXCLAMATION_SYMBOL, MySqlParserBIT_NOT_OP, MySqlParserLR_BRACKET, MySqlParserZERO_DECIMAL, MySqlParserONE_DECIMAL, MySqlParserTWO_DECIMAL, MySqlParserCHARSET_REVERSE_QOUTE_STRING, MySqlParserSTART_NATIONAL_STRING_LITERAL, MySqlParserSTRING_LITERAL, MySqlParserDECIMAL_LITERAL, MySqlParserHEXADECIMAL_LITERAL, MySqlParserREAL_LITERAL, MySqlParserNULL_SPEC_LITERAL, MySqlParserBIT_STRING, MySqlParserSTRING_CHARSET_NAME, MySqlParserID, MySqlParserREVERSE_QUOTE_ID, MySqlParserLOCAL_ID, MySqlParserGLOBAL_ID:
			p.SetState(1165)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == MySqlParserALL {
				{
					p.SetState(1164)

					var _m = p.Match(MySqlParserALL)

					localctx.(*AggregateWindowedFunction2Context).aggregator = _m
				}

			}
			{
				p.SetState(1167)
				p.FunctionArg()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		{
			p.SetState(1170)
			p.Match(MySqlParserRR_BRACKET)
		}

	case 3:
		localctx = NewAggregateWindowedFunction3Context(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1171)
			p.Match(MySqlParserCOUNT)
		}
		{
			p.SetState(1172)
			p.Match(MySqlParserLR_BRACKET)
		}
		{
			p.SetState(1173)

			var _m = p.Match(MySqlParserDISTINCT)

			localctx.(*AggregateWindowedFunction3Context).aggregator = _m
		}
		{
			p.SetState(1174)
			p.FunctionArgs()
		}
		{
			p.SetState(1175)
			p.Match(MySqlParserRR_BRACKET)
		}

	case 4:
		localctx = NewAggregateWindowedFunction4Context(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1177)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*AggregateWindowedFunction4Context).linkName = _lt

			_la = p.GetTokenStream().LA(1)

			if !(((_la-236)&-(0x1f+1)) == 0 && ((1<<uint((_la-236)))&((1<<(MySqlParserBIT_AND-236))|(1<<(MySqlParserBIT_OR-236))|(1<<(MySqlParserBIT_XOR-236))|(1<<(MySqlParserSTD-236))|(1<<(MySqlParserSTDDEV-236))|(1<<(MySqlParserSTDDEV_POP-236))|(1<<(MySqlParserSTDDEV_SAMP-236))|(1<<(MySqlParserVAR_POP-236))|(1<<(MySqlParserVAR_SAMP-236))|(1<<(MySqlParserVARIANCE-236)))) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*AggregateWindowedFunction4Context).linkName = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1178)
			p.Match(MySqlParserLR_BRACKET)
		}
		p.SetState(1180)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserALL {
			{
				p.SetState(1179)

				var _m = p.Match(MySqlParserALL)

				localctx.(*AggregateWindowedFunction4Context).aggregator = _m
			}

		}
		{
			p.SetState(1182)
			p.FunctionArg()
		}
		{
			p.SetState(1183)
			p.Match(MySqlParserRR_BRACKET)
		}

	case 5:
		localctx = NewAggregateWindowedFunction5Context(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1185)
			p.Match(MySqlParserGROUP_CONCAT)
		}
		{
			p.SetState(1186)
			p.Match(MySqlParserLR_BRACKET)
		}
		p.SetState(1188)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserDISTINCT {
			{
				p.SetState(1187)

				var _m = p.Match(MySqlParserDISTINCT)

				localctx.(*AggregateWindowedFunction5Context).aggregator = _m
			}

		}
		{
			p.SetState(1190)
			p.FunctionArgs()
		}
		p.SetState(1201)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserORDER {
			{
				p.SetState(1191)
				p.Match(MySqlParserORDER)
			}
			{
				p.SetState(1192)
				p.Match(MySqlParserBY)
			}
			{
				p.SetState(1193)
				p.OrderByExpression()
			}
			p.SetState(1198)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == MySqlParserCOMMA {
				{
					p.SetState(1194)
					p.Match(MySqlParserCOMMA)
				}
				{
					p.SetState(1195)
					p.OrderByExpression()
				}

				p.SetState(1200)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}
		p.SetState(1205)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserSEPARATOR {
			{
				p.SetState(1203)
				p.Match(MySqlParserSEPARATOR)
			}
			{
				p.SetState(1204)

				var _m = p.Match(MySqlParserSTRING_LITERAL)

				localctx.(*AggregateWindowedFunction5Context).separator = _m
			}

		}
		{
			p.SetState(1207)
			p.Match(MySqlParserRR_BRACKET)
		}

	}

	return localctx
}

// IScalarFunctionNameContext is an interface to support dynamic dispatch.
type IScalarFunctionNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScalarFunctionNameContext differentiates from other interfaces.
	IsScalarFunctionNameContext()
}

type ScalarFunctionNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScalarFunctionNameContext() *ScalarFunctionNameContext {
	var p = new(ScalarFunctionNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_scalarFunctionName
	return p
}

func (*ScalarFunctionNameContext) IsScalarFunctionNameContext() {}

func NewScalarFunctionNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScalarFunctionNameContext {
	var p = new(ScalarFunctionNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_scalarFunctionName

	return p
}

func (s *ScalarFunctionNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ScalarFunctionNameContext) FunctionNameBase() IFunctionNameBaseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionNameBaseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionNameBaseContext)
}

func (s *ScalarFunctionNameContext) ASCII() antlr.TerminalNode {
	return s.GetToken(MySqlParserASCII, 0)
}

func (s *ScalarFunctionNameContext) CURDATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCURDATE, 0)
}

func (s *ScalarFunctionNameContext) CURRENT_DATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCURRENT_DATE, 0)
}

func (s *ScalarFunctionNameContext) CURRENT_TIME() antlr.TerminalNode {
	return s.GetToken(MySqlParserCURRENT_TIME, 0)
}

func (s *ScalarFunctionNameContext) CURRENT_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(MySqlParserCURRENT_TIMESTAMP, 0)
}

func (s *ScalarFunctionNameContext) CURTIME() antlr.TerminalNode {
	return s.GetToken(MySqlParserCURTIME, 0)
}

func (s *ScalarFunctionNameContext) DATE_ADD() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATE_ADD, 0)
}

func (s *ScalarFunctionNameContext) DATE_SUB() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATE_SUB, 0)
}

func (s *ScalarFunctionNameContext) IF() antlr.TerminalNode {
	return s.GetToken(MySqlParserIF, 0)
}

func (s *ScalarFunctionNameContext) INSERT() antlr.TerminalNode {
	return s.GetToken(MySqlParserINSERT, 0)
}

func (s *ScalarFunctionNameContext) LOCALTIME() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCALTIME, 0)
}

func (s *ScalarFunctionNameContext) LOCALTIMESTAMP() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCALTIMESTAMP, 0)
}

func (s *ScalarFunctionNameContext) MID() antlr.TerminalNode {
	return s.GetToken(MySqlParserMID, 0)
}

func (s *ScalarFunctionNameContext) NOW() antlr.TerminalNode {
	return s.GetToken(MySqlParserNOW, 0)
}

func (s *ScalarFunctionNameContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPLACE, 0)
}

func (s *ScalarFunctionNameContext) SUBSTR() antlr.TerminalNode {
	return s.GetToken(MySqlParserSUBSTR, 0)
}

func (s *ScalarFunctionNameContext) SUBSTRING() antlr.TerminalNode {
	return s.GetToken(MySqlParserSUBSTRING, 0)
}

func (s *ScalarFunctionNameContext) SYSDATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSYSDATE, 0)
}

func (s *ScalarFunctionNameContext) TRIM() antlr.TerminalNode {
	return s.GetToken(MySqlParserTRIM, 0)
}

func (s *ScalarFunctionNameContext) UTC_DATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserUTC_DATE, 0)
}

func (s *ScalarFunctionNameContext) UTC_TIME() antlr.TerminalNode {
	return s.GetToken(MySqlParserUTC_TIME, 0)
}

func (s *ScalarFunctionNameContext) UTC_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(MySqlParserUTC_TIMESTAMP, 0)
}

func (s *ScalarFunctionNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScalarFunctionNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScalarFunctionNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterScalarFunctionName(s)
	}
}

func (s *ScalarFunctionNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitScalarFunctionName(s)
	}
}

func (s *ScalarFunctionNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitScalarFunctionName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) ScalarFunctionName() (localctx IScalarFunctionNameContext) {
	localctx = NewScalarFunctionNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, MySqlParserRULE_scalarFunctionName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1234)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case MySqlParserDATABASE, MySqlParserLEFT, MySqlParserRIGHT, MySqlParserDATE, MySqlParserTIME, MySqlParserTIMESTAMP, MySqlParserYEAR, MySqlParserJSON_VALID, MySqlParserJSON_SCHEMA_VALID, MySqlParserCOUNT, MySqlParserPOSITION, MySqlParserINVISIBLE, MySqlParserVISIBLE, MySqlParserQUARTER, MySqlParserMONTH, MySqlParserDAY, MySqlParserHOUR, MySqlParserMINUTE, MySqlParserWEEK, MySqlParserSECOND, MySqlParserMICROSECOND, MySqlParserSESSION_VARIABLES_ADMIN, MySqlParserGEOMETRYCOLLECTION, MySqlParserLINESTRING, MySqlParserMULTILINESTRING, MySqlParserMULTIPOINT, MySqlParserMULTIPOLYGON, MySqlParserPOINT, MySqlParserPOLYGON, MySqlParserABS, MySqlParserACOS, MySqlParserADDDATE, MySqlParserADDTIME, MySqlParserAES_DECRYPT, MySqlParserAES_ENCRYPT, MySqlParserAREA, MySqlParserASBINARY, MySqlParserASIN, MySqlParserASTEXT, MySqlParserASWKB, MySqlParserASWKT, MySqlParserASYMMETRIC_DECRYPT, MySqlParserASYMMETRIC_DERIVE, MySqlParserASYMMETRIC_ENCRYPT, MySqlParserASYMMETRIC_SIGN, MySqlParserASYMMETRIC_VERIFY, MySqlParserATAN, MySqlParserATAN2, MySqlParserBENCHMARK, MySqlParserBIN, MySqlParserBIT_COUNT, MySqlParserBIT_LENGTH, MySqlParserBUFFER, MySqlParserCEIL, MySqlParserCEILING, MySqlParserCENTROID, MySqlParserCHARACTER_LENGTH, MySqlParserCHARSET, MySqlParserCHAR_LENGTH, MySqlParserCOERCIBILITY, MySqlParserCOLLATION, MySqlParserCOMPRESS, MySqlParserCONCAT, MySqlParserCONCAT_WS, MySqlParserCONNECTION_ID, MySqlParserCONV, MySqlParserCONVERT_TZ, MySqlParserCOS, MySqlParserCOT, MySqlParserCRC32, MySqlParserCREATE_ASYMMETRIC_PRIV_KEY, MySqlParserCREATE_ASYMMETRIC_PUB_KEY, MySqlParserCREATE_DH_PARAMETERS, MySqlParserCREATE_DIGEST, MySqlParserCROSSES, MySqlParserDATEDIFF, MySqlParserDATE_FORMAT, MySqlParserDAYNAME, MySqlParserDAYOFMONTH, MySqlParserDAYOFWEEK, MySqlParserDAYOFYEAR, MySqlParserDECODE, MySqlParserDEGREES, MySqlParserDES_DECRYPT, MySqlParserDES_ENCRYPT, MySqlParserDIMENSION, MySqlParserDISJOINT, MySqlParserELT, MySqlParserENCODE, MySqlParserENCRYPT, MySqlParserENDPOINT, MySqlParserENVELOPE, MySqlParserEQUALS, MySqlParserEXP, MySqlParserEXPORT_SET, MySqlParserEXTERIORRING, MySqlParserEXTRACTVALUE, MySqlParserFIELD, MySqlParserFIND_IN_SET, MySqlParserFLOOR, MySqlParserFORMAT, MySqlParserFOUND_ROWS, MySqlParserFROM_BASE64, MySqlParserFROM_DAYS, MySqlParserFROM_UNIXTIME, MySqlParserGEOMCOLLFROMTEXT, MySqlParserGEOMCOLLFROMWKB, MySqlParserGEOMETRYCOLLECTIONFROMTEXT, MySqlParserGEOMETRYCOLLECTIONFROMWKB, MySqlParserGEOMETRYFROMTEXT, MySqlParserGEOMETRYFROMWKB, MySqlParserGEOMETRYN, MySqlParserGEOMETRYTYPE, MySqlParserGEOMFROMTEXT, MySqlParserGEOMFROMWKB, MySqlParserGET_FORMAT, MySqlParserGET_LOCK, MySqlParserGLENGTH, MySqlParserGREATEST, MySqlParserGTID_SUBSET, MySqlParserGTID_SUBTRACT, MySqlParserHEX, MySqlParserIFNULL, MySqlParserINET6_ATON, MySqlParserINET6_NTOA, MySqlParserINET_ATON, MySqlParserINET_NTOA, MySqlParserINSTR, MySqlParserINTERIORRINGN, MySqlParserINTERSECTS, MySqlParserISCLOSED, MySqlParserISEMPTY, MySqlParserISNULL, MySqlParserISSIMPLE, MySqlParserIS_FREE_LOCK, MySqlParserIS_IPV4, MySqlParserIS_IPV4_COMPAT, MySqlParserIS_IPV4_MAPPED, MySqlParserIS_IPV6, MySqlParserIS_USED_LOCK, MySqlParserLAST_INSERT_ID, MySqlParserLCASE, MySqlParserLEAST, MySqlParserLENGTH, MySqlParserLINEFROMTEXT, MySqlParserLINEFROMWKB, MySqlParserLINESTRINGFROMTEXT, MySqlParserLINESTRINGFROMWKB, MySqlParserLN, MySqlParserLOAD_FILE, MySqlParserLOCATE, MySqlParserLOG, MySqlParserLOG10, MySqlParserLOG2, MySqlParserLOWER, MySqlParserLPAD, MySqlParserLTRIM, MySqlParserMAKEDATE, MySqlParserMAKETIME, MySqlParserMAKE_SET, MySqlParserMASTER_POS_WAIT, MySqlParserMBRCONTAINS, MySqlParserMBRDISJOINT, MySqlParserMBREQUAL, MySqlParserMBRINTERSECTS, MySqlParserMBROVERLAPS, MySqlParserMBRTOUCHES, MySqlParserMBRWITHIN, MySqlParserMD5, MySqlParserMLINEFROMTEXT, MySqlParserMLINEFROMWKB, MySqlParserMONTHNAME, MySqlParserMPOINTFROMTEXT, MySqlParserMPOINTFROMWKB, MySqlParserMPOLYFROMTEXT, MySqlParserMPOLYFROMWKB, MySqlParserMULTILINESTRINGFROMTEXT, MySqlParserMULTILINESTRINGFROMWKB, MySqlParserMULTIPOINTFROMTEXT, MySqlParserMULTIPOINTFROMWKB, MySqlParserMULTIPOLYGONFROMTEXT, MySqlParserMULTIPOLYGONFROMWKB, MySqlParserNAME_CONST, MySqlParserNULLIF, MySqlParserNUMGEOMETRIES, MySqlParserNUMINTERIORRINGS, MySqlParserNUMPOINTS, MySqlParserOCT, MySqlParserOCTET_LENGTH, MySqlParserORD, MySqlParserOVERLAPS, MySqlParserPERIOD_ADD, MySqlParserPERIOD_DIFF, MySqlParserPI, MySqlParserPOINTFROMTEXT, MySqlParserPOINTFROMWKB, MySqlParserPOINTN, MySqlParserPOLYFROMTEXT, MySqlParserPOLYFROMWKB, MySqlParserPOLYGONFROMTEXT, MySqlParserPOLYGONFROMWKB, MySqlParserPOW, MySqlParserPOWER, MySqlParserQUOTE, MySqlParserRADIANS, MySqlParserRAND, MySqlParserRANDOM_BYTES, MySqlParserRELEASE_LOCK, MySqlParserREVERSE, MySqlParserROUND, MySqlParserROW_COUNT, MySqlParserRPAD, MySqlParserRTRIM, MySqlParserSEC_TO_TIME, MySqlParserSESSION_USER, MySqlParserSHA, MySqlParserSHA1, MySqlParserSHA2, MySqlParserSIGN, MySqlParserSIN, MySqlParserSLEEP, MySqlParserSOUNDEX, MySqlParserSQL_THREAD_WAIT_AFTER_GTIDS, MySqlParserSQRT, MySqlParserSRID, MySqlParserSTARTPOINT, MySqlParserSTRCMP, MySqlParserSTR_TO_DATE, MySqlParserST_AREA, MySqlParserST_ASBINARY, MySqlParserST_ASTEXT, MySqlParserST_ASWKB, MySqlParserST_ASWKT, MySqlParserST_BUFFER, MySqlParserST_CENTROID, MySqlParserST_CONTAINS, MySqlParserST_CROSSES, MySqlParserST_DIFFERENCE, MySqlParserST_DIMENSION, MySqlParserST_DISJOINT, MySqlParserST_DISTANCE, MySqlParserST_ENDPOINT, MySqlParserST_ENVELOPE, MySqlParserST_EQUALS, MySqlParserST_EXTERIORRING, MySqlParserST_GEOMCOLLFROMTEXT, MySqlParserST_GEOMCOLLFROMTXT, MySqlParserST_GEOMCOLLFROMWKB, MySqlParserST_GEOMETRYCOLLECTIONFROMTEXT, MySqlParserST_GEOMETRYCOLLECTIONFROMWKB, MySqlParserST_GEOMETRYFROMTEXT, MySqlParserST_GEOMETRYFROMWKB, MySqlParserST_GEOMETRYN, MySqlParserST_GEOMETRYTYPE, MySqlParserST_GEOMFROMTEXT, MySqlParserST_GEOMFROMWKB, MySqlParserST_INTERIORRINGN, MySqlParserST_INTERSECTION, MySqlParserST_INTERSECTS, MySqlParserST_ISCLOSED, MySqlParserST_ISEMPTY, MySqlParserST_ISSIMPLE, MySqlParserST_LINEFROMTEXT, MySqlParserST_LINEFROMWKB, MySqlParserST_LINESTRINGFROMTEXT, MySqlParserST_LINESTRINGFROMWKB, MySqlParserST_NUMGEOMETRIES, MySqlParserST_NUMINTERIORRING, MySqlParserST_NUMINTERIORRINGS, MySqlParserST_NUMPOINTS, MySqlParserST_OVERLAPS, MySqlParserST_POINTFROMTEXT, MySqlParserST_POINTFROMWKB, MySqlParserST_POINTN, MySqlParserST_POLYFROMTEXT, MySqlParserST_POLYFROMWKB, MySqlParserST_POLYGONFROMTEXT, MySqlParserST_POLYGONFROMWKB, MySqlParserST_SRID, MySqlParserST_STARTPOINT, MySqlParserST_SYMDIFFERENCE, MySqlParserST_TOUCHES, MySqlParserST_UNION, MySqlParserST_WITHIN, MySqlParserST_X, MySqlParserST_Y, MySqlParserSUBDATE, MySqlParserSUBSTRING_INDEX, MySqlParserSUBTIME, MySqlParserSYSTEM_USER, MySqlParserTAN, MySqlParserTIMEDIFF, MySqlParserTIMESTAMPADD, MySqlParserTIMESTAMPDIFF, MySqlParserTIME_FORMAT, MySqlParserTIME_TO_SEC, MySqlParserTOUCHES, MySqlParserTO_BASE64, MySqlParserTO_DAYS, MySqlParserTO_SECONDS, MySqlParserUCASE, MySqlParserUNCOMPRESS, MySqlParserUNCOMPRESSED_LENGTH, MySqlParserUNHEX, MySqlParserUNIX_TIMESTAMP, MySqlParserUPDATEXML, MySqlParserUPPER, MySqlParserUUID, MySqlParserUUID_SHORT, MySqlParserVALIDATE_PASSWORD_STRENGTH, MySqlParserVERSION, MySqlParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS, MySqlParserWEEKDAY, MySqlParserWEEKOFYEAR, MySqlParserWEIGHT_STRING, MySqlParserWITHIN, MySqlParserYEARWEEK, MySqlParserY_FUNCTION, MySqlParserX_FUNCTION:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1211)
			p.FunctionNameBase()
		}

	case MySqlParserASCII:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1212)
			p.Match(MySqlParserASCII)
		}

	case MySqlParserCURDATE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1213)
			p.Match(MySqlParserCURDATE)
		}

	case MySqlParserCURRENT_DATE:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1214)
			p.Match(MySqlParserCURRENT_DATE)
		}

	case MySqlParserCURRENT_TIME:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1215)
			p.Match(MySqlParserCURRENT_TIME)
		}

	case MySqlParserCURRENT_TIMESTAMP:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1216)
			p.Match(MySqlParserCURRENT_TIMESTAMP)
		}

	case MySqlParserCURTIME:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1217)
			p.Match(MySqlParserCURTIME)
		}

	case MySqlParserDATE_ADD:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1218)
			p.Match(MySqlParserDATE_ADD)
		}

	case MySqlParserDATE_SUB:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1219)
			p.Match(MySqlParserDATE_SUB)
		}

	case MySqlParserIF:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1220)
			p.Match(MySqlParserIF)
		}

	case MySqlParserINSERT:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1221)
			p.Match(MySqlParserINSERT)
		}

	case MySqlParserLOCALTIME:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1222)
			p.Match(MySqlParserLOCALTIME)
		}

	case MySqlParserLOCALTIMESTAMP:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(1223)
			p.Match(MySqlParserLOCALTIMESTAMP)
		}

	case MySqlParserMID:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(1224)
			p.Match(MySqlParserMID)
		}

	case MySqlParserNOW:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(1225)
			p.Match(MySqlParserNOW)
		}

	case MySqlParserREPLACE:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(1226)
			p.Match(MySqlParserREPLACE)
		}

	case MySqlParserSUBSTR:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(1227)
			p.Match(MySqlParserSUBSTR)
		}

	case MySqlParserSUBSTRING:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(1228)
			p.Match(MySqlParserSUBSTRING)
		}

	case MySqlParserSYSDATE:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(1229)
			p.Match(MySqlParserSYSDATE)
		}

	case MySqlParserTRIM:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(1230)
			p.Match(MySqlParserTRIM)
		}

	case MySqlParserUTC_DATE:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(1231)
			p.Match(MySqlParserUTC_DATE)
		}

	case MySqlParserUTC_TIME:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(1232)
			p.Match(MySqlParserUTC_TIME)
		}

	case MySqlParserUTC_TIMESTAMP:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(1233)
			p.Match(MySqlParserUTC_TIMESTAMP)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IPasswordFunctionClauseContext is an interface to support dynamic dispatch.
type IPasswordFunctionClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetFunctionName returns the functionName token.
	GetFunctionName() antlr.Token

	// SetFunctionName sets the functionName token.
	SetFunctionName(antlr.Token)

	// IsPasswordFunctionClauseContext differentiates from other interfaces.
	IsPasswordFunctionClauseContext()
}

type PasswordFunctionClauseContext struct {
	*antlr.BaseParserRuleContext
	parser       antlr.Parser
	functionName antlr.Token
}

func NewEmptyPasswordFunctionClauseContext() *PasswordFunctionClauseContext {
	var p = new(PasswordFunctionClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_passwordFunctionClause
	return p
}

func (*PasswordFunctionClauseContext) IsPasswordFunctionClauseContext() {}

func NewPasswordFunctionClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PasswordFunctionClauseContext {
	var p = new(PasswordFunctionClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_passwordFunctionClause

	return p
}

func (s *PasswordFunctionClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *PasswordFunctionClauseContext) GetFunctionName() antlr.Token { return s.functionName }

func (s *PasswordFunctionClauseContext) SetFunctionName(v antlr.Token) { s.functionName = v }

func (s *PasswordFunctionClauseContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *PasswordFunctionClauseContext) FunctionArg() IFunctionArgContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionArgContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionArgContext)
}

func (s *PasswordFunctionClauseContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *PasswordFunctionClauseContext) PASSWORD() antlr.TerminalNode {
	return s.GetToken(MySqlParserPASSWORD, 0)
}

func (s *PasswordFunctionClauseContext) OLD_PASSWORD() antlr.TerminalNode {
	return s.GetToken(MySqlParserOLD_PASSWORD, 0)
}

func (s *PasswordFunctionClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PasswordFunctionClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PasswordFunctionClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPasswordFunctionClause(s)
	}
}

func (s *PasswordFunctionClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPasswordFunctionClause(s)
	}
}

func (s *PasswordFunctionClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitPasswordFunctionClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) PasswordFunctionClause() (localctx IPasswordFunctionClauseContext) {
	localctx = NewPasswordFunctionClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, MySqlParserRULE_passwordFunctionClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1236)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*PasswordFunctionClauseContext).functionName = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserOLD_PASSWORD || _la == MySqlParserPASSWORD) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*PasswordFunctionClauseContext).functionName = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1237)
		p.Match(MySqlParserLR_BRACKET)
	}
	{
		p.SetState(1238)
		p.FunctionArg()
	}
	{
		p.SetState(1239)
		p.Match(MySqlParserRR_BRACKET)
	}

	return localctx
}

// IFunctionArgsContext is an interface to support dynamic dispatch.
type IFunctionArgsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctionArgsContext differentiates from other interfaces.
	IsFunctionArgsContext()
}

type FunctionArgsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionArgsContext() *FunctionArgsContext {
	var p = new(FunctionArgsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_functionArgs
	return p
}

func (*FunctionArgsContext) IsFunctionArgsContext() {}

func NewFunctionArgsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionArgsContext {
	var p = new(FunctionArgsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_functionArgs

	return p
}

func (s *FunctionArgsContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionArgsContext) AllFunctionArg() []IFunctionArgContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFunctionArgContext)(nil)).Elem())
	var tst = make([]IFunctionArgContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFunctionArgContext)
		}
	}

	return tst
}

func (s *FunctionArgsContext) FunctionArg(i int) IFunctionArgContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionArgContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFunctionArgContext)
}

func (s *FunctionArgsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *FunctionArgsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *FunctionArgsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionArgsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionArgsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterFunctionArgs(s)
	}
}

func (s *FunctionArgsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitFunctionArgs(s)
	}
}

func (s *FunctionArgsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitFunctionArgs(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) FunctionArgs() (localctx IFunctionArgsContext) {
	localctx = NewFunctionArgsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, MySqlParserRULE_functionArgs)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1241)
		p.FunctionArg()
	}
	p.SetState(1246)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == MySqlParserCOMMA {
		{
			p.SetState(1242)
			p.Match(MySqlParserCOMMA)
		}
		{
			p.SetState(1243)
			p.FunctionArg()
		}

		p.SetState(1248)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IFunctionArgContext is an interface to support dynamic dispatch.
type IFunctionArgContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctionArgContext differentiates from other interfaces.
	IsFunctionArgContext()
}

type FunctionArgContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionArgContext() *FunctionArgContext {
	var p = new(FunctionArgContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_functionArg
	return p
}

func (*FunctionArgContext) IsFunctionArgContext() {}

func NewFunctionArgContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionArgContext {
	var p = new(FunctionArgContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_functionArg

	return p
}

func (s *FunctionArgContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionArgContext) Constant() IConstantContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstantContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *FunctionArgContext) FullColumnName() IFullColumnNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFullColumnNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFullColumnNameContext)
}

func (s *FunctionArgContext) FunctionCall() IFunctionCallContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionCallContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionCallContext)
}

func (s *FunctionArgContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *FunctionArgContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionArgContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionArgContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterFunctionArg(s)
	}
}

func (s *FunctionArgContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitFunctionArg(s)
	}
}

func (s *FunctionArgContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitFunctionArg(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) FunctionArg() (localctx IFunctionArgContext) {
	localctx = NewFunctionArgContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, MySqlParserRULE_functionArg)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1253)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 193, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1249)
			p.Constant()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1250)
			p.FullColumnName()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1251)
			p.FunctionCall()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1252)
			p.expression(0)
		}

	}

	return localctx
}

// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_expression
	return p
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) CopyFrom(ctx *ExpressionContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type IsExpressionContext struct {
	*ExpressionContext
	testValue antlr.Token
}

func NewIsExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IsExpressionContext {
	var p = new(IsExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *IsExpressionContext) GetTestValue() antlr.Token { return s.testValue }

func (s *IsExpressionContext) SetTestValue(v antlr.Token) { s.testValue = v }

func (s *IsExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IsExpressionContext) Predicate() IPredicateContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPredicateContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *IsExpressionContext) IS() antlr.TerminalNode {
	return s.GetToken(MySqlParserIS, 0)
}

func (s *IsExpressionContext) TRUE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTRUE, 0)
}

func (s *IsExpressionContext) FALSE() antlr.TerminalNode {
	return s.GetToken(MySqlParserFALSE, 0)
}

func (s *IsExpressionContext) UNKNOWN() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNKNOWN, 0)
}

func (s *IsExpressionContext) NOT() antlr.TerminalNode {
	return s.GetToken(MySqlParserNOT, 0)
}

func (s *IsExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterIsExpression(s)
	}
}

func (s *IsExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitIsExpression(s)
	}
}

func (s *IsExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitIsExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type NotExpressionContext struct {
	*ExpressionContext
	notOperator antlr.Token
}

func NewNotExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NotExpressionContext {
	var p = new(NotExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *NotExpressionContext) GetNotOperator() antlr.Token { return s.notOperator }

func (s *NotExpressionContext) SetNotOperator(v antlr.Token) { s.notOperator = v }

func (s *NotExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NotExpressionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *NotExpressionContext) NOT() antlr.TerminalNode {
	return s.GetToken(MySqlParserNOT, 0)
}

func (s *NotExpressionContext) EXCLAMATION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXCLAMATION_SYMBOL, 0)
}

func (s *NotExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterNotExpression(s)
	}
}

func (s *NotExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitNotExpression(s)
	}
}

func (s *NotExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitNotExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type LogicalExpressionContext struct {
	*ExpressionContext
}

func NewLogicalExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LogicalExpressionContext {
	var p = new(LogicalExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *LogicalExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalExpressionContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *LogicalExpressionContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LogicalExpressionContext) LogicalOperator() ILogicalOperatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILogicalOperatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILogicalOperatorContext)
}

func (s *LogicalExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterLogicalExpression(s)
	}
}

func (s *LogicalExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitLogicalExpression(s)
	}
}

func (s *LogicalExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitLogicalExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type PredicateExpressionContext struct {
	*ExpressionContext
}

func NewPredicateExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PredicateExpressionContext {
	var p = new(PredicateExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *PredicateExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredicateExpressionContext) Predicate() IPredicateContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPredicateContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *PredicateExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPredicateExpression(s)
	}
}

func (s *PredicateExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPredicateExpression(s)
	}
}

func (s *PredicateExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitPredicateExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) Expression() (localctx IExpressionContext) {
	return p.expression(0)
}

func (p *MySqlParser) expression(_p int) (localctx IExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 130
	p.EnterRecursionRule(localctx, 130, MySqlParserRULE_expression, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1266)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 195, p.GetParserRuleContext()) {
	case 1:
		localctx = NewNotExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(1256)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*NotExpressionContext).notOperator = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserNOT || _la == MySqlParserEXCLAMATION_SYMBOL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*NotExpressionContext).notOperator = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1257)
			p.expression(4)
		}

	case 2:
		localctx = NewIsExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1258)
			p.predicate(0)
		}
		{
			p.SetState(1259)
			p.Match(MySqlParserIS)
		}
		p.SetState(1261)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == MySqlParserNOT {
			{
				p.SetState(1260)
				p.Match(MySqlParserNOT)
			}

		}
		{
			p.SetState(1263)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*IsExpressionContext).testValue = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySqlParserFALSE || _la == MySqlParserTRUE || _la == MySqlParserUNKNOWN) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*IsExpressionContext).testValue = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 3:
		localctx = NewPredicateExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1265)
			p.predicate(0)
		}

	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1274)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 196, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewLogicalExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
			p.PushNewRecursionContext(localctx, _startState, MySqlParserRULE_expression)
			p.SetState(1268)

			if !(p.Precpred(p.GetParserRuleContext(), 3)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
			}
			{
				p.SetState(1269)
				p.LogicalOperator()
			}
			{
				p.SetState(1270)
				p.expression(4)
			}

		}
		p.SetState(1276)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 196, p.GetParserRuleContext())
	}

	return localctx
}

// IPredicateContext is an interface to support dynamic dispatch.
type IPredicateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPredicateContext differentiates from other interfaces.
	IsPredicateContext()
}

type PredicateContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPredicateContext() *PredicateContext {
	var p = new(PredicateContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_predicate
	return p
}

func (*PredicateContext) IsPredicateContext() {}

func NewPredicateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PredicateContext {
	var p = new(PredicateContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_predicate

	return p
}

func (s *PredicateContext) GetParser() antlr.Parser { return s.parser }

func (s *PredicateContext) CopyFrom(ctx *PredicateContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *PredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredicateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SoundsLikePredicateContext struct {
	*PredicateContext
}

func NewSoundsLikePredicateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SoundsLikePredicateContext {
	var p = new(SoundsLikePredicateContext)

	p.PredicateContext = NewEmptyPredicateContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PredicateContext))

	return p
}

func (s *SoundsLikePredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SoundsLikePredicateContext) AllPredicate() []IPredicateContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPredicateContext)(nil)).Elem())
	var tst = make([]IPredicateContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPredicateContext)
		}
	}

	return tst
}

func (s *SoundsLikePredicateContext) Predicate(i int) IPredicateContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPredicateContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *SoundsLikePredicateContext) SOUNDS() antlr.TerminalNode {
	return s.GetToken(MySqlParserSOUNDS, 0)
}

func (s *SoundsLikePredicateContext) LIKE() antlr.TerminalNode {
	return s.GetToken(MySqlParserLIKE, 0)
}

func (s *SoundsLikePredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSoundsLikePredicate(s)
	}
}

func (s *SoundsLikePredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSoundsLikePredicate(s)
	}
}

func (s *SoundsLikePredicateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSoundsLikePredicate(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExpressionAtomPredicateContext struct {
	*PredicateContext
}

func NewExpressionAtomPredicateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExpressionAtomPredicateContext {
	var p = new(ExpressionAtomPredicateContext)

	p.PredicateContext = NewEmptyPredicateContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PredicateContext))

	return p
}

func (s *ExpressionAtomPredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionAtomPredicateContext) ExpressionAtom() IExpressionAtomContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionAtomContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionAtomContext)
}

func (s *ExpressionAtomPredicateContext) LOCAL_ID() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCAL_ID, 0)
}

func (s *ExpressionAtomPredicateContext) VAR_ASSIGN() antlr.TerminalNode {
	return s.GetToken(MySqlParserVAR_ASSIGN, 0)
}

func (s *ExpressionAtomPredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterExpressionAtomPredicate(s)
	}
}

func (s *ExpressionAtomPredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitExpressionAtomPredicate(s)
	}
}

func (s *ExpressionAtomPredicateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitExpressionAtomPredicate(s)

	default:
		return t.VisitChildren(s)
	}
}

type JsonMemberOfPredicateContext struct {
	*PredicateContext
}

func NewJsonMemberOfPredicateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *JsonMemberOfPredicateContext {
	var p = new(JsonMemberOfPredicateContext)

	p.PredicateContext = NewEmptyPredicateContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PredicateContext))

	return p
}

func (s *JsonMemberOfPredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JsonMemberOfPredicateContext) AllPredicate() []IPredicateContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPredicateContext)(nil)).Elem())
	var tst = make([]IPredicateContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPredicateContext)
		}
	}

	return tst
}

func (s *JsonMemberOfPredicateContext) Predicate(i int) IPredicateContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPredicateContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *JsonMemberOfPredicateContext) MEMBER() antlr.TerminalNode {
	return s.GetToken(MySqlParserMEMBER, 0)
}

func (s *JsonMemberOfPredicateContext) OF() antlr.TerminalNode {
	return s.GetToken(MySqlParserOF, 0)
}

func (s *JsonMemberOfPredicateContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *JsonMemberOfPredicateContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *JsonMemberOfPredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterJsonMemberOfPredicate(s)
	}
}

func (s *JsonMemberOfPredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitJsonMemberOfPredicate(s)
	}
}

func (s *JsonMemberOfPredicateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitJsonMemberOfPredicate(s)

	default:
		return t.VisitChildren(s)
	}
}

type InPredicateContext struct {
	*PredicateContext
}

func NewInPredicateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InPredicateContext {
	var p = new(InPredicateContext)

	p.PredicateContext = NewEmptyPredicateContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PredicateContext))

	return p
}

func (s *InPredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InPredicateContext) Predicate() IPredicateContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPredicateContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *InPredicateContext) IN() antlr.TerminalNode {
	return s.GetToken(MySqlParserIN, 0)
}

func (s *InPredicateContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *InPredicateContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *InPredicateContext) SelectStatement() ISelectStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelectStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelectStatementContext)
}

func (s *InPredicateContext) Expressions() IExpressionsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionsContext)
}

func (s *InPredicateContext) NOT() antlr.TerminalNode {
	return s.GetToken(MySqlParserNOT, 0)
}

func (s *InPredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterInPredicate(s)
	}
}

func (s *InPredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitInPredicate(s)
	}
}

func (s *InPredicateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitInPredicate(s)

	default:
		return t.VisitChildren(s)
	}
}

type SubqueryComparasionPredicateContext struct {
	*PredicateContext
	quantifier antlr.Token
}

func NewSubqueryComparasionPredicateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SubqueryComparasionPredicateContext {
	var p = new(SubqueryComparasionPredicateContext)

	p.PredicateContext = NewEmptyPredicateContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PredicateContext))

	return p
}

func (s *SubqueryComparasionPredicateContext) GetQuantifier() antlr.Token { return s.quantifier }

func (s *SubqueryComparasionPredicateContext) SetQuantifier(v antlr.Token) { s.quantifier = v }

func (s *SubqueryComparasionPredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubqueryComparasionPredicateContext) Predicate() IPredicateContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPredicateContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *SubqueryComparasionPredicateContext) ComparisonOperator() IComparisonOperatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComparisonOperatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComparisonOperatorContext)
}

func (s *SubqueryComparasionPredicateContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *SubqueryComparasionPredicateContext) SelectStatement() ISelectStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelectStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelectStatementContext)
}

func (s *SubqueryComparasionPredicateContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *SubqueryComparasionPredicateContext) ALL() antlr.TerminalNode {
	return s.GetToken(MySqlParserALL, 0)
}

func (s *SubqueryComparasionPredicateContext) ANY() antlr.TerminalNode {
	return s.GetToken(MySqlParserANY, 0)
}

func (s *SubqueryComparasionPredicateContext) SOME() antlr.TerminalNode {
	return s.GetToken(MySqlParserSOME, 0)
}

func (s *SubqueryComparasionPredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSubqueryComparasionPredicate(s)
	}
}

func (s *SubqueryComparasionPredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSubqueryComparasionPredicate(s)
	}
}

func (s *SubqueryComparasionPredicateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSubqueryComparasionPredicate(s)

	default:
		return t.VisitChildren(s)
	}
}

type BetweenPredicateContext struct {
	*PredicateContext
}

func NewBetweenPredicateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BetweenPredicateContext {
	var p = new(BetweenPredicateContext)

	p.PredicateContext = NewEmptyPredicateContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PredicateContext))

	return p
}

func (s *BetweenPredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BetweenPredicateContext) AllPredicate() []IPredicateContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPredicateContext)(nil)).Elem())
	var tst = make([]IPredicateContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPredicateContext)
		}
	}

	return tst
}

func (s *BetweenPredicateContext) Predicate(i int) IPredicateContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPredicateContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *BetweenPredicateContext) BETWEEN() antlr.TerminalNode {
	return s.GetToken(MySqlParserBETWEEN, 0)
}

func (s *BetweenPredicateContext) AND() antlr.TerminalNode {
	return s.GetToken(MySqlParserAND, 0)
}

func (s *BetweenPredicateContext) NOT() antlr.TerminalNode {
	return s.GetToken(MySqlParserNOT, 0)
}

func (s *BetweenPredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterBetweenPredicate(s)
	}
}

func (s *BetweenPredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitBetweenPredicate(s)
	}
}

func (s *BetweenPredicateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitBetweenPredicate(s)

	default:
		return t.VisitChildren(s)
	}
}

type BinaryComparasionPredicateContext struct {
	*PredicateContext
	left  IPredicateContext
	right IPredicateContext
}

func NewBinaryComparasionPredicateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BinaryComparasionPredicateContext {
	var p = new(BinaryComparasionPredicateContext)

	p.PredicateContext = NewEmptyPredicateContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PredicateContext))

	return p
}

func (s *BinaryComparasionPredicateContext) GetLeft() IPredicateContext { return s.left }

func (s *BinaryComparasionPredicateContext) GetRight() IPredicateContext { return s.right }

func (s *BinaryComparasionPredicateContext) SetLeft(v IPredicateContext) { s.left = v }

func (s *BinaryComparasionPredicateContext) SetRight(v IPredicateContext) { s.right = v }

func (s *BinaryComparasionPredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BinaryComparasionPredicateContext) ComparisonOperator() IComparisonOperatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComparisonOperatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComparisonOperatorContext)
}

func (s *BinaryComparasionPredicateContext) AllPredicate() []IPredicateContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPredicateContext)(nil)).Elem())
	var tst = make([]IPredicateContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPredicateContext)
		}
	}

	return tst
}

func (s *BinaryComparasionPredicateContext) Predicate(i int) IPredicateContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPredicateContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *BinaryComparasionPredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterBinaryComparasionPredicate(s)
	}
}

func (s *BinaryComparasionPredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitBinaryComparasionPredicate(s)
	}
}

func (s *BinaryComparasionPredicateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitBinaryComparasionPredicate(s)

	default:
		return t.VisitChildren(s)
	}
}

type IsNullPredicateContext struct {
	*PredicateContext
}

func NewIsNullPredicateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IsNullPredicateContext {
	var p = new(IsNullPredicateContext)

	p.PredicateContext = NewEmptyPredicateContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PredicateContext))

	return p
}

func (s *IsNullPredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IsNullPredicateContext) Predicate() IPredicateContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPredicateContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *IsNullPredicateContext) IS() antlr.TerminalNode {
	return s.GetToken(MySqlParserIS, 0)
}

func (s *IsNullPredicateContext) NullNotnull() INullNotnullContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INullNotnullContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INullNotnullContext)
}

func (s *IsNullPredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterIsNullPredicate(s)
	}
}

func (s *IsNullPredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitIsNullPredicate(s)
	}
}

func (s *IsNullPredicateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitIsNullPredicate(s)

	default:
		return t.VisitChildren(s)
	}
}

type LikePredicateContext struct {
	*PredicateContext
}

func NewLikePredicateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LikePredicateContext {
	var p = new(LikePredicateContext)

	p.PredicateContext = NewEmptyPredicateContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PredicateContext))

	return p
}

func (s *LikePredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LikePredicateContext) AllPredicate() []IPredicateContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPredicateContext)(nil)).Elem())
	var tst = make([]IPredicateContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPredicateContext)
		}
	}

	return tst
}

func (s *LikePredicateContext) Predicate(i int) IPredicateContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPredicateContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *LikePredicateContext) LIKE() antlr.TerminalNode {
	return s.GetToken(MySqlParserLIKE, 0)
}

func (s *LikePredicateContext) NOT() antlr.TerminalNode {
	return s.GetToken(MySqlParserNOT, 0)
}

func (s *LikePredicateContext) ESCAPE() antlr.TerminalNode {
	return s.GetToken(MySqlParserESCAPE, 0)
}

func (s *LikePredicateContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING_LITERAL, 0)
}

func (s *LikePredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterLikePredicate(s)
	}
}

func (s *LikePredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitLikePredicate(s)
	}
}

func (s *LikePredicateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitLikePredicate(s)

	default:
		return t.VisitChildren(s)
	}
}

type RegexpPredicateContext struct {
	*PredicateContext
	regex antlr.Token
}

func NewRegexpPredicateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RegexpPredicateContext {
	var p = new(RegexpPredicateContext)

	p.PredicateContext = NewEmptyPredicateContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PredicateContext))

	return p
}

func (s *RegexpPredicateContext) GetRegex() antlr.Token { return s.regex }

func (s *RegexpPredicateContext) SetRegex(v antlr.Token) { s.regex = v }

func (s *RegexpPredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RegexpPredicateContext) AllPredicate() []IPredicateContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPredicateContext)(nil)).Elem())
	var tst = make([]IPredicateContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPredicateContext)
		}
	}

	return tst
}

func (s *RegexpPredicateContext) Predicate(i int) IPredicateContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPredicateContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *RegexpPredicateContext) REGEXP() antlr.TerminalNode {
	return s.GetToken(MySqlParserREGEXP, 0)
}

func (s *RegexpPredicateContext) RLIKE() antlr.TerminalNode {
	return s.GetToken(MySqlParserRLIKE, 0)
}

func (s *RegexpPredicateContext) NOT() antlr.TerminalNode {
	return s.GetToken(MySqlParserNOT, 0)
}

func (s *RegexpPredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterRegexpPredicate(s)
	}
}

func (s *RegexpPredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitRegexpPredicate(s)
	}
}

func (s *RegexpPredicateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitRegexpPredicate(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) Predicate() (localctx IPredicateContext) {
	return p.predicate(0)
}

func (p *MySqlParser) predicate(_p int) (localctx IPredicateContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewPredicateContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IPredicateContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 132
	p.EnterRecursionRule(localctx, 132, MySqlParserRULE_predicate, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	localctx = NewExpressionAtomPredicateContext(p, localctx)
	p.SetParserRuleContext(localctx)
	_prevctx = localctx

	p.SetState(1280)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 197, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1278)
			p.Match(MySqlParserLOCAL_ID)
		}
		{
			p.SetState(1279)
			p.Match(MySqlParserVAR_ASSIGN)
		}

	}
	{
		p.SetState(1282)
		p.expressionAtom(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1348)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 205, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(1346)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 204, p.GetParserRuleContext()) {
			case 1:
				localctx = NewBinaryComparasionPredicateContext(p, NewPredicateContext(p, _parentctx, _parentState))
				localctx.(*BinaryComparasionPredicateContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, MySqlParserRULE_predicate)
				p.SetState(1284)

				if !(p.Precpred(p.GetParserRuleContext(), 8)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 8)", ""))
				}
				{
					p.SetState(1285)
					p.ComparisonOperator()
				}
				{
					p.SetState(1286)

					var _x = p.predicate(9)

					localctx.(*BinaryComparasionPredicateContext).right = _x
				}

			case 2:
				localctx = NewBetweenPredicateContext(p, NewPredicateContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, MySqlParserRULE_predicate)
				p.SetState(1288)

				if !(p.Precpred(p.GetParserRuleContext(), 6)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 6)", ""))
				}
				p.SetState(1290)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == MySqlParserNOT {
					{
						p.SetState(1289)
						p.Match(MySqlParserNOT)
					}

				}
				{
					p.SetState(1292)
					p.Match(MySqlParserBETWEEN)
				}
				{
					p.SetState(1293)
					p.predicate(0)
				}
				{
					p.SetState(1294)
					p.Match(MySqlParserAND)
				}
				{
					p.SetState(1295)
					p.predicate(7)
				}

			case 3:
				localctx = NewSoundsLikePredicateContext(p, NewPredicateContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, MySqlParserRULE_predicate)
				p.SetState(1297)

				if !(p.Precpred(p.GetParserRuleContext(), 5)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
				}
				{
					p.SetState(1298)
					p.Match(MySqlParserSOUNDS)
				}
				{
					p.SetState(1299)
					p.Match(MySqlParserLIKE)
				}
				{
					p.SetState(1300)
					p.predicate(6)
				}

			case 4:
				localctx = NewRegexpPredicateContext(p, NewPredicateContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, MySqlParserRULE_predicate)
				p.SetState(1301)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
				}
				p.SetState(1303)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == MySqlParserNOT {
					{
						p.SetState(1302)
						p.Match(MySqlParserNOT)
					}

				}
				{
					p.SetState(1305)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*RegexpPredicateContext).regex = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == MySqlParserREGEXP || _la == MySqlParserRLIKE) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*RegexpPredicateContext).regex = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(1306)
					p.predicate(4)
				}

			case 5:
				localctx = NewInPredicateContext(p, NewPredicateContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, MySqlParserRULE_predicate)
				p.SetState(1307)

				if !(p.Precpred(p.GetParserRuleContext(), 10)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 10)", ""))
				}
				p.SetState(1309)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == MySqlParserNOT {
					{
						p.SetState(1308)
						p.Match(MySqlParserNOT)
					}

				}
				{
					p.SetState(1311)
					p.Match(MySqlParserIN)
				}
				{
					p.SetState(1312)
					p.Match(MySqlParserLR_BRACKET)
				}
				p.SetState(1315)
				p.GetErrorHandler().Sync(p)
				switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 201, p.GetParserRuleContext()) {
				case 1:
					{
						p.SetState(1313)
						p.SelectStatement()
					}

				case 2:
					{
						p.SetState(1314)
						p.Expressions()
					}

				}
				{
					p.SetState(1317)
					p.Match(MySqlParserRR_BRACKET)
				}

			case 6:
				localctx = NewIsNullPredicateContext(p, NewPredicateContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, MySqlParserRULE_predicate)
				p.SetState(1319)

				if !(p.Precpred(p.GetParserRuleContext(), 9)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 9)", ""))
				}
				{
					p.SetState(1320)
					p.Match(MySqlParserIS)
				}
				{
					p.SetState(1321)
					p.NullNotnull()
				}

			case 7:
				localctx = NewSubqueryComparasionPredicateContext(p, NewPredicateContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, MySqlParserRULE_predicate)
				p.SetState(1322)

				if !(p.Precpred(p.GetParserRuleContext(), 7)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 7)", ""))
				}
				{
					p.SetState(1323)
					p.ComparisonOperator()
				}
				{
					p.SetState(1324)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*SubqueryComparasionPredicateContext).quantifier = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == MySqlParserALL || _la == MySqlParserANY || _la == MySqlParserSOME) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*SubqueryComparasionPredicateContext).quantifier = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(1325)
					p.Match(MySqlParserLR_BRACKET)
				}
				{
					p.SetState(1326)
					p.SelectStatement()
				}
				{
					p.SetState(1327)
					p.Match(MySqlParserRR_BRACKET)
				}

			case 8:
				localctx = NewLikePredicateContext(p, NewPredicateContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, MySqlParserRULE_predicate)
				p.SetState(1329)

				if !(p.Precpred(p.GetParserRuleContext(), 4)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
				}
				p.SetState(1331)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == MySqlParserNOT {
					{
						p.SetState(1330)
						p.Match(MySqlParserNOT)
					}

				}
				{
					p.SetState(1333)
					p.Match(MySqlParserLIKE)
				}
				{
					p.SetState(1334)
					p.predicate(0)
				}
				p.SetState(1337)
				p.GetErrorHandler().Sync(p)

				if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 203, p.GetParserRuleContext()) == 1 {
					{
						p.SetState(1335)
						p.Match(MySqlParserESCAPE)
					}
					{
						p.SetState(1336)
						p.Match(MySqlParserSTRING_LITERAL)
					}

				}

			case 9:
				localctx = NewJsonMemberOfPredicateContext(p, NewPredicateContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, MySqlParserRULE_predicate)
				p.SetState(1339)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				}
				{
					p.SetState(1340)
					p.Match(MySqlParserMEMBER)
				}
				{
					p.SetState(1341)
					p.Match(MySqlParserOF)
				}
				{
					p.SetState(1342)
					p.Match(MySqlParserLR_BRACKET)
				}
				{
					p.SetState(1343)
					p.predicate(0)
				}
				{
					p.SetState(1344)
					p.Match(MySqlParserRR_BRACKET)
				}

			}

		}
		p.SetState(1350)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 205, p.GetParserRuleContext())
	}

	return localctx
}

// IExpressionAtomContext is an interface to support dynamic dispatch.
type IExpressionAtomContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpressionAtomContext differentiates from other interfaces.
	IsExpressionAtomContext()
}

type ExpressionAtomContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionAtomContext() *ExpressionAtomContext {
	var p = new(ExpressionAtomContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_expressionAtom
	return p
}

func (*ExpressionAtomContext) IsExpressionAtomContext() {}

func NewExpressionAtomContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionAtomContext {
	var p = new(ExpressionAtomContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_expressionAtom

	return p
}

func (s *ExpressionAtomContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionAtomContext) CopyFrom(ctx *ExpressionAtomContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *ExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionAtomContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type UnaryExpressionAtomContext struct {
	*ExpressionAtomContext
}

func NewUnaryExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnaryExpressionAtomContext {
	var p = new(UnaryExpressionAtomContext)

	p.ExpressionAtomContext = NewEmptyExpressionAtomContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionAtomContext))

	return p
}

func (s *UnaryExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnaryExpressionAtomContext) UnaryOperator() IUnaryOperatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnaryOperatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnaryOperatorContext)
}

func (s *UnaryExpressionAtomContext) ExpressionAtom() IExpressionAtomContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionAtomContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionAtomContext)
}

func (s *UnaryExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterUnaryExpressionAtom(s)
	}
}

func (s *UnaryExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitUnaryExpressionAtom(s)
	}
}

func (s *UnaryExpressionAtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitUnaryExpressionAtom(s)

	default:
		return t.VisitChildren(s)
	}
}

type CollateExpressionAtomContext struct {
	*ExpressionAtomContext
}

func NewCollateExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CollateExpressionAtomContext {
	var p = new(CollateExpressionAtomContext)

	p.ExpressionAtomContext = NewEmptyExpressionAtomContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionAtomContext))

	return p
}

func (s *CollateExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CollateExpressionAtomContext) ExpressionAtom() IExpressionAtomContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionAtomContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionAtomContext)
}

func (s *CollateExpressionAtomContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLLATE, 0)
}

func (s *CollateExpressionAtomContext) CollationName() ICollationNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICollationNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICollationNameContext)
}

func (s *CollateExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCollateExpressionAtom(s)
	}
}

func (s *CollateExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCollateExpressionAtom(s)
	}
}

func (s *CollateExpressionAtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCollateExpressionAtom(s)

	default:
		return t.VisitChildren(s)
	}
}

type SubqueryExpessionAtomContext struct {
	*ExpressionAtomContext
}

func NewSubqueryExpessionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SubqueryExpessionAtomContext {
	var p = new(SubqueryExpessionAtomContext)

	p.ExpressionAtomContext = NewEmptyExpressionAtomContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionAtomContext))

	return p
}

func (s *SubqueryExpessionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubqueryExpessionAtomContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *SubqueryExpessionAtomContext) SelectStatement() ISelectStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelectStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelectStatementContext)
}

func (s *SubqueryExpessionAtomContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *SubqueryExpessionAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterSubqueryExpessionAtom(s)
	}
}

func (s *SubqueryExpessionAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitSubqueryExpessionAtom(s)
	}
}

func (s *SubqueryExpessionAtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitSubqueryExpessionAtom(s)

	default:
		return t.VisitChildren(s)
	}
}

type MysqlVariableExpressionAtomContext struct {
	*ExpressionAtomContext
}

func NewMysqlVariableExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MysqlVariableExpressionAtomContext {
	var p = new(MysqlVariableExpressionAtomContext)

	p.ExpressionAtomContext = NewEmptyExpressionAtomContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionAtomContext))

	return p
}

func (s *MysqlVariableExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MysqlVariableExpressionAtomContext) MysqlVariable() IMysqlVariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMysqlVariableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMysqlVariableContext)
}

func (s *MysqlVariableExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterMysqlVariableExpressionAtom(s)
	}
}

func (s *MysqlVariableExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitMysqlVariableExpressionAtom(s)
	}
}

func (s *MysqlVariableExpressionAtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitMysqlVariableExpressionAtom(s)

	default:
		return t.VisitChildren(s)
	}
}

type NestedExpressionAtomContext struct {
	*ExpressionAtomContext
}

func NewNestedExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NestedExpressionAtomContext {
	var p = new(NestedExpressionAtomContext)

	p.ExpressionAtomContext = NewEmptyExpressionAtomContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionAtomContext))

	return p
}

func (s *NestedExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NestedExpressionAtomContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *NestedExpressionAtomContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *NestedExpressionAtomContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *NestedExpressionAtomContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *NestedExpressionAtomContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *NestedExpressionAtomContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *NestedExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterNestedExpressionAtom(s)
	}
}

func (s *NestedExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitNestedExpressionAtom(s)
	}
}

func (s *NestedExpressionAtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitNestedExpressionAtom(s)

	default:
		return t.VisitChildren(s)
	}
}

type NestedRowExpressionAtomContext struct {
	*ExpressionAtomContext
}

func NewNestedRowExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NestedRowExpressionAtomContext {
	var p = new(NestedRowExpressionAtomContext)

	p.ExpressionAtomContext = NewEmptyExpressionAtomContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionAtomContext))

	return p
}

func (s *NestedRowExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NestedRowExpressionAtomContext) ROW() antlr.TerminalNode {
	return s.GetToken(MySqlParserROW, 0)
}

func (s *NestedRowExpressionAtomContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *NestedRowExpressionAtomContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *NestedRowExpressionAtomContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *NestedRowExpressionAtomContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *NestedRowExpressionAtomContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserCOMMA)
}

func (s *NestedRowExpressionAtomContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMA, i)
}

func (s *NestedRowExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterNestedRowExpressionAtom(s)
	}
}

func (s *NestedRowExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitNestedRowExpressionAtom(s)
	}
}

func (s *NestedRowExpressionAtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitNestedRowExpressionAtom(s)

	default:
		return t.VisitChildren(s)
	}
}

type MathExpressionAtomContext struct {
	*ExpressionAtomContext
	left  IExpressionAtomContext
	right IExpressionAtomContext
}

func NewMathExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MathExpressionAtomContext {
	var p = new(MathExpressionAtomContext)

	p.ExpressionAtomContext = NewEmptyExpressionAtomContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionAtomContext))

	return p
}

func (s *MathExpressionAtomContext) GetLeft() IExpressionAtomContext { return s.left }

func (s *MathExpressionAtomContext) GetRight() IExpressionAtomContext { return s.right }

func (s *MathExpressionAtomContext) SetLeft(v IExpressionAtomContext) { s.left = v }

func (s *MathExpressionAtomContext) SetRight(v IExpressionAtomContext) { s.right = v }

func (s *MathExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MathExpressionAtomContext) MathOperator() IMathOperatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMathOperatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMathOperatorContext)
}

func (s *MathExpressionAtomContext) AllExpressionAtom() []IExpressionAtomContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionAtomContext)(nil)).Elem())
	var tst = make([]IExpressionAtomContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionAtomContext)
		}
	}

	return tst
}

func (s *MathExpressionAtomContext) ExpressionAtom(i int) IExpressionAtomContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionAtomContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionAtomContext)
}

func (s *MathExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterMathExpressionAtom(s)
	}
}

func (s *MathExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitMathExpressionAtom(s)
	}
}

func (s *MathExpressionAtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitMathExpressionAtom(s)

	default:
		return t.VisitChildren(s)
	}
}

type IntervalExpressionAtomContext struct {
	*ExpressionAtomContext
}

func NewIntervalExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IntervalExpressionAtomContext {
	var p = new(IntervalExpressionAtomContext)

	p.ExpressionAtomContext = NewEmptyExpressionAtomContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionAtomContext))

	return p
}

func (s *IntervalExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntervalExpressionAtomContext) INTERVAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserINTERVAL, 0)
}

func (s *IntervalExpressionAtomContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IntervalExpressionAtomContext) IntervalType() IIntervalTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntervalTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntervalTypeContext)
}

func (s *IntervalExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterIntervalExpressionAtom(s)
	}
}

func (s *IntervalExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitIntervalExpressionAtom(s)
	}
}

func (s *IntervalExpressionAtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitIntervalExpressionAtom(s)

	default:
		return t.VisitChildren(s)
	}
}

type JsonExpressionAtomContext struct {
	*ExpressionAtomContext
	left  IExpressionAtomContext
	right IExpressionAtomContext
}

func NewJsonExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *JsonExpressionAtomContext {
	var p = new(JsonExpressionAtomContext)

	p.ExpressionAtomContext = NewEmptyExpressionAtomContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionAtomContext))

	return p
}

func (s *JsonExpressionAtomContext) GetLeft() IExpressionAtomContext { return s.left }

func (s *JsonExpressionAtomContext) GetRight() IExpressionAtomContext { return s.right }

func (s *JsonExpressionAtomContext) SetLeft(v IExpressionAtomContext) { s.left = v }

func (s *JsonExpressionAtomContext) SetRight(v IExpressionAtomContext) { s.right = v }

func (s *JsonExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JsonExpressionAtomContext) JsonOperator() IJsonOperatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IJsonOperatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IJsonOperatorContext)
}

func (s *JsonExpressionAtomContext) AllExpressionAtom() []IExpressionAtomContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionAtomContext)(nil)).Elem())
	var tst = make([]IExpressionAtomContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionAtomContext)
		}
	}

	return tst
}

func (s *JsonExpressionAtomContext) ExpressionAtom(i int) IExpressionAtomContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionAtomContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionAtomContext)
}

func (s *JsonExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterJsonExpressionAtom(s)
	}
}

func (s *JsonExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitJsonExpressionAtom(s)
	}
}

func (s *JsonExpressionAtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitJsonExpressionAtom(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExistsExpessionAtomContext struct {
	*ExpressionAtomContext
}

func NewExistsExpessionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExistsExpessionAtomContext {
	var p = new(ExistsExpessionAtomContext)

	p.ExpressionAtomContext = NewEmptyExpressionAtomContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionAtomContext))

	return p
}

func (s *ExistsExpessionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExistsExpessionAtomContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXISTS, 0)
}

func (s *ExistsExpessionAtomContext) LR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserLR_BRACKET, 0)
}

func (s *ExistsExpessionAtomContext) SelectStatement() ISelectStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelectStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelectStatementContext)
}

func (s *ExistsExpessionAtomContext) RR_BRACKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRR_BRACKET, 0)
}

func (s *ExistsExpessionAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterExistsExpessionAtom(s)
	}
}

func (s *ExistsExpessionAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitExistsExpessionAtom(s)
	}
}

func (s *ExistsExpessionAtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitExistsExpessionAtom(s)

	default:
		return t.VisitChildren(s)
	}
}

type ConstantExpressionAtomContext struct {
	*ExpressionAtomContext
}

func NewConstantExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ConstantExpressionAtomContext {
	var p = new(ConstantExpressionAtomContext)

	p.ExpressionAtomContext = NewEmptyExpressionAtomContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionAtomContext))

	return p
}

func (s *ConstantExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstantExpressionAtomContext) Constant() IConstantContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstantContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *ConstantExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterConstantExpressionAtom(s)
	}
}

func (s *ConstantExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitConstantExpressionAtom(s)
	}
}

func (s *ConstantExpressionAtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitConstantExpressionAtom(s)

	default:
		return t.VisitChildren(s)
	}
}

type FunctionCallExpressionAtomContext struct {
	*ExpressionAtomContext
}

func NewFunctionCallExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FunctionCallExpressionAtomContext {
	var p = new(FunctionCallExpressionAtomContext)

	p.ExpressionAtomContext = NewEmptyExpressionAtomContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionAtomContext))

	return p
}

func (s *FunctionCallExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionCallExpressionAtomContext) FunctionCall() IFunctionCallContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionCallContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctionCallContext)
}

func (s *FunctionCallExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterFunctionCallExpressionAtom(s)
	}
}

func (s *FunctionCallExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitFunctionCallExpressionAtom(s)
	}
}

func (s *FunctionCallExpressionAtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitFunctionCallExpressionAtom(s)

	default:
		return t.VisitChildren(s)
	}
}

type BinaryExpressionAtomContext struct {
	*ExpressionAtomContext
}

func NewBinaryExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BinaryExpressionAtomContext {
	var p = new(BinaryExpressionAtomContext)

	p.ExpressionAtomContext = NewEmptyExpressionAtomContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionAtomContext))

	return p
}

func (s *BinaryExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BinaryExpressionAtomContext) BINARY() antlr.TerminalNode {
	return s.GetToken(MySqlParserBINARY, 0)
}

func (s *BinaryExpressionAtomContext) ExpressionAtom() IExpressionAtomContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionAtomContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionAtomContext)
}

func (s *BinaryExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterBinaryExpressionAtom(s)
	}
}

func (s *BinaryExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitBinaryExpressionAtom(s)
	}
}

func (s *BinaryExpressionAtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitBinaryExpressionAtom(s)

	default:
		return t.VisitChildren(s)
	}
}

type FullColumnNameExpressionAtomContext struct {
	*ExpressionAtomContext
}

func NewFullColumnNameExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FullColumnNameExpressionAtomContext {
	var p = new(FullColumnNameExpressionAtomContext)

	p.ExpressionAtomContext = NewEmptyExpressionAtomContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionAtomContext))

	return p
}

func (s *FullColumnNameExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FullColumnNameExpressionAtomContext) FullColumnName() IFullColumnNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFullColumnNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFullColumnNameContext)
}

func (s *FullColumnNameExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterFullColumnNameExpressionAtom(s)
	}
}

func (s *FullColumnNameExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitFullColumnNameExpressionAtom(s)
	}
}

func (s *FullColumnNameExpressionAtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitFullColumnNameExpressionAtom(s)

	default:
		return t.VisitChildren(s)
	}
}

type BitExpressionAtomContext struct {
	*ExpressionAtomContext
	left  IExpressionAtomContext
	right IExpressionAtomContext
}

func NewBitExpressionAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BitExpressionAtomContext {
	var p = new(BitExpressionAtomContext)

	p.ExpressionAtomContext = NewEmptyExpressionAtomContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionAtomContext))

	return p
}

func (s *BitExpressionAtomContext) GetLeft() IExpressionAtomContext { return s.left }

func (s *BitExpressionAtomContext) GetRight() IExpressionAtomContext { return s.right }

func (s *BitExpressionAtomContext) SetLeft(v IExpressionAtomContext) { s.left = v }

func (s *BitExpressionAtomContext) SetRight(v IExpressionAtomContext) { s.right = v }

func (s *BitExpressionAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitExpressionAtomContext) BitOperator() IBitOperatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBitOperatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBitOperatorContext)
}

func (s *BitExpressionAtomContext) AllExpressionAtom() []IExpressionAtomContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionAtomContext)(nil)).Elem())
	var tst = make([]IExpressionAtomContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionAtomContext)
		}
	}

	return tst
}

func (s *BitExpressionAtomContext) ExpressionAtom(i int) IExpressionAtomContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionAtomContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionAtomContext)
}

func (s *BitExpressionAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterBitExpressionAtom(s)
	}
}

func (s *BitExpressionAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitBitExpressionAtom(s)
	}
}

func (s *BitExpressionAtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitBitExpressionAtom(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) ExpressionAtom() (localctx IExpressionAtomContext) {
	return p.expressionAtom(0)
}

func (p *MySqlParser) expressionAtom(_p int) (localctx IExpressionAtomContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewExpressionAtomContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IExpressionAtomContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 134
	p.EnterRecursionRule(localctx, 134, MySqlParserRULE_expressionAtom, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1396)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 208, p.GetParserRuleContext()) {
	case 1:
		localctx = NewConstantExpressionAtomContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(1352)
			p.Constant()
		}

	case 2:
		localctx = NewFullColumnNameExpressionAtomContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1353)
			p.FullColumnName()
		}

	case 3:
		localctx = NewFunctionCallExpressionAtomContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1354)
			p.FunctionCall()
		}

	case 4:
		localctx = NewMysqlVariableExpressionAtomContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1355)
			p.MysqlVariable()
		}

	case 5:
		localctx = NewUnaryExpressionAtomContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1356)
			p.UnaryOperator()
		}
		{
			p.SetState(1357)
			p.expressionAtom(10)
		}

	case 6:
		localctx = NewBinaryExpressionAtomContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1359)
			p.Match(MySqlParserBINARY)
		}
		{
			p.SetState(1360)
			p.expressionAtom(9)
		}

	case 7:
		localctx = NewNestedExpressionAtomContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1361)
			p.Match(MySqlParserLR_BRACKET)
		}
		{
			p.SetState(1362)
			p.expression(0)
		}
		p.SetState(1367)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == MySqlParserCOMMA {
			{
				p.SetState(1363)
				p.Match(MySqlParserCOMMA)
			}
			{
				p.SetState(1364)
				p.expression(0)
			}

			p.SetState(1369)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1370)
			p.Match(MySqlParserRR_BRACKET)
		}

	case 8:
		localctx = NewNestedRowExpressionAtomContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1372)
			p.Match(MySqlParserROW)
		}
		{
			p.SetState(1373)
			p.Match(MySqlParserLR_BRACKET)
		}
		{
			p.SetState(1374)
			p.expression(0)
		}
		p.SetState(1377)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == MySqlParserCOMMA {
			{
				p.SetState(1375)
				p.Match(MySqlParserCOMMA)
			}
			{
				p.SetState(1376)
				p.expression(0)
			}

			p.SetState(1379)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1381)
			p.Match(MySqlParserRR_BRACKET)
		}

	case 9:
		localctx = NewExistsExpessionAtomContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1383)
			p.Match(MySqlParserEXISTS)
		}
		{
			p.SetState(1384)
			p.Match(MySqlParserLR_BRACKET)
		}
		{
			p.SetState(1385)
			p.SelectStatement()
		}
		{
			p.SetState(1386)
			p.Match(MySqlParserRR_BRACKET)
		}

	case 10:
		localctx = NewSubqueryExpessionAtomContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1388)
			p.Match(MySqlParserLR_BRACKET)
		}
		{
			p.SetState(1389)
			p.SelectStatement()
		}
		{
			p.SetState(1390)
			p.Match(MySqlParserRR_BRACKET)
		}

	case 11:
		localctx = NewIntervalExpressionAtomContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(1392)
			p.Match(MySqlParserINTERVAL)
		}
		{
			p.SetState(1393)
			p.expression(0)
		}
		{
			p.SetState(1394)
			p.IntervalType()
		}

	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1415)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 210, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(1413)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 209, p.GetParserRuleContext()) {
			case 1:
				localctx = NewBitExpressionAtomContext(p, NewExpressionAtomContext(p, _parentctx, _parentState))
				localctx.(*BitExpressionAtomContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, MySqlParserRULE_expressionAtom)
				p.SetState(1398)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
				}
				{
					p.SetState(1399)
					p.BitOperator()
				}
				{
					p.SetState(1400)

					var _x = p.expressionAtom(4)

					localctx.(*BitExpressionAtomContext).right = _x
				}

			case 2:
				localctx = NewMathExpressionAtomContext(p, NewExpressionAtomContext(p, _parentctx, _parentState))
				localctx.(*MathExpressionAtomContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, MySqlParserRULE_expressionAtom)
				p.SetState(1402)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				}
				{
					p.SetState(1403)
					p.MathOperator()
				}
				{
					p.SetState(1404)

					var _x = p.expressionAtom(3)

					localctx.(*MathExpressionAtomContext).right = _x
				}

			case 3:
				localctx = NewJsonExpressionAtomContext(p, NewExpressionAtomContext(p, _parentctx, _parentState))
				localctx.(*JsonExpressionAtomContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, MySqlParserRULE_expressionAtom)
				p.SetState(1406)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				}
				{
					p.SetState(1407)
					p.JsonOperator()
				}
				{
					p.SetState(1408)

					var _x = p.expressionAtom(2)

					localctx.(*JsonExpressionAtomContext).right = _x
				}

			case 4:
				localctx = NewCollateExpressionAtomContext(p, NewExpressionAtomContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, MySqlParserRULE_expressionAtom)
				p.SetState(1410)

				if !(p.Precpred(p.GetParserRuleContext(), 12)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 12)", ""))
				}
				{
					p.SetState(1411)
					p.Match(MySqlParserCOLLATE)
				}
				{
					p.SetState(1412)
					p.CollationName()
				}

			}

		}
		p.SetState(1417)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 210, p.GetParserRuleContext())
	}

	return localctx
}

// IUnaryOperatorContext is an interface to support dynamic dispatch.
type IUnaryOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnaryOperatorContext differentiates from other interfaces.
	IsUnaryOperatorContext()
}

type UnaryOperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnaryOperatorContext() *UnaryOperatorContext {
	var p = new(UnaryOperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_unaryOperator
	return p
}

func (*UnaryOperatorContext) IsUnaryOperatorContext() {}

func NewUnaryOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnaryOperatorContext {
	var p = new(UnaryOperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_unaryOperator

	return p
}

func (s *UnaryOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *UnaryOperatorContext) EXCLAMATION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXCLAMATION_SYMBOL, 0)
}

func (s *UnaryOperatorContext) BIT_NOT_OP() antlr.TerminalNode {
	return s.GetToken(MySqlParserBIT_NOT_OP, 0)
}

func (s *UnaryOperatorContext) PLUS() antlr.TerminalNode {
	return s.GetToken(MySqlParserPLUS, 0)
}

func (s *UnaryOperatorContext) MINUS() antlr.TerminalNode {
	return s.GetToken(MySqlParserMINUS, 0)
}

func (s *UnaryOperatorContext) NOT() antlr.TerminalNode {
	return s.GetToken(MySqlParserNOT, 0)
}

func (s *UnaryOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnaryOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnaryOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterUnaryOperator(s)
	}
}

func (s *UnaryOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitUnaryOperator(s)
	}
}

func (s *UnaryOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitUnaryOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) UnaryOperator() (localctx IUnaryOperatorContext) {
	localctx = NewUnaryOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, MySqlParserRULE_unaryOperator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1418)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserNOT || (((_la-1008)&-(0x1f+1)) == 0 && ((1<<uint((_la-1008)))&((1<<(MySqlParserPLUS-1008))|(1<<(MySqlParserMINUS-1008))|(1<<(MySqlParserEXCLAMATION_SYMBOL-1008))|(1<<(MySqlParserBIT_NOT_OP-1008)))) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IComparisonOperatorContext is an interface to support dynamic dispatch.
type IComparisonOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComparisonOperatorContext differentiates from other interfaces.
	IsComparisonOperatorContext()
}

type ComparisonOperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComparisonOperatorContext() *ComparisonOperatorContext {
	var p = new(ComparisonOperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_comparisonOperator
	return p
}

func (*ComparisonOperatorContext) IsComparisonOperatorContext() {}

func NewComparisonOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComparisonOperatorContext {
	var p = new(ComparisonOperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_comparisonOperator

	return p
}

func (s *ComparisonOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *ComparisonOperatorContext) EQUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUAL_SYMBOL, 0)
}

func (s *ComparisonOperatorContext) GREATER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserGREATER_SYMBOL, 0)
}

func (s *ComparisonOperatorContext) LESS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserLESS_SYMBOL, 0)
}

func (s *ComparisonOperatorContext) EXCLAMATION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXCLAMATION_SYMBOL, 0)
}

func (s *ComparisonOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComparisonOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterComparisonOperator(s)
	}
}

func (s *ComparisonOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitComparisonOperator(s)
	}
}

func (s *ComparisonOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitComparisonOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) ComparisonOperator() (localctx IComparisonOperatorContext) {
	localctx = NewComparisonOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, MySqlParserRULE_comparisonOperator)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1434)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 211, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1420)
			p.Match(MySqlParserEQUAL_SYMBOL)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1421)
			p.Match(MySqlParserGREATER_SYMBOL)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1422)
			p.Match(MySqlParserLESS_SYMBOL)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1423)
			p.Match(MySqlParserLESS_SYMBOL)
		}
		{
			p.SetState(1424)
			p.Match(MySqlParserEQUAL_SYMBOL)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1425)
			p.Match(MySqlParserGREATER_SYMBOL)
		}
		{
			p.SetState(1426)
			p.Match(MySqlParserEQUAL_SYMBOL)
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1427)
			p.Match(MySqlParserLESS_SYMBOL)
		}
		{
			p.SetState(1428)
			p.Match(MySqlParserGREATER_SYMBOL)
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1429)
			p.Match(MySqlParserEXCLAMATION_SYMBOL)
		}
		{
			p.SetState(1430)
			p.Match(MySqlParserEQUAL_SYMBOL)
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1431)
			p.Match(MySqlParserLESS_SYMBOL)
		}
		{
			p.SetState(1432)
			p.Match(MySqlParserEQUAL_SYMBOL)
		}
		{
			p.SetState(1433)
			p.Match(MySqlParserGREATER_SYMBOL)
		}

	}

	return localctx
}

// ILogicalOperatorContext is an interface to support dynamic dispatch.
type ILogicalOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLogicalOperatorContext differentiates from other interfaces.
	IsLogicalOperatorContext()
}

type LogicalOperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLogicalOperatorContext() *LogicalOperatorContext {
	var p = new(LogicalOperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_logicalOperator
	return p
}

func (*LogicalOperatorContext) IsLogicalOperatorContext() {}

func NewLogicalOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LogicalOperatorContext {
	var p = new(LogicalOperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_logicalOperator

	return p
}

func (s *LogicalOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *LogicalOperatorContext) AND() antlr.TerminalNode {
	return s.GetToken(MySqlParserAND, 0)
}

func (s *LogicalOperatorContext) AllBIT_AND_OP() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserBIT_AND_OP)
}

func (s *LogicalOperatorContext) BIT_AND_OP(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserBIT_AND_OP, i)
}

func (s *LogicalOperatorContext) XOR() antlr.TerminalNode {
	return s.GetToken(MySqlParserXOR, 0)
}

func (s *LogicalOperatorContext) OR() antlr.TerminalNode {
	return s.GetToken(MySqlParserOR, 0)
}

func (s *LogicalOperatorContext) AllBIT_OR_OP() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserBIT_OR_OP)
}

func (s *LogicalOperatorContext) BIT_OR_OP(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserBIT_OR_OP, i)
}

func (s *LogicalOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LogicalOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterLogicalOperator(s)
	}
}

func (s *LogicalOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitLogicalOperator(s)
	}
}

func (s *LogicalOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitLogicalOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) LogicalOperator() (localctx ILogicalOperatorContext) {
	localctx = NewLogicalOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, MySqlParserRULE_logicalOperator)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1443)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case MySqlParserAND:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1436)
			p.Match(MySqlParserAND)
		}

	case MySqlParserBIT_AND_OP:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1437)
			p.Match(MySqlParserBIT_AND_OP)
		}
		{
			p.SetState(1438)
			p.Match(MySqlParserBIT_AND_OP)
		}

	case MySqlParserXOR:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1439)
			p.Match(MySqlParserXOR)
		}

	case MySqlParserOR:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1440)
			p.Match(MySqlParserOR)
		}

	case MySqlParserBIT_OR_OP:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1441)
			p.Match(MySqlParserBIT_OR_OP)
		}
		{
			p.SetState(1442)
			p.Match(MySqlParserBIT_OR_OP)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IBitOperatorContext is an interface to support dynamic dispatch.
type IBitOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBitOperatorContext differentiates from other interfaces.
	IsBitOperatorContext()
}

type BitOperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBitOperatorContext() *BitOperatorContext {
	var p = new(BitOperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_bitOperator
	return p
}

func (*BitOperatorContext) IsBitOperatorContext() {}

func NewBitOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BitOperatorContext {
	var p = new(BitOperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_bitOperator

	return p
}

func (s *BitOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *BitOperatorContext) AllLESS_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserLESS_SYMBOL)
}

func (s *BitOperatorContext) LESS_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserLESS_SYMBOL, i)
}

func (s *BitOperatorContext) AllGREATER_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserGREATER_SYMBOL)
}

func (s *BitOperatorContext) GREATER_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserGREATER_SYMBOL, i)
}

func (s *BitOperatorContext) BIT_AND_OP() antlr.TerminalNode {
	return s.GetToken(MySqlParserBIT_AND_OP, 0)
}

func (s *BitOperatorContext) BIT_XOR_OP() antlr.TerminalNode {
	return s.GetToken(MySqlParserBIT_XOR_OP, 0)
}

func (s *BitOperatorContext) BIT_OR_OP() antlr.TerminalNode {
	return s.GetToken(MySqlParserBIT_OR_OP, 0)
}

func (s *BitOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BitOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterBitOperator(s)
	}
}

func (s *BitOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitBitOperator(s)
	}
}

func (s *BitOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitBitOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) BitOperator() (localctx IBitOperatorContext) {
	localctx = NewBitOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, MySqlParserRULE_bitOperator)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1452)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case MySqlParserLESS_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1445)
			p.Match(MySqlParserLESS_SYMBOL)
		}
		{
			p.SetState(1446)
			p.Match(MySqlParserLESS_SYMBOL)
		}

	case MySqlParserGREATER_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1447)
			p.Match(MySqlParserGREATER_SYMBOL)
		}
		{
			p.SetState(1448)
			p.Match(MySqlParserGREATER_SYMBOL)
		}

	case MySqlParserBIT_AND_OP:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1449)
			p.Match(MySqlParserBIT_AND_OP)
		}

	case MySqlParserBIT_XOR_OP:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1450)
			p.Match(MySqlParserBIT_XOR_OP)
		}

	case MySqlParserBIT_OR_OP:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1451)
			p.Match(MySqlParserBIT_OR_OP)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IMathOperatorContext is an interface to support dynamic dispatch.
type IMathOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMathOperatorContext differentiates from other interfaces.
	IsMathOperatorContext()
}

type MathOperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMathOperatorContext() *MathOperatorContext {
	var p = new(MathOperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_mathOperator
	return p
}

func (*MathOperatorContext) IsMathOperatorContext() {}

func NewMathOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MathOperatorContext {
	var p = new(MathOperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_mathOperator

	return p
}

func (s *MathOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *MathOperatorContext) STAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTAR, 0)
}

func (s *MathOperatorContext) DIVIDE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDIVIDE, 0)
}

func (s *MathOperatorContext) MODULE() antlr.TerminalNode {
	return s.GetToken(MySqlParserMODULE, 0)
}

func (s *MathOperatorContext) DIV() antlr.TerminalNode {
	return s.GetToken(MySqlParserDIV, 0)
}

func (s *MathOperatorContext) MOD() antlr.TerminalNode {
	return s.GetToken(MySqlParserMOD, 0)
}

func (s *MathOperatorContext) PLUS() antlr.TerminalNode {
	return s.GetToken(MySqlParserPLUS, 0)
}

func (s *MathOperatorContext) MINUS() antlr.TerminalNode {
	return s.GetToken(MySqlParserMINUS, 0)
}

func (s *MathOperatorContext) MINUSMINUS() antlr.TerminalNode {
	return s.GetToken(MySqlParserMINUSMINUS, 0)
}

func (s *MathOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MathOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MathOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterMathOperator(s)
	}
}

func (s *MathOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitMathOperator(s)
	}
}

func (s *MathOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitMathOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) MathOperator() (localctx IMathOperatorContext) {
	localctx = NewMathOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, MySqlParserRULE_mathOperator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1454)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-1005)&-(0x1f+1)) == 0 && ((1<<uint((_la-1005)))&((1<<(MySqlParserSTAR-1005))|(1<<(MySqlParserDIVIDE-1005))|(1<<(MySqlParserMODULE-1005))|(1<<(MySqlParserPLUS-1005))|(1<<(MySqlParserMINUSMINUS-1005))|(1<<(MySqlParserMINUS-1005))|(1<<(MySqlParserDIV-1005))|(1<<(MySqlParserMOD-1005)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IJsonOperatorContext is an interface to support dynamic dispatch.
type IJsonOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsJsonOperatorContext differentiates from other interfaces.
	IsJsonOperatorContext()
}

type JsonOperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJsonOperatorContext() *JsonOperatorContext {
	var p = new(JsonOperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_jsonOperator
	return p
}

func (*JsonOperatorContext) IsJsonOperatorContext() {}

func NewJsonOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JsonOperatorContext {
	var p = new(JsonOperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_jsonOperator

	return p
}

func (s *JsonOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *JsonOperatorContext) MINUS() antlr.TerminalNode {
	return s.GetToken(MySqlParserMINUS, 0)
}

func (s *JsonOperatorContext) AllGREATER_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySqlParserGREATER_SYMBOL)
}

func (s *JsonOperatorContext) GREATER_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySqlParserGREATER_SYMBOL, i)
}

func (s *JsonOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JsonOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JsonOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterJsonOperator(s)
	}
}

func (s *JsonOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitJsonOperator(s)
	}
}

func (s *JsonOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitJsonOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) JsonOperator() (localctx IJsonOperatorContext) {
	localctx = NewJsonOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, MySqlParserRULE_jsonOperator)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1461)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 214, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1456)
			p.Match(MySqlParserMINUS)
		}
		{
			p.SetState(1457)
			p.Match(MySqlParserGREATER_SYMBOL)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1458)
			p.Match(MySqlParserMINUS)
		}
		{
			p.SetState(1459)
			p.Match(MySqlParserGREATER_SYMBOL)
		}
		{
			p.SetState(1460)
			p.Match(MySqlParserGREATER_SYMBOL)
		}

	}

	return localctx
}

// ICharsetNameBaseContext is an interface to support dynamic dispatch.
type ICharsetNameBaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCharsetNameBaseContext differentiates from other interfaces.
	IsCharsetNameBaseContext()
}

type CharsetNameBaseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCharsetNameBaseContext() *CharsetNameBaseContext {
	var p = new(CharsetNameBaseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_charsetNameBase
	return p
}

func (*CharsetNameBaseContext) IsCharsetNameBaseContext() {}

func NewCharsetNameBaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CharsetNameBaseContext {
	var p = new(CharsetNameBaseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_charsetNameBase

	return p
}

func (s *CharsetNameBaseContext) GetParser() antlr.Parser { return s.parser }

func (s *CharsetNameBaseContext) ARMSCII8() antlr.TerminalNode {
	return s.GetToken(MySqlParserARMSCII8, 0)
}

func (s *CharsetNameBaseContext) ASCII() antlr.TerminalNode {
	return s.GetToken(MySqlParserASCII, 0)
}

func (s *CharsetNameBaseContext) BIG5() antlr.TerminalNode {
	return s.GetToken(MySqlParserBIG5, 0)
}

func (s *CharsetNameBaseContext) CP1250() antlr.TerminalNode {
	return s.GetToken(MySqlParserCP1250, 0)
}

func (s *CharsetNameBaseContext) CP1251() antlr.TerminalNode {
	return s.GetToken(MySqlParserCP1251, 0)
}

func (s *CharsetNameBaseContext) CP1256() antlr.TerminalNode {
	return s.GetToken(MySqlParserCP1256, 0)
}

func (s *CharsetNameBaseContext) CP1257() antlr.TerminalNode {
	return s.GetToken(MySqlParserCP1257, 0)
}

func (s *CharsetNameBaseContext) CP850() antlr.TerminalNode {
	return s.GetToken(MySqlParserCP850, 0)
}

func (s *CharsetNameBaseContext) CP852() antlr.TerminalNode {
	return s.GetToken(MySqlParserCP852, 0)
}

func (s *CharsetNameBaseContext) CP866() antlr.TerminalNode {
	return s.GetToken(MySqlParserCP866, 0)
}

func (s *CharsetNameBaseContext) CP932() antlr.TerminalNode {
	return s.GetToken(MySqlParserCP932, 0)
}

func (s *CharsetNameBaseContext) DEC8() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEC8, 0)
}

func (s *CharsetNameBaseContext) EUCJPMS() antlr.TerminalNode {
	return s.GetToken(MySqlParserEUCJPMS, 0)
}

func (s *CharsetNameBaseContext) EUCKR() antlr.TerminalNode {
	return s.GetToken(MySqlParserEUCKR, 0)
}

func (s *CharsetNameBaseContext) GB2312() antlr.TerminalNode {
	return s.GetToken(MySqlParserGB2312, 0)
}

func (s *CharsetNameBaseContext) GBK() antlr.TerminalNode {
	return s.GetToken(MySqlParserGBK, 0)
}

func (s *CharsetNameBaseContext) GEOSTD8() antlr.TerminalNode {
	return s.GetToken(MySqlParserGEOSTD8, 0)
}

func (s *CharsetNameBaseContext) GREEK() antlr.TerminalNode {
	return s.GetToken(MySqlParserGREEK, 0)
}

func (s *CharsetNameBaseContext) HEBREW() antlr.TerminalNode {
	return s.GetToken(MySqlParserHEBREW, 0)
}

func (s *CharsetNameBaseContext) HP8() antlr.TerminalNode {
	return s.GetToken(MySqlParserHP8, 0)
}

func (s *CharsetNameBaseContext) KEYBCS2() antlr.TerminalNode {
	return s.GetToken(MySqlParserKEYBCS2, 0)
}

func (s *CharsetNameBaseContext) KOI8R() antlr.TerminalNode {
	return s.GetToken(MySqlParserKOI8R, 0)
}

func (s *CharsetNameBaseContext) KOI8U() antlr.TerminalNode {
	return s.GetToken(MySqlParserKOI8U, 0)
}

func (s *CharsetNameBaseContext) LATIN1() antlr.TerminalNode {
	return s.GetToken(MySqlParserLATIN1, 0)
}

func (s *CharsetNameBaseContext) LATIN2() antlr.TerminalNode {
	return s.GetToken(MySqlParserLATIN2, 0)
}

func (s *CharsetNameBaseContext) LATIN5() antlr.TerminalNode {
	return s.GetToken(MySqlParserLATIN5, 0)
}

func (s *CharsetNameBaseContext) LATIN7() antlr.TerminalNode {
	return s.GetToken(MySqlParserLATIN7, 0)
}

func (s *CharsetNameBaseContext) MACCE() antlr.TerminalNode {
	return s.GetToken(MySqlParserMACCE, 0)
}

func (s *CharsetNameBaseContext) MACROMAN() antlr.TerminalNode {
	return s.GetToken(MySqlParserMACROMAN, 0)
}

func (s *CharsetNameBaseContext) SJIS() antlr.TerminalNode {
	return s.GetToken(MySqlParserSJIS, 0)
}

func (s *CharsetNameBaseContext) SWE7() antlr.TerminalNode {
	return s.GetToken(MySqlParserSWE7, 0)
}

func (s *CharsetNameBaseContext) TIS620() antlr.TerminalNode {
	return s.GetToken(MySqlParserTIS620, 0)
}

func (s *CharsetNameBaseContext) UCS2() antlr.TerminalNode {
	return s.GetToken(MySqlParserUCS2, 0)
}

func (s *CharsetNameBaseContext) UJIS() antlr.TerminalNode {
	return s.GetToken(MySqlParserUJIS, 0)
}

func (s *CharsetNameBaseContext) UTF16() antlr.TerminalNode {
	return s.GetToken(MySqlParserUTF16, 0)
}

func (s *CharsetNameBaseContext) UTF16LE() antlr.TerminalNode {
	return s.GetToken(MySqlParserUTF16LE, 0)
}

func (s *CharsetNameBaseContext) UTF32() antlr.TerminalNode {
	return s.GetToken(MySqlParserUTF32, 0)
}

func (s *CharsetNameBaseContext) UTF8() antlr.TerminalNode {
	return s.GetToken(MySqlParserUTF8, 0)
}

func (s *CharsetNameBaseContext) UTF8MB3() antlr.TerminalNode {
	return s.GetToken(MySqlParserUTF8MB3, 0)
}

func (s *CharsetNameBaseContext) UTF8MB4() antlr.TerminalNode {
	return s.GetToken(MySqlParserUTF8MB4, 0)
}

func (s *CharsetNameBaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CharsetNameBaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CharsetNameBaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterCharsetNameBase(s)
	}
}

func (s *CharsetNameBaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitCharsetNameBase(s)
	}
}

func (s *CharsetNameBaseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitCharsetNameBase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) CharsetNameBase() (localctx ICharsetNameBaseContext) {
	localctx = NewCharsetNameBaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, MySqlParserRULE_charsetNameBase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1463)
		_la = p.GetTokenStream().LA(1)

		if !((((_la-639)&-(0x1f+1)) == 0 && ((1<<uint((_la-639)))&((1<<(MySqlParserARMSCII8-639))|(1<<(MySqlParserASCII-639))|(1<<(MySqlParserBIG5-639))|(1<<(MySqlParserCP1250-639))|(1<<(MySqlParserCP1251-639))|(1<<(MySqlParserCP1256-639))|(1<<(MySqlParserCP1257-639))|(1<<(MySqlParserCP850-639))|(1<<(MySqlParserCP852-639))|(1<<(MySqlParserCP866-639))|(1<<(MySqlParserCP932-639))|(1<<(MySqlParserDEC8-639))|(1<<(MySqlParserEUCJPMS-639))|(1<<(MySqlParserEUCKR-639))|(1<<(MySqlParserGB2312-639))|(1<<(MySqlParserGBK-639))|(1<<(MySqlParserGEOSTD8-639))|(1<<(MySqlParserGREEK-639))|(1<<(MySqlParserHEBREW-639))|(1<<(MySqlParserHP8-639))|(1<<(MySqlParserKEYBCS2-639))|(1<<(MySqlParserKOI8R-639))|(1<<(MySqlParserKOI8U-639))|(1<<(MySqlParserLATIN1-639))|(1<<(MySqlParserLATIN2-639))|(1<<(MySqlParserLATIN5-639))|(1<<(MySqlParserLATIN7-639))|(1<<(MySqlParserMACCE-639))|(1<<(MySqlParserMACROMAN-639))|(1<<(MySqlParserSJIS-639))|(1<<(MySqlParserSWE7-639))|(1<<(MySqlParserTIS620-639)))) != 0) || (((_la-671)&-(0x1f+1)) == 0 && ((1<<uint((_la-671)))&((1<<(MySqlParserUCS2-671))|(1<<(MySqlParserUJIS-671))|(1<<(MySqlParserUTF16-671))|(1<<(MySqlParserUTF16LE-671))|(1<<(MySqlParserUTF32-671))|(1<<(MySqlParserUTF8-671))|(1<<(MySqlParserUTF8MB3-671))|(1<<(MySqlParserUTF8MB4-671)))) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ITransactionLevelBaseContext is an interface to support dynamic dispatch.
type ITransactionLevelBaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTransactionLevelBaseContext differentiates from other interfaces.
	IsTransactionLevelBaseContext()
}

type TransactionLevelBaseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTransactionLevelBaseContext() *TransactionLevelBaseContext {
	var p = new(TransactionLevelBaseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_transactionLevelBase
	return p
}

func (*TransactionLevelBaseContext) IsTransactionLevelBaseContext() {}

func NewTransactionLevelBaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TransactionLevelBaseContext {
	var p = new(TransactionLevelBaseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_transactionLevelBase

	return p
}

func (s *TransactionLevelBaseContext) GetParser() antlr.Parser { return s.parser }

func (s *TransactionLevelBaseContext) REPEATABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPEATABLE, 0)
}

func (s *TransactionLevelBaseContext) COMMITTED() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMITTED, 0)
}

func (s *TransactionLevelBaseContext) UNCOMMITTED() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNCOMMITTED, 0)
}

func (s *TransactionLevelBaseContext) SERIALIZABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSERIALIZABLE, 0)
}

func (s *TransactionLevelBaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TransactionLevelBaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TransactionLevelBaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterTransactionLevelBase(s)
	}
}

func (s *TransactionLevelBaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitTransactionLevelBase(s)
	}
}

func (s *TransactionLevelBaseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitTransactionLevelBase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) TransactionLevelBase() (localctx ITransactionLevelBaseContext) {
	localctx = NewTransactionLevelBaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, MySqlParserRULE_transactionLevelBase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1465)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-691)&-(0x1f+1)) == 0 && ((1<<uint((_la-691)))&((1<<(MySqlParserREPEATABLE-691))|(1<<(MySqlParserCOMMITTED-691))|(1<<(MySqlParserUNCOMMITTED-691))|(1<<(MySqlParserSERIALIZABLE-691)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IPrivilegesBaseContext is an interface to support dynamic dispatch.
type IPrivilegesBaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrivilegesBaseContext differentiates from other interfaces.
	IsPrivilegesBaseContext()
}

type PrivilegesBaseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrivilegesBaseContext() *PrivilegesBaseContext {
	var p = new(PrivilegesBaseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_privilegesBase
	return p
}

func (*PrivilegesBaseContext) IsPrivilegesBaseContext() {}

func NewPrivilegesBaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrivilegesBaseContext {
	var p = new(PrivilegesBaseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_privilegesBase

	return p
}

func (s *PrivilegesBaseContext) GetParser() antlr.Parser { return s.parser }

func (s *PrivilegesBaseContext) TABLES() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLES, 0)
}

func (s *PrivilegesBaseContext) ROUTINE() antlr.TerminalNode {
	return s.GetToken(MySqlParserROUTINE, 0)
}

func (s *PrivilegesBaseContext) EXECUTE() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXECUTE, 0)
}

func (s *PrivilegesBaseContext) FILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserFILE, 0)
}

func (s *PrivilegesBaseContext) PROCESS() antlr.TerminalNode {
	return s.GetToken(MySqlParserPROCESS, 0)
}

func (s *PrivilegesBaseContext) RELOAD() antlr.TerminalNode {
	return s.GetToken(MySqlParserRELOAD, 0)
}

func (s *PrivilegesBaseContext) SHUTDOWN() antlr.TerminalNode {
	return s.GetToken(MySqlParserSHUTDOWN, 0)
}

func (s *PrivilegesBaseContext) SUPER() antlr.TerminalNode {
	return s.GetToken(MySqlParserSUPER, 0)
}

func (s *PrivilegesBaseContext) PRIVILEGES() antlr.TerminalNode {
	return s.GetToken(MySqlParserPRIVILEGES, 0)
}

func (s *PrivilegesBaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrivilegesBaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrivilegesBaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterPrivilegesBase(s)
	}
}

func (s *PrivilegesBaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitPrivilegesBase(s)
	}
}

func (s *PrivilegesBaseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitPrivilegesBase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) PrivilegesBase() (localctx IPrivilegesBaseContext) {
	localctx = NewPrivilegesBaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, MySqlParserRULE_privilegesBase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1467)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-604)&-(0x1f+1)) == 0 && ((1<<uint((_la-604)))&((1<<(MySqlParserTABLES-604))|(1<<(MySqlParserROUTINE-604))|(1<<(MySqlParserEXECUTE-604))|(1<<(MySqlParserFILE-604))|(1<<(MySqlParserPROCESS-604))|(1<<(MySqlParserRELOAD-604))|(1<<(MySqlParserSHUTDOWN-604))|(1<<(MySqlParserSUPER-604))|(1<<(MySqlParserPRIVILEGES-604)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IIntervalTypeBaseContext is an interface to support dynamic dispatch.
type IIntervalTypeBaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIntervalTypeBaseContext differentiates from other interfaces.
	IsIntervalTypeBaseContext()
}

type IntervalTypeBaseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntervalTypeBaseContext() *IntervalTypeBaseContext {
	var p = new(IntervalTypeBaseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_intervalTypeBase
	return p
}

func (*IntervalTypeBaseContext) IsIntervalTypeBaseContext() {}

func NewIntervalTypeBaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntervalTypeBaseContext {
	var p = new(IntervalTypeBaseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_intervalTypeBase

	return p
}

func (s *IntervalTypeBaseContext) GetParser() antlr.Parser { return s.parser }

func (s *IntervalTypeBaseContext) QUARTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserQUARTER, 0)
}

func (s *IntervalTypeBaseContext) MONTH() antlr.TerminalNode {
	return s.GetToken(MySqlParserMONTH, 0)
}

func (s *IntervalTypeBaseContext) DAY() antlr.TerminalNode {
	return s.GetToken(MySqlParserDAY, 0)
}

func (s *IntervalTypeBaseContext) HOUR() antlr.TerminalNode {
	return s.GetToken(MySqlParserHOUR, 0)
}

func (s *IntervalTypeBaseContext) MINUTE() antlr.TerminalNode {
	return s.GetToken(MySqlParserMINUTE, 0)
}

func (s *IntervalTypeBaseContext) WEEK() antlr.TerminalNode {
	return s.GetToken(MySqlParserWEEK, 0)
}

func (s *IntervalTypeBaseContext) SECOND() antlr.TerminalNode {
	return s.GetToken(MySqlParserSECOND, 0)
}

func (s *IntervalTypeBaseContext) MICROSECOND() antlr.TerminalNode {
	return s.GetToken(MySqlParserMICROSECOND, 0)
}

func (s *IntervalTypeBaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntervalTypeBaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntervalTypeBaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterIntervalTypeBase(s)
	}
}

func (s *IntervalTypeBaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitIntervalTypeBase(s)
	}
}

func (s *IntervalTypeBaseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitIntervalTypeBase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) IntervalTypeBase() (localctx IIntervalTypeBaseContext) {
	localctx = NewIntervalTypeBaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, MySqlParserRULE_intervalTypeBase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1469)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-596)&-(0x1f+1)) == 0 && ((1<<uint((_la-596)))&((1<<(MySqlParserQUARTER-596))|(1<<(MySqlParserMONTH-596))|(1<<(MySqlParserDAY-596))|(1<<(MySqlParserHOUR-596))|(1<<(MySqlParserMINUTE-596))|(1<<(MySqlParserWEEK-596))|(1<<(MySqlParserSECOND-596))|(1<<(MySqlParserMICROSECOND-596)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IDataTypeBaseContext is an interface to support dynamic dispatch.
type IDataTypeBaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataTypeBaseContext differentiates from other interfaces.
	IsDataTypeBaseContext()
}

type DataTypeBaseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataTypeBaseContext() *DataTypeBaseContext {
	var p = new(DataTypeBaseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_dataTypeBase
	return p
}

func (*DataTypeBaseContext) IsDataTypeBaseContext() {}

func NewDataTypeBaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataTypeBaseContext {
	var p = new(DataTypeBaseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_dataTypeBase

	return p
}

func (s *DataTypeBaseContext) GetParser() antlr.Parser { return s.parser }

func (s *DataTypeBaseContext) DATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATE, 0)
}

func (s *DataTypeBaseContext) TIME() antlr.TerminalNode {
	return s.GetToken(MySqlParserTIME, 0)
}

func (s *DataTypeBaseContext) TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(MySqlParserTIMESTAMP, 0)
}

func (s *DataTypeBaseContext) DATETIME() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATETIME, 0)
}

func (s *DataTypeBaseContext) YEAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserYEAR, 0)
}

func (s *DataTypeBaseContext) ENUM() antlr.TerminalNode {
	return s.GetToken(MySqlParserENUM, 0)
}

func (s *DataTypeBaseContext) TEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserTEXT, 0)
}

func (s *DataTypeBaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataTypeBaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataTypeBaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterDataTypeBase(s)
	}
}

func (s *DataTypeBaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitDataTypeBase(s)
	}
}

func (s *DataTypeBaseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitDataTypeBase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) DataTypeBase() (localctx IDataTypeBaseContext) {
	localctx = NewDataTypeBaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, MySqlParserRULE_dataTypeBase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1471)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-199)&-(0x1f+1)) == 0 && ((1<<uint((_la-199)))&((1<<(MySqlParserDATE-199))|(1<<(MySqlParserTIME-199))|(1<<(MySqlParserTIMESTAMP-199))|(1<<(MySqlParserDATETIME-199))|(1<<(MySqlParserYEAR-199))|(1<<(MySqlParserTEXT-199))|(1<<(MySqlParserENUM-199)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IKeywordsCanBeIdContext is an interface to support dynamic dispatch.
type IKeywordsCanBeIdContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsKeywordsCanBeIdContext differentiates from other interfaces.
	IsKeywordsCanBeIdContext()
}

type KeywordsCanBeIdContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeywordsCanBeIdContext() *KeywordsCanBeIdContext {
	var p = new(KeywordsCanBeIdContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_keywordsCanBeId
	return p
}

func (*KeywordsCanBeIdContext) IsKeywordsCanBeIdContext() {}

func NewKeywordsCanBeIdContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KeywordsCanBeIdContext {
	var p = new(KeywordsCanBeIdContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_keywordsCanBeId

	return p
}

func (s *KeywordsCanBeIdContext) GetParser() antlr.Parser { return s.parser }

func (s *KeywordsCanBeIdContext) ACCOUNT() antlr.TerminalNode {
	return s.GetToken(MySqlParserACCOUNT, 0)
}

func (s *KeywordsCanBeIdContext) ACTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserACTION, 0)
}

func (s *KeywordsCanBeIdContext) AFTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserAFTER, 0)
}

func (s *KeywordsCanBeIdContext) AGGREGATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserAGGREGATE, 0)
}

func (s *KeywordsCanBeIdContext) ALGORITHM() antlr.TerminalNode {
	return s.GetToken(MySqlParserALGORITHM, 0)
}

func (s *KeywordsCanBeIdContext) ANY() antlr.TerminalNode {
	return s.GetToken(MySqlParserANY, 0)
}

func (s *KeywordsCanBeIdContext) AT() antlr.TerminalNode {
	return s.GetToken(MySqlParserAT, 0)
}

func (s *KeywordsCanBeIdContext) AUDIT_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserAUDIT_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) AUTHORS() antlr.TerminalNode {
	return s.GetToken(MySqlParserAUTHORS, 0)
}

func (s *KeywordsCanBeIdContext) AUTOCOMMIT() antlr.TerminalNode {
	return s.GetToken(MySqlParserAUTOCOMMIT, 0)
}

func (s *KeywordsCanBeIdContext) AUTOEXTEND_SIZE() antlr.TerminalNode {
	return s.GetToken(MySqlParserAUTOEXTEND_SIZE, 0)
}

func (s *KeywordsCanBeIdContext) AUTO_INCREMENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserAUTO_INCREMENT, 0)
}

func (s *KeywordsCanBeIdContext) AVG_ROW_LENGTH() antlr.TerminalNode {
	return s.GetToken(MySqlParserAVG_ROW_LENGTH, 0)
}

func (s *KeywordsCanBeIdContext) BACKUP_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserBACKUP_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) BEGIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserBEGIN, 0)
}

func (s *KeywordsCanBeIdContext) BINLOG() antlr.TerminalNode {
	return s.GetToken(MySqlParserBINLOG, 0)
}

func (s *KeywordsCanBeIdContext) BINLOG_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserBINLOG_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) BINLOG_ENCRYPTION_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserBINLOG_ENCRYPTION_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) BIT() antlr.TerminalNode {
	return s.GetToken(MySqlParserBIT, 0)
}

func (s *KeywordsCanBeIdContext) BLOCK() antlr.TerminalNode {
	return s.GetToken(MySqlParserBLOCK, 0)
}

func (s *KeywordsCanBeIdContext) BOOL() antlr.TerminalNode {
	return s.GetToken(MySqlParserBOOL, 0)
}

func (s *KeywordsCanBeIdContext) BOOLEAN() antlr.TerminalNode {
	return s.GetToken(MySqlParserBOOLEAN, 0)
}

func (s *KeywordsCanBeIdContext) BTREE() antlr.TerminalNode {
	return s.GetToken(MySqlParserBTREE, 0)
}

func (s *KeywordsCanBeIdContext) CACHE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCACHE, 0)
}

func (s *KeywordsCanBeIdContext) CASCADED() antlr.TerminalNode {
	return s.GetToken(MySqlParserCASCADED, 0)
}

func (s *KeywordsCanBeIdContext) CHAIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHAIN, 0)
}

func (s *KeywordsCanBeIdContext) CHANGED() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHANGED, 0)
}

func (s *KeywordsCanBeIdContext) CHANNEL() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHANNEL, 0)
}

func (s *KeywordsCanBeIdContext) CHECKSUM() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHECKSUM, 0)
}

func (s *KeywordsCanBeIdContext) PAGE_CHECKSUM() antlr.TerminalNode {
	return s.GetToken(MySqlParserPAGE_CHECKSUM, 0)
}

func (s *KeywordsCanBeIdContext) CATALOG_NAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserCATALOG_NAME, 0)
}

func (s *KeywordsCanBeIdContext) CIPHER() antlr.TerminalNode {
	return s.GetToken(MySqlParserCIPHER, 0)
}

func (s *KeywordsCanBeIdContext) CLASS_ORIGIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserCLASS_ORIGIN, 0)
}

func (s *KeywordsCanBeIdContext) CLIENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCLIENT, 0)
}

func (s *KeywordsCanBeIdContext) CLONE_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserCLONE_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) CLOSE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCLOSE, 0)
}

func (s *KeywordsCanBeIdContext) COALESCE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOALESCE, 0)
}

func (s *KeywordsCanBeIdContext) CODE() antlr.TerminalNode {
	return s.GetToken(MySqlParserCODE, 0)
}

func (s *KeywordsCanBeIdContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLUMNS, 0)
}

func (s *KeywordsCanBeIdContext) COLUMN_FORMAT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLUMN_FORMAT, 0)
}

func (s *KeywordsCanBeIdContext) COLUMN_NAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLUMN_NAME, 0)
}

func (s *KeywordsCanBeIdContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMENT, 0)
}

func (s *KeywordsCanBeIdContext) COMMIT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMMIT, 0)
}

func (s *KeywordsCanBeIdContext) COMPACT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMPACT, 0)
}

func (s *KeywordsCanBeIdContext) COMPLETION() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMPLETION, 0)
}

func (s *KeywordsCanBeIdContext) COMPRESSED() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMPRESSED, 0)
}

func (s *KeywordsCanBeIdContext) COMPRESSION() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMPRESSION, 0)
}

func (s *KeywordsCanBeIdContext) CONCURRENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONCURRENT, 0)
}

func (s *KeywordsCanBeIdContext) CONNECTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONNECTION, 0)
}

func (s *KeywordsCanBeIdContext) CONNECTION_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONNECTION_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) CONSISTENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONSISTENT, 0)
}

func (s *KeywordsCanBeIdContext) CONSTRAINT_CATALOG() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONSTRAINT_CATALOG, 0)
}

func (s *KeywordsCanBeIdContext) CONSTRAINT_NAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONSTRAINT_NAME, 0)
}

func (s *KeywordsCanBeIdContext) CONSTRAINT_SCHEMA() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONSTRAINT_SCHEMA, 0)
}

func (s *KeywordsCanBeIdContext) CONTAINS() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONTAINS, 0)
}

func (s *KeywordsCanBeIdContext) CONTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONTEXT, 0)
}

func (s *KeywordsCanBeIdContext) CONTRIBUTORS() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONTRIBUTORS, 0)
}

func (s *KeywordsCanBeIdContext) COPY() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOPY, 0)
}

func (s *KeywordsCanBeIdContext) CPU() antlr.TerminalNode {
	return s.GetToken(MySqlParserCPU, 0)
}

func (s *KeywordsCanBeIdContext) CURRENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCURRENT, 0)
}

func (s *KeywordsCanBeIdContext) CURSOR_NAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserCURSOR_NAME, 0)
}

func (s *KeywordsCanBeIdContext) DATA() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATA, 0)
}

func (s *KeywordsCanBeIdContext) DATAFILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATAFILE, 0)
}

func (s *KeywordsCanBeIdContext) DEALLOCATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEALLOCATE, 0)
}

func (s *KeywordsCanBeIdContext) DEFAULT_AUTH() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFAULT_AUTH, 0)
}

func (s *KeywordsCanBeIdContext) DEFINER() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEFINER, 0)
}

func (s *KeywordsCanBeIdContext) DELAY_KEY_WRITE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDELAY_KEY_WRITE, 0)
}

func (s *KeywordsCanBeIdContext) DES_KEY_FILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDES_KEY_FILE, 0)
}

func (s *KeywordsCanBeIdContext) DIAGNOSTICS() antlr.TerminalNode {
	return s.GetToken(MySqlParserDIAGNOSTICS, 0)
}

func (s *KeywordsCanBeIdContext) DIRECTORY() antlr.TerminalNode {
	return s.GetToken(MySqlParserDIRECTORY, 0)
}

func (s *KeywordsCanBeIdContext) DISABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDISABLE, 0)
}

func (s *KeywordsCanBeIdContext) DISCARD() antlr.TerminalNode {
	return s.GetToken(MySqlParserDISCARD, 0)
}

func (s *KeywordsCanBeIdContext) DISK() antlr.TerminalNode {
	return s.GetToken(MySqlParserDISK, 0)
}

func (s *KeywordsCanBeIdContext) DO() antlr.TerminalNode {
	return s.GetToken(MySqlParserDO, 0)
}

func (s *KeywordsCanBeIdContext) DUMPFILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDUMPFILE, 0)
}

func (s *KeywordsCanBeIdContext) DUPLICATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDUPLICATE, 0)
}

func (s *KeywordsCanBeIdContext) DYNAMIC() antlr.TerminalNode {
	return s.GetToken(MySqlParserDYNAMIC, 0)
}

func (s *KeywordsCanBeIdContext) ENABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserENABLE, 0)
}

func (s *KeywordsCanBeIdContext) ENCRYPTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserENCRYPTION, 0)
}

func (s *KeywordsCanBeIdContext) ENCRYPTION_KEY_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserENCRYPTION_KEY_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) END() antlr.TerminalNode {
	return s.GetToken(MySqlParserEND, 0)
}

func (s *KeywordsCanBeIdContext) ENDS() antlr.TerminalNode {
	return s.GetToken(MySqlParserENDS, 0)
}

func (s *KeywordsCanBeIdContext) ENGINE() antlr.TerminalNode {
	return s.GetToken(MySqlParserENGINE, 0)
}

func (s *KeywordsCanBeIdContext) ENGINES() antlr.TerminalNode {
	return s.GetToken(MySqlParserENGINES, 0)
}

func (s *KeywordsCanBeIdContext) ERROR() antlr.TerminalNode {
	return s.GetToken(MySqlParserERROR, 0)
}

func (s *KeywordsCanBeIdContext) ERRORS() antlr.TerminalNode {
	return s.GetToken(MySqlParserERRORS, 0)
}

func (s *KeywordsCanBeIdContext) ESCAPE() antlr.TerminalNode {
	return s.GetToken(MySqlParserESCAPE, 0)
}

func (s *KeywordsCanBeIdContext) EVEN() antlr.TerminalNode {
	return s.GetToken(MySqlParserEVEN, 0)
}

func (s *KeywordsCanBeIdContext) EVENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserEVENT, 0)
}

func (s *KeywordsCanBeIdContext) EVENTS() antlr.TerminalNode {
	return s.GetToken(MySqlParserEVENTS, 0)
}

func (s *KeywordsCanBeIdContext) EVERY() antlr.TerminalNode {
	return s.GetToken(MySqlParserEVERY, 0)
}

func (s *KeywordsCanBeIdContext) EXCHANGE() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXCHANGE, 0)
}

func (s *KeywordsCanBeIdContext) EXCLUSIVE() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXCLUSIVE, 0)
}

func (s *KeywordsCanBeIdContext) EXPIRE() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXPIRE, 0)
}

func (s *KeywordsCanBeIdContext) EXPORT() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXPORT, 0)
}

func (s *KeywordsCanBeIdContext) EXTENDED() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXTENDED, 0)
}

func (s *KeywordsCanBeIdContext) EXTENT_SIZE() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXTENT_SIZE, 0)
}

func (s *KeywordsCanBeIdContext) FAST() antlr.TerminalNode {
	return s.GetToken(MySqlParserFAST, 0)
}

func (s *KeywordsCanBeIdContext) FAULTS() antlr.TerminalNode {
	return s.GetToken(MySqlParserFAULTS, 0)
}

func (s *KeywordsCanBeIdContext) FIELDS() antlr.TerminalNode {
	return s.GetToken(MySqlParserFIELDS, 0)
}

func (s *KeywordsCanBeIdContext) FILE_BLOCK_SIZE() antlr.TerminalNode {
	return s.GetToken(MySqlParserFILE_BLOCK_SIZE, 0)
}

func (s *KeywordsCanBeIdContext) FILTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserFILTER, 0)
}

func (s *KeywordsCanBeIdContext) FIREWALL_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserFIREWALL_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) FIREWALL_USER() antlr.TerminalNode {
	return s.GetToken(MySqlParserFIREWALL_USER, 0)
}

func (s *KeywordsCanBeIdContext) FIRST() antlr.TerminalNode {
	return s.GetToken(MySqlParserFIRST, 0)
}

func (s *KeywordsCanBeIdContext) FIXED() antlr.TerminalNode {
	return s.GetToken(MySqlParserFIXED, 0)
}

func (s *KeywordsCanBeIdContext) FLUSH() antlr.TerminalNode {
	return s.GetToken(MySqlParserFLUSH, 0)
}

func (s *KeywordsCanBeIdContext) FOLLOWS() antlr.TerminalNode {
	return s.GetToken(MySqlParserFOLLOWS, 0)
}

func (s *KeywordsCanBeIdContext) FOUND() antlr.TerminalNode {
	return s.GetToken(MySqlParserFOUND, 0)
}

func (s *KeywordsCanBeIdContext) FULL() antlr.TerminalNode {
	return s.GetToken(MySqlParserFULL, 0)
}

func (s *KeywordsCanBeIdContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserFUNCTION, 0)
}

func (s *KeywordsCanBeIdContext) GENERAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserGENERAL, 0)
}

func (s *KeywordsCanBeIdContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserGLOBAL, 0)
}

func (s *KeywordsCanBeIdContext) GRANTS() antlr.TerminalNode {
	return s.GetToken(MySqlParserGRANTS, 0)
}

func (s *KeywordsCanBeIdContext) GROUP_REPLICATION() antlr.TerminalNode {
	return s.GetToken(MySqlParserGROUP_REPLICATION, 0)
}

func (s *KeywordsCanBeIdContext) GROUP_REPLICATION_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserGROUP_REPLICATION_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) HANDLER() antlr.TerminalNode {
	return s.GetToken(MySqlParserHANDLER, 0)
}

func (s *KeywordsCanBeIdContext) HASH() antlr.TerminalNode {
	return s.GetToken(MySqlParserHASH, 0)
}

func (s *KeywordsCanBeIdContext) HELP() antlr.TerminalNode {
	return s.GetToken(MySqlParserHELP, 0)
}

func (s *KeywordsCanBeIdContext) HOST() antlr.TerminalNode {
	return s.GetToken(MySqlParserHOST, 0)
}

func (s *KeywordsCanBeIdContext) HOSTS() antlr.TerminalNode {
	return s.GetToken(MySqlParserHOSTS, 0)
}

func (s *KeywordsCanBeIdContext) IDENTIFIED() antlr.TerminalNode {
	return s.GetToken(MySqlParserIDENTIFIED, 0)
}

func (s *KeywordsCanBeIdContext) IGNORE_SERVER_IDS() antlr.TerminalNode {
	return s.GetToken(MySqlParserIGNORE_SERVER_IDS, 0)
}

func (s *KeywordsCanBeIdContext) IMPORT() antlr.TerminalNode {
	return s.GetToken(MySqlParserIMPORT, 0)
}

func (s *KeywordsCanBeIdContext) INDEXES() antlr.TerminalNode {
	return s.GetToken(MySqlParserINDEXES, 0)
}

func (s *KeywordsCanBeIdContext) INITIAL_SIZE() antlr.TerminalNode {
	return s.GetToken(MySqlParserINITIAL_SIZE, 0)
}

func (s *KeywordsCanBeIdContext) INNODB_REDO_LOG_ARCHIVE() antlr.TerminalNode {
	return s.GetToken(MySqlParserINNODB_REDO_LOG_ARCHIVE, 0)
}

func (s *KeywordsCanBeIdContext) INPLACE() antlr.TerminalNode {
	return s.GetToken(MySqlParserINPLACE, 0)
}

func (s *KeywordsCanBeIdContext) INSERT_METHOD() antlr.TerminalNode {
	return s.GetToken(MySqlParserINSERT_METHOD, 0)
}

func (s *KeywordsCanBeIdContext) INSTALL() antlr.TerminalNode {
	return s.GetToken(MySqlParserINSTALL, 0)
}

func (s *KeywordsCanBeIdContext) INSTANCE() antlr.TerminalNode {
	return s.GetToken(MySqlParserINSTANCE, 0)
}

func (s *KeywordsCanBeIdContext) INTERNAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserINTERNAL, 0)
}

func (s *KeywordsCanBeIdContext) INVOKER() antlr.TerminalNode {
	return s.GetToken(MySqlParserINVOKER, 0)
}

func (s *KeywordsCanBeIdContext) IO() antlr.TerminalNode {
	return s.GetToken(MySqlParserIO, 0)
}

func (s *KeywordsCanBeIdContext) IO_THREAD() antlr.TerminalNode {
	return s.GetToken(MySqlParserIO_THREAD, 0)
}

func (s *KeywordsCanBeIdContext) IPC() antlr.TerminalNode {
	return s.GetToken(MySqlParserIPC, 0)
}

func (s *KeywordsCanBeIdContext) ISOLATION() antlr.TerminalNode {
	return s.GetToken(MySqlParserISOLATION, 0)
}

func (s *KeywordsCanBeIdContext) ISSUER() antlr.TerminalNode {
	return s.GetToken(MySqlParserISSUER, 0)
}

func (s *KeywordsCanBeIdContext) JSON() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON, 0)
}

func (s *KeywordsCanBeIdContext) KEY_BLOCK_SIZE() antlr.TerminalNode {
	return s.GetToken(MySqlParserKEY_BLOCK_SIZE, 0)
}

func (s *KeywordsCanBeIdContext) LANGUAGE() antlr.TerminalNode {
	return s.GetToken(MySqlParserLANGUAGE, 0)
}

func (s *KeywordsCanBeIdContext) LAST() antlr.TerminalNode {
	return s.GetToken(MySqlParserLAST, 0)
}

func (s *KeywordsCanBeIdContext) LEAVES() antlr.TerminalNode {
	return s.GetToken(MySqlParserLEAVES, 0)
}

func (s *KeywordsCanBeIdContext) LESS() antlr.TerminalNode {
	return s.GetToken(MySqlParserLESS, 0)
}

func (s *KeywordsCanBeIdContext) LEVEL() antlr.TerminalNode {
	return s.GetToken(MySqlParserLEVEL, 0)
}

func (s *KeywordsCanBeIdContext) LIST() antlr.TerminalNode {
	return s.GetToken(MySqlParserLIST, 0)
}

func (s *KeywordsCanBeIdContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCAL, 0)
}

func (s *KeywordsCanBeIdContext) LOGFILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOGFILE, 0)
}

func (s *KeywordsCanBeIdContext) LOGS() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOGS, 0)
}

func (s *KeywordsCanBeIdContext) MASTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_AUTO_POSITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_AUTO_POSITION, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_CONNECT_RETRY() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_CONNECT_RETRY, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_DELAY() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_DELAY, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_HEARTBEAT_PERIOD() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_HEARTBEAT_PERIOD, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_HOST() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_HOST, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_LOG_FILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_LOG_FILE, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_LOG_POS() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_LOG_POS, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_PASSWORD() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_PASSWORD, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_PORT() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_PORT, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_RETRY_COUNT() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_RETRY_COUNT, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_SSL() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_SSL, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_SSL_CA() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_SSL_CA, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_SSL_CAPATH() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_SSL_CAPATH, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_SSL_CERT() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_SSL_CERT, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_SSL_CIPHER() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_SSL_CIPHER, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_SSL_CRL() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_SSL_CRL, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_SSL_CRLPATH() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_SSL_CRLPATH, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_SSL_KEY() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_SSL_KEY, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_TLS_VERSION() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_TLS_VERSION, 0)
}

func (s *KeywordsCanBeIdContext) MASTER_USER() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_USER, 0)
}

func (s *KeywordsCanBeIdContext) MAX_CONNECTIONS_PER_HOUR() antlr.TerminalNode {
	return s.GetToken(MySqlParserMAX_CONNECTIONS_PER_HOUR, 0)
}

func (s *KeywordsCanBeIdContext) MAX_QUERIES_PER_HOUR() antlr.TerminalNode {
	return s.GetToken(MySqlParserMAX_QUERIES_PER_HOUR, 0)
}

func (s *KeywordsCanBeIdContext) MAX_ROWS() antlr.TerminalNode {
	return s.GetToken(MySqlParserMAX_ROWS, 0)
}

func (s *KeywordsCanBeIdContext) MAX_SIZE() antlr.TerminalNode {
	return s.GetToken(MySqlParserMAX_SIZE, 0)
}

func (s *KeywordsCanBeIdContext) MAX_UPDATES_PER_HOUR() antlr.TerminalNode {
	return s.GetToken(MySqlParserMAX_UPDATES_PER_HOUR, 0)
}

func (s *KeywordsCanBeIdContext) MAX_USER_CONNECTIONS() antlr.TerminalNode {
	return s.GetToken(MySqlParserMAX_USER_CONNECTIONS, 0)
}

func (s *KeywordsCanBeIdContext) MEDIUM() antlr.TerminalNode {
	return s.GetToken(MySqlParserMEDIUM, 0)
}

func (s *KeywordsCanBeIdContext) MEMBER() antlr.TerminalNode {
	return s.GetToken(MySqlParserMEMBER, 0)
}

func (s *KeywordsCanBeIdContext) MEMORY() antlr.TerminalNode {
	return s.GetToken(MySqlParserMEMORY, 0)
}

func (s *KeywordsCanBeIdContext) MERGE() antlr.TerminalNode {
	return s.GetToken(MySqlParserMERGE, 0)
}

func (s *KeywordsCanBeIdContext) MESSAGE_TEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserMESSAGE_TEXT, 0)
}

func (s *KeywordsCanBeIdContext) MID() antlr.TerminalNode {
	return s.GetToken(MySqlParserMID, 0)
}

func (s *KeywordsCanBeIdContext) MIGRATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserMIGRATE, 0)
}

func (s *KeywordsCanBeIdContext) MIN_ROWS() antlr.TerminalNode {
	return s.GetToken(MySqlParserMIN_ROWS, 0)
}

func (s *KeywordsCanBeIdContext) MODE() antlr.TerminalNode {
	return s.GetToken(MySqlParserMODE, 0)
}

func (s *KeywordsCanBeIdContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(MySqlParserMODIFY, 0)
}

func (s *KeywordsCanBeIdContext) MUTEX() antlr.TerminalNode {
	return s.GetToken(MySqlParserMUTEX, 0)
}

func (s *KeywordsCanBeIdContext) MYSQL() antlr.TerminalNode {
	return s.GetToken(MySqlParserMYSQL, 0)
}

func (s *KeywordsCanBeIdContext) MYSQL_ERRNO() antlr.TerminalNode {
	return s.GetToken(MySqlParserMYSQL_ERRNO, 0)
}

func (s *KeywordsCanBeIdContext) NAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserNAME, 0)
}

func (s *KeywordsCanBeIdContext) NAMES() antlr.TerminalNode {
	return s.GetToken(MySqlParserNAMES, 0)
}

func (s *KeywordsCanBeIdContext) NCHAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserNCHAR, 0)
}

func (s *KeywordsCanBeIdContext) NDB_STORED_USER() antlr.TerminalNode {
	return s.GetToken(MySqlParserNDB_STORED_USER, 0)
}

func (s *KeywordsCanBeIdContext) NEVER() antlr.TerminalNode {
	return s.GetToken(MySqlParserNEVER, 0)
}

func (s *KeywordsCanBeIdContext) NEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserNEXT, 0)
}

func (s *KeywordsCanBeIdContext) NO() antlr.TerminalNode {
	return s.GetToken(MySqlParserNO, 0)
}

func (s *KeywordsCanBeIdContext) NODEGROUP() antlr.TerminalNode {
	return s.GetToken(MySqlParserNODEGROUP, 0)
}

func (s *KeywordsCanBeIdContext) NONE() antlr.TerminalNode {
	return s.GetToken(MySqlParserNONE, 0)
}

func (s *KeywordsCanBeIdContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(MySqlParserNUMBER, 0)
}

func (s *KeywordsCanBeIdContext) OFFLINE() antlr.TerminalNode {
	return s.GetToken(MySqlParserOFFLINE, 0)
}

func (s *KeywordsCanBeIdContext) OFFSET() antlr.TerminalNode {
	return s.GetToken(MySqlParserOFFSET, 0)
}

func (s *KeywordsCanBeIdContext) OF() antlr.TerminalNode {
	return s.GetToken(MySqlParserOF, 0)
}

func (s *KeywordsCanBeIdContext) OJ() antlr.TerminalNode {
	return s.GetToken(MySqlParserOJ, 0)
}

func (s *KeywordsCanBeIdContext) OLD_PASSWORD() antlr.TerminalNode {
	return s.GetToken(MySqlParserOLD_PASSWORD, 0)
}

func (s *KeywordsCanBeIdContext) ONE() antlr.TerminalNode {
	return s.GetToken(MySqlParserONE, 0)
}

func (s *KeywordsCanBeIdContext) ONLINE() antlr.TerminalNode {
	return s.GetToken(MySqlParserONLINE, 0)
}

func (s *KeywordsCanBeIdContext) ONLY() antlr.TerminalNode {
	return s.GetToken(MySqlParserONLY, 0)
}

func (s *KeywordsCanBeIdContext) OPEN() antlr.TerminalNode {
	return s.GetToken(MySqlParserOPEN, 0)
}

func (s *KeywordsCanBeIdContext) OPTIMIZER_COSTS() antlr.TerminalNode {
	return s.GetToken(MySqlParserOPTIMIZER_COSTS, 0)
}

func (s *KeywordsCanBeIdContext) OPTIONS() antlr.TerminalNode {
	return s.GetToken(MySqlParserOPTIONS, 0)
}

func (s *KeywordsCanBeIdContext) OWNER() antlr.TerminalNode {
	return s.GetToken(MySqlParserOWNER, 0)
}

func (s *KeywordsCanBeIdContext) PACK_KEYS() antlr.TerminalNode {
	return s.GetToken(MySqlParserPACK_KEYS, 0)
}

func (s *KeywordsCanBeIdContext) PAGE() antlr.TerminalNode {
	return s.GetToken(MySqlParserPAGE, 0)
}

func (s *KeywordsCanBeIdContext) PARSER() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARSER, 0)
}

func (s *KeywordsCanBeIdContext) PARTIAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARTIAL, 0)
}

func (s *KeywordsCanBeIdContext) PARTITIONING() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARTITIONING, 0)
}

func (s *KeywordsCanBeIdContext) PARTITIONS() antlr.TerminalNode {
	return s.GetToken(MySqlParserPARTITIONS, 0)
}

func (s *KeywordsCanBeIdContext) PASSWORD() antlr.TerminalNode {
	return s.GetToken(MySqlParserPASSWORD, 0)
}

func (s *KeywordsCanBeIdContext) PERSIST_RO_VARIABLES_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserPERSIST_RO_VARIABLES_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) PHASE() antlr.TerminalNode {
	return s.GetToken(MySqlParserPHASE, 0)
}

func (s *KeywordsCanBeIdContext) PLUGINS() antlr.TerminalNode {
	return s.GetToken(MySqlParserPLUGINS, 0)
}

func (s *KeywordsCanBeIdContext) PLUGIN_DIR() antlr.TerminalNode {
	return s.GetToken(MySqlParserPLUGIN_DIR, 0)
}

func (s *KeywordsCanBeIdContext) PLUGIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserPLUGIN, 0)
}

func (s *KeywordsCanBeIdContext) PORT() antlr.TerminalNode {
	return s.GetToken(MySqlParserPORT, 0)
}

func (s *KeywordsCanBeIdContext) PRECEDES() antlr.TerminalNode {
	return s.GetToken(MySqlParserPRECEDES, 0)
}

func (s *KeywordsCanBeIdContext) PREPARE() antlr.TerminalNode {
	return s.GetToken(MySqlParserPREPARE, 0)
}

func (s *KeywordsCanBeIdContext) PRESERVE() antlr.TerminalNode {
	return s.GetToken(MySqlParserPRESERVE, 0)
}

func (s *KeywordsCanBeIdContext) PREV() antlr.TerminalNode {
	return s.GetToken(MySqlParserPREV, 0)
}

func (s *KeywordsCanBeIdContext) PROCESSLIST() antlr.TerminalNode {
	return s.GetToken(MySqlParserPROCESSLIST, 0)
}

func (s *KeywordsCanBeIdContext) PROFILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserPROFILE, 0)
}

func (s *KeywordsCanBeIdContext) PROFILES() antlr.TerminalNode {
	return s.GetToken(MySqlParserPROFILES, 0)
}

func (s *KeywordsCanBeIdContext) PROXY() antlr.TerminalNode {
	return s.GetToken(MySqlParserPROXY, 0)
}

func (s *KeywordsCanBeIdContext) QUERY() antlr.TerminalNode {
	return s.GetToken(MySqlParserQUERY, 0)
}

func (s *KeywordsCanBeIdContext) QUICK() antlr.TerminalNode {
	return s.GetToken(MySqlParserQUICK, 0)
}

func (s *KeywordsCanBeIdContext) REBUILD() antlr.TerminalNode {
	return s.GetToken(MySqlParserREBUILD, 0)
}

func (s *KeywordsCanBeIdContext) RECOVER() antlr.TerminalNode {
	return s.GetToken(MySqlParserRECOVER, 0)
}

func (s *KeywordsCanBeIdContext) REDO_BUFFER_SIZE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREDO_BUFFER_SIZE, 0)
}

func (s *KeywordsCanBeIdContext) REDUNDANT() antlr.TerminalNode {
	return s.GetToken(MySqlParserREDUNDANT, 0)
}

func (s *KeywordsCanBeIdContext) RELAY() antlr.TerminalNode {
	return s.GetToken(MySqlParserRELAY, 0)
}

func (s *KeywordsCanBeIdContext) RELAYLOG() antlr.TerminalNode {
	return s.GetToken(MySqlParserRELAYLOG, 0)
}

func (s *KeywordsCanBeIdContext) RELAY_LOG_FILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserRELAY_LOG_FILE, 0)
}

func (s *KeywordsCanBeIdContext) RELAY_LOG_POS() antlr.TerminalNode {
	return s.GetToken(MySqlParserRELAY_LOG_POS, 0)
}

func (s *KeywordsCanBeIdContext) REMOVE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREMOVE, 0)
}

func (s *KeywordsCanBeIdContext) REORGANIZE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREORGANIZE, 0)
}

func (s *KeywordsCanBeIdContext) REPAIR() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPAIR, 0)
}

func (s *KeywordsCanBeIdContext) REPLICATE_DO_DB() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPLICATE_DO_DB, 0)
}

func (s *KeywordsCanBeIdContext) REPLICATE_DO_TABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPLICATE_DO_TABLE, 0)
}

func (s *KeywordsCanBeIdContext) REPLICATE_IGNORE_DB() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPLICATE_IGNORE_DB, 0)
}

func (s *KeywordsCanBeIdContext) REPLICATE_IGNORE_TABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPLICATE_IGNORE_TABLE, 0)
}

func (s *KeywordsCanBeIdContext) REPLICATE_REWRITE_DB() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPLICATE_REWRITE_DB, 0)
}

func (s *KeywordsCanBeIdContext) REPLICATE_WILD_DO_TABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPLICATE_WILD_DO_TABLE, 0)
}

func (s *KeywordsCanBeIdContext) REPLICATE_WILD_IGNORE_TABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPLICATE_WILD_IGNORE_TABLE, 0)
}

func (s *KeywordsCanBeIdContext) REPLICATION() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPLICATION, 0)
}

func (s *KeywordsCanBeIdContext) REPLICATION_APPLIER() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPLICATION_APPLIER, 0)
}

func (s *KeywordsCanBeIdContext) REPLICATION_SLAVE_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserREPLICATION_SLAVE_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) RESET() antlr.TerminalNode {
	return s.GetToken(MySqlParserRESET, 0)
}

func (s *KeywordsCanBeIdContext) RESOURCE_GROUP_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserRESOURCE_GROUP_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) RESOURCE_GROUP_USER() antlr.TerminalNode {
	return s.GetToken(MySqlParserRESOURCE_GROUP_USER, 0)
}

func (s *KeywordsCanBeIdContext) RESUME() antlr.TerminalNode {
	return s.GetToken(MySqlParserRESUME, 0)
}

func (s *KeywordsCanBeIdContext) RETURNED_SQLSTATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserRETURNED_SQLSTATE, 0)
}

func (s *KeywordsCanBeIdContext) RETURNS() antlr.TerminalNode {
	return s.GetToken(MySqlParserRETURNS, 0)
}

func (s *KeywordsCanBeIdContext) ROLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserROLE, 0)
}

func (s *KeywordsCanBeIdContext) ROLE_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserROLE_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) ROLLBACK() antlr.TerminalNode {
	return s.GetToken(MySqlParserROLLBACK, 0)
}

func (s *KeywordsCanBeIdContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(MySqlParserROLLUP, 0)
}

func (s *KeywordsCanBeIdContext) ROTATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserROTATE, 0)
}

func (s *KeywordsCanBeIdContext) ROW() antlr.TerminalNode {
	return s.GetToken(MySqlParserROW, 0)
}

func (s *KeywordsCanBeIdContext) ROWS() antlr.TerminalNode {
	return s.GetToken(MySqlParserROWS, 0)
}

func (s *KeywordsCanBeIdContext) ROW_FORMAT() antlr.TerminalNode {
	return s.GetToken(MySqlParserROW_FORMAT, 0)
}

func (s *KeywordsCanBeIdContext) SAVEPOINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserSAVEPOINT, 0)
}

func (s *KeywordsCanBeIdContext) SCHEDULE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSCHEDULE, 0)
}

func (s *KeywordsCanBeIdContext) SCHEMA_NAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserSCHEMA_NAME, 0)
}

func (s *KeywordsCanBeIdContext) SECURITY() antlr.TerminalNode {
	return s.GetToken(MySqlParserSECURITY, 0)
}

func (s *KeywordsCanBeIdContext) SERIAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserSERIAL, 0)
}

func (s *KeywordsCanBeIdContext) SERVER() antlr.TerminalNode {
	return s.GetToken(MySqlParserSERVER, 0)
}

func (s *KeywordsCanBeIdContext) SESSION() antlr.TerminalNode {
	return s.GetToken(MySqlParserSESSION, 0)
}

func (s *KeywordsCanBeIdContext) SESSION_VARIABLES_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserSESSION_VARIABLES_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) SET_USER_ID() antlr.TerminalNode {
	return s.GetToken(MySqlParserSET_USER_ID, 0)
}

func (s *KeywordsCanBeIdContext) SHARE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSHARE, 0)
}

func (s *KeywordsCanBeIdContext) SHARED() antlr.TerminalNode {
	return s.GetToken(MySqlParserSHARED, 0)
}

func (s *KeywordsCanBeIdContext) SHOW_ROUTINE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSHOW_ROUTINE, 0)
}

func (s *KeywordsCanBeIdContext) SIGNED() antlr.TerminalNode {
	return s.GetToken(MySqlParserSIGNED, 0)
}

func (s *KeywordsCanBeIdContext) SIMPLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSIMPLE, 0)
}

func (s *KeywordsCanBeIdContext) SLAVE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSLAVE, 0)
}

func (s *KeywordsCanBeIdContext) SLOW() antlr.TerminalNode {
	return s.GetToken(MySqlParserSLOW, 0)
}

func (s *KeywordsCanBeIdContext) SNAPSHOT() antlr.TerminalNode {
	return s.GetToken(MySqlParserSNAPSHOT, 0)
}

func (s *KeywordsCanBeIdContext) SOCKET() antlr.TerminalNode {
	return s.GetToken(MySqlParserSOCKET, 0)
}

func (s *KeywordsCanBeIdContext) SOME() antlr.TerminalNode {
	return s.GetToken(MySqlParserSOME, 0)
}

func (s *KeywordsCanBeIdContext) SONAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserSONAME, 0)
}

func (s *KeywordsCanBeIdContext) SOUNDS() antlr.TerminalNode {
	return s.GetToken(MySqlParserSOUNDS, 0)
}

func (s *KeywordsCanBeIdContext) SOURCE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSOURCE, 0)
}

func (s *KeywordsCanBeIdContext) SQL_AFTER_GTIDS() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQL_AFTER_GTIDS, 0)
}

func (s *KeywordsCanBeIdContext) SQL_AFTER_MTS_GAPS() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQL_AFTER_MTS_GAPS, 0)
}

func (s *KeywordsCanBeIdContext) SQL_BEFORE_GTIDS() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQL_BEFORE_GTIDS, 0)
}

func (s *KeywordsCanBeIdContext) SQL_BUFFER_RESULT() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQL_BUFFER_RESULT, 0)
}

func (s *KeywordsCanBeIdContext) SQL_CACHE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQL_CACHE, 0)
}

func (s *KeywordsCanBeIdContext) SQL_NO_CACHE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQL_NO_CACHE, 0)
}

func (s *KeywordsCanBeIdContext) SQL_THREAD() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQL_THREAD, 0)
}

func (s *KeywordsCanBeIdContext) STACKED() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTACKED, 0)
}

func (s *KeywordsCanBeIdContext) START() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTART, 0)
}

func (s *KeywordsCanBeIdContext) STARTS() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTARTS, 0)
}

func (s *KeywordsCanBeIdContext) STATS_AUTO_RECALC() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTATS_AUTO_RECALC, 0)
}

func (s *KeywordsCanBeIdContext) STATS_PERSISTENT() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTATS_PERSISTENT, 0)
}

func (s *KeywordsCanBeIdContext) STATS_SAMPLE_PAGES() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTATS_SAMPLE_PAGES, 0)
}

func (s *KeywordsCanBeIdContext) STATUS() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTATUS, 0)
}

func (s *KeywordsCanBeIdContext) STOP() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTOP, 0)
}

func (s *KeywordsCanBeIdContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTORAGE, 0)
}

func (s *KeywordsCanBeIdContext) STRING() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRING, 0)
}

func (s *KeywordsCanBeIdContext) SUBCLASS_ORIGIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserSUBCLASS_ORIGIN, 0)
}

func (s *KeywordsCanBeIdContext) SUBJECT() antlr.TerminalNode {
	return s.GetToken(MySqlParserSUBJECT, 0)
}

func (s *KeywordsCanBeIdContext) SUBPARTITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserSUBPARTITION, 0)
}

func (s *KeywordsCanBeIdContext) SUBPARTITIONS() antlr.TerminalNode {
	return s.GetToken(MySqlParserSUBPARTITIONS, 0)
}

func (s *KeywordsCanBeIdContext) SUSPEND() antlr.TerminalNode {
	return s.GetToken(MySqlParserSUSPEND, 0)
}

func (s *KeywordsCanBeIdContext) SWAPS() antlr.TerminalNode {
	return s.GetToken(MySqlParserSWAPS, 0)
}

func (s *KeywordsCanBeIdContext) SWITCHES() antlr.TerminalNode {
	return s.GetToken(MySqlParserSWITCHES, 0)
}

func (s *KeywordsCanBeIdContext) SYSTEM_VARIABLES_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserSYSTEM_VARIABLES_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) TABLE_NAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLE_NAME, 0)
}

func (s *KeywordsCanBeIdContext) TABLESPACE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLESPACE, 0)
}

func (s *KeywordsCanBeIdContext) TABLE_ENCRYPTION_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserTABLE_ENCRYPTION_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(MySqlParserTEMPORARY, 0)
}

func (s *KeywordsCanBeIdContext) TEMPTABLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTEMPTABLE, 0)
}

func (s *KeywordsCanBeIdContext) THAN() antlr.TerminalNode {
	return s.GetToken(MySqlParserTHAN, 0)
}

func (s *KeywordsCanBeIdContext) TRADITIONAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserTRADITIONAL, 0)
}

func (s *KeywordsCanBeIdContext) TRANSACTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserTRANSACTION, 0)
}

func (s *KeywordsCanBeIdContext) TRANSACTIONAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserTRANSACTIONAL, 0)
}

func (s *KeywordsCanBeIdContext) TRIGGERS() antlr.TerminalNode {
	return s.GetToken(MySqlParserTRIGGERS, 0)
}

func (s *KeywordsCanBeIdContext) TRUNCATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserTRUNCATE, 0)
}

func (s *KeywordsCanBeIdContext) UNDEFINED() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNDEFINED, 0)
}

func (s *KeywordsCanBeIdContext) UNDOFILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNDOFILE, 0)
}

func (s *KeywordsCanBeIdContext) UNDO_BUFFER_SIZE() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNDO_BUFFER_SIZE, 0)
}

func (s *KeywordsCanBeIdContext) UNINSTALL() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNINSTALL, 0)
}

func (s *KeywordsCanBeIdContext) UNKNOWN() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNKNOWN, 0)
}

func (s *KeywordsCanBeIdContext) UNTIL() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNTIL, 0)
}

func (s *KeywordsCanBeIdContext) UPGRADE() antlr.TerminalNode {
	return s.GetToken(MySqlParserUPGRADE, 0)
}

func (s *KeywordsCanBeIdContext) USER() antlr.TerminalNode {
	return s.GetToken(MySqlParserUSER, 0)
}

func (s *KeywordsCanBeIdContext) USE_FRM() antlr.TerminalNode {
	return s.GetToken(MySqlParserUSE_FRM, 0)
}

func (s *KeywordsCanBeIdContext) USER_RESOURCES() antlr.TerminalNode {
	return s.GetToken(MySqlParserUSER_RESOURCES, 0)
}

func (s *KeywordsCanBeIdContext) VALIDATION() antlr.TerminalNode {
	return s.GetToken(MySqlParserVALIDATION, 0)
}

func (s *KeywordsCanBeIdContext) VALUE() antlr.TerminalNode {
	return s.GetToken(MySqlParserVALUE, 0)
}

func (s *KeywordsCanBeIdContext) VARIABLES() antlr.TerminalNode {
	return s.GetToken(MySqlParserVARIABLES, 0)
}

func (s *KeywordsCanBeIdContext) VERSION_TOKEN_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserVERSION_TOKEN_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) VIEW() antlr.TerminalNode {
	return s.GetToken(MySqlParserVIEW, 0)
}

func (s *KeywordsCanBeIdContext) WAIT() antlr.TerminalNode {
	return s.GetToken(MySqlParserWAIT, 0)
}

func (s *KeywordsCanBeIdContext) WARNINGS() antlr.TerminalNode {
	return s.GetToken(MySqlParserWARNINGS, 0)
}

func (s *KeywordsCanBeIdContext) WITHOUT() antlr.TerminalNode {
	return s.GetToken(MySqlParserWITHOUT, 0)
}

func (s *KeywordsCanBeIdContext) WORK() antlr.TerminalNode {
	return s.GetToken(MySqlParserWORK, 0)
}

func (s *KeywordsCanBeIdContext) WRAPPER() antlr.TerminalNode {
	return s.GetToken(MySqlParserWRAPPER, 0)
}

func (s *KeywordsCanBeIdContext) X509() antlr.TerminalNode {
	return s.GetToken(MySqlParserX509, 0)
}

func (s *KeywordsCanBeIdContext) XA() antlr.TerminalNode {
	return s.GetToken(MySqlParserXA, 0)
}

func (s *KeywordsCanBeIdContext) XA_RECOVER_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserXA_RECOVER_ADMIN, 0)
}

func (s *KeywordsCanBeIdContext) XML() antlr.TerminalNode {
	return s.GetToken(MySqlParserXML, 0)
}

func (s *KeywordsCanBeIdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeywordsCanBeIdContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KeywordsCanBeIdContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterKeywordsCanBeId(s)
	}
}

func (s *KeywordsCanBeIdContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitKeywordsCanBeId(s)
	}
}

func (s *KeywordsCanBeIdContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitKeywordsCanBeId(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) KeywordsCanBeId() (localctx IKeywordsCanBeIdContext) {
	localctx = NewKeywordsCanBeIdContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, MySqlParserRULE_keywordsCanBeId)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1473)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserCURRENT || _la == MySqlParserDIAGNOSTICS || _la == MySqlParserNUMBER || _la == MySqlParserSTACKED || _la == MySqlParserSERIAL || (((_la-270)&-(0x1f+1)) == 0 && ((1<<uint((_la-270)))&((1<<(MySqlParserACCOUNT-270))|(1<<(MySqlParserACTION-270))|(1<<(MySqlParserAFTER-270))|(1<<(MySqlParserAGGREGATE-270))|(1<<(MySqlParserALGORITHM-270))|(1<<(MySqlParserANY-270))|(1<<(MySqlParserAT-270))|(1<<(MySqlParserAUTHORS-270))|(1<<(MySqlParserAUTOCOMMIT-270))|(1<<(MySqlParserAUTOEXTEND_SIZE-270))|(1<<(MySqlParserAUTO_INCREMENT-270))|(1<<(MySqlParserAVG_ROW_LENGTH-270))|(1<<(MySqlParserBEGIN-270))|(1<<(MySqlParserBINLOG-270))|(1<<(MySqlParserBIT-270))|(1<<(MySqlParserBLOCK-270))|(1<<(MySqlParserBOOL-270))|(1<<(MySqlParserBOOLEAN-270))|(1<<(MySqlParserBTREE-270))|(1<<(MySqlParserCACHE-270))|(1<<(MySqlParserCASCADED-270))|(1<<(MySqlParserCHAIN-270))|(1<<(MySqlParserCHANGED-270))|(1<<(MySqlParserCHANNEL-270))|(1<<(MySqlParserCHECKSUM-270))|(1<<(MySqlParserPAGE_CHECKSUM-270))|(1<<(MySqlParserCIPHER-270))|(1<<(MySqlParserCLASS_ORIGIN-270))|(1<<(MySqlParserCLIENT-270))|(1<<(MySqlParserCLOSE-270))|(1<<(MySqlParserCOALESCE-270))|(1<<(MySqlParserCODE-270)))) != 0) || (((_la-302)&-(0x1f+1)) == 0 && ((1<<uint((_la-302)))&((1<<(MySqlParserCOLUMNS-302))|(1<<(MySqlParserCOLUMN_FORMAT-302))|(1<<(MySqlParserCOLUMN_NAME-302))|(1<<(MySqlParserCOMMENT-302))|(1<<(MySqlParserCOMMIT-302))|(1<<(MySqlParserCOMPACT-302))|(1<<(MySqlParserCOMPLETION-302))|(1<<(MySqlParserCOMPRESSED-302))|(1<<(MySqlParserCOMPRESSION-302))|(1<<(MySqlParserCONCURRENT-302))|(1<<(MySqlParserCONNECTION-302))|(1<<(MySqlParserCONSISTENT-302))|(1<<(MySqlParserCONSTRAINT_CATALOG-302))|(1<<(MySqlParserCONSTRAINT_SCHEMA-302))|(1<<(MySqlParserCONSTRAINT_NAME-302))|(1<<(MySqlParserCONTAINS-302))|(1<<(MySqlParserCONTEXT-302))|(1<<(MySqlParserCONTRIBUTORS-302))|(1<<(MySqlParserCOPY-302))|(1<<(MySqlParserCPU-302))|(1<<(MySqlParserCURSOR_NAME-302))|(1<<(MySqlParserDATA-302))|(1<<(MySqlParserDATAFILE-302))|(1<<(MySqlParserDEALLOCATE-302))|(1<<(MySqlParserDEFAULT_AUTH-302))|(1<<(MySqlParserDEFINER-302))|(1<<(MySqlParserDELAY_KEY_WRITE-302))|(1<<(MySqlParserDES_KEY_FILE-302))|(1<<(MySqlParserDIRECTORY-302))|(1<<(MySqlParserDISABLE-302))|(1<<(MySqlParserDISCARD-302))|(1<<(MySqlParserDISK-302)))) != 0) || (((_la-334)&-(0x1f+1)) == 0 && ((1<<uint((_la-334)))&((1<<(MySqlParserDO-334))|(1<<(MySqlParserDUMPFILE-334))|(1<<(MySqlParserDUPLICATE-334))|(1<<(MySqlParserDYNAMIC-334))|(1<<(MySqlParserENABLE-334))|(1<<(MySqlParserENCRYPTION-334))|(1<<(MySqlParserEND-334))|(1<<(MySqlParserENDS-334))|(1<<(MySqlParserENGINE-334))|(1<<(MySqlParserENGINES-334))|(1<<(MySqlParserERROR-334))|(1<<(MySqlParserERRORS-334))|(1<<(MySqlParserESCAPE-334))|(1<<(MySqlParserEVEN-334))|(1<<(MySqlParserEVENT-334))|(1<<(MySqlParserEVENTS-334))|(1<<(MySqlParserEVERY-334))|(1<<(MySqlParserEXCHANGE-334))|(1<<(MySqlParserEXCLUSIVE-334))|(1<<(MySqlParserEXPIRE-334))|(1<<(MySqlParserEXPORT-334))|(1<<(MySqlParserEXTENDED-334))|(1<<(MySqlParserEXTENT_SIZE-334))|(1<<(MySqlParserFAST-334))|(1<<(MySqlParserFAULTS-334))|(1<<(MySqlParserFIELDS-334))|(1<<(MySqlParserFILE_BLOCK_SIZE-334))|(1<<(MySqlParserFILTER-334))|(1<<(MySqlParserFIRST-334))|(1<<(MySqlParserFIXED-334))|(1<<(MySqlParserFLUSH-334))|(1<<(MySqlParserFOLLOWS-334)))) != 0) || (((_la-366)&-(0x1f+1)) == 0 && ((1<<uint((_la-366)))&((1<<(MySqlParserFOUND-366))|(1<<(MySqlParserFULL-366))|(1<<(MySqlParserFUNCTION-366))|(1<<(MySqlParserGENERAL-366))|(1<<(MySqlParserGLOBAL-366))|(1<<(MySqlParserGRANTS-366))|(1<<(MySqlParserGROUP_REPLICATION-366))|(1<<(MySqlParserHANDLER-366))|(1<<(MySqlParserHASH-366))|(1<<(MySqlParserHELP-366))|(1<<(MySqlParserHOST-366))|(1<<(MySqlParserHOSTS-366))|(1<<(MySqlParserIDENTIFIED-366))|(1<<(MySqlParserIGNORE_SERVER_IDS-366))|(1<<(MySqlParserIMPORT-366))|(1<<(MySqlParserINDEXES-366))|(1<<(MySqlParserINITIAL_SIZE-366))|(1<<(MySqlParserINPLACE-366))|(1<<(MySqlParserINSERT_METHOD-366))|(1<<(MySqlParserINSTALL-366))|(1<<(MySqlParserINSTANCE-366))|(1<<(MySqlParserINVOKER-366))|(1<<(MySqlParserIO-366))|(1<<(MySqlParserIO_THREAD-366))|(1<<(MySqlParserIPC-366))|(1<<(MySqlParserISOLATION-366))|(1<<(MySqlParserISSUER-366))|(1<<(MySqlParserJSON-366))|(1<<(MySqlParserKEY_BLOCK_SIZE-366))|(1<<(MySqlParserLANGUAGE-366))|(1<<(MySqlParserLAST-366)))) != 0) || (((_la-398)&-(0x1f+1)) == 0 && ((1<<uint((_la-398)))&((1<<(MySqlParserLEAVES-398))|(1<<(MySqlParserLESS-398))|(1<<(MySqlParserLEVEL-398))|(1<<(MySqlParserLIST-398))|(1<<(MySqlParserLOCAL-398))|(1<<(MySqlParserLOGFILE-398))|(1<<(MySqlParserLOGS-398))|(1<<(MySqlParserMASTER-398))|(1<<(MySqlParserMASTER_AUTO_POSITION-398))|(1<<(MySqlParserMASTER_CONNECT_RETRY-398))|(1<<(MySqlParserMASTER_DELAY-398))|(1<<(MySqlParserMASTER_HEARTBEAT_PERIOD-398))|(1<<(MySqlParserMASTER_HOST-398))|(1<<(MySqlParserMASTER_LOG_FILE-398))|(1<<(MySqlParserMASTER_LOG_POS-398))|(1<<(MySqlParserMASTER_PASSWORD-398))|(1<<(MySqlParserMASTER_PORT-398))|(1<<(MySqlParserMASTER_RETRY_COUNT-398))|(1<<(MySqlParserMASTER_SSL-398))|(1<<(MySqlParserMASTER_SSL_CA-398))|(1<<(MySqlParserMASTER_SSL_CAPATH-398))|(1<<(MySqlParserMASTER_SSL_CERT-398))|(1<<(MySqlParserMASTER_SSL_CIPHER-398))|(1<<(MySqlParserMASTER_SSL_CRL-398))|(1<<(MySqlParserMASTER_SSL_CRLPATH-398))|(1<<(MySqlParserMASTER_SSL_KEY-398))|(1<<(MySqlParserMASTER_TLS_VERSION-398))|(1<<(MySqlParserMASTER_USER-398))|(1<<(MySqlParserMAX_CONNECTIONS_PER_HOUR-398))|(1<<(MySqlParserMAX_QUERIES_PER_HOUR-398))|(1<<(MySqlParserMAX_ROWS-398))|(1<<(MySqlParserMAX_SIZE-398)))) != 0) || (((_la-430)&-(0x1f+1)) == 0 && ((1<<uint((_la-430)))&((1<<(MySqlParserMAX_UPDATES_PER_HOUR-430))|(1<<(MySqlParserMAX_USER_CONNECTIONS-430))|(1<<(MySqlParserMEDIUM-430))|(1<<(MySqlParserMEMBER-430))|(1<<(MySqlParserMERGE-430))|(1<<(MySqlParserMESSAGE_TEXT-430))|(1<<(MySqlParserMID-430))|(1<<(MySqlParserMIGRATE-430))|(1<<(MySqlParserMIN_ROWS-430))|(1<<(MySqlParserMODE-430))|(1<<(MySqlParserMODIFY-430))|(1<<(MySqlParserMUTEX-430))|(1<<(MySqlParserMYSQL-430))|(1<<(MySqlParserMYSQL_ERRNO-430))|(1<<(MySqlParserNAME-430))|(1<<(MySqlParserNAMES-430))|(1<<(MySqlParserNCHAR-430))|(1<<(MySqlParserNEVER-430))|(1<<(MySqlParserNEXT-430))|(1<<(MySqlParserNO-430))|(1<<(MySqlParserNODEGROUP-430))|(1<<(MySqlParserNONE-430))|(1<<(MySqlParserOFFLINE-430))|(1<<(MySqlParserOFFSET-430))|(1<<(MySqlParserOF-430))|(1<<(MySqlParserOJ-430))|(1<<(MySqlParserOLD_PASSWORD-430))|(1<<(MySqlParserONE-430))|(1<<(MySqlParserONLINE-430))|(1<<(MySqlParserONLY-430))|(1<<(MySqlParserOPEN-430))|(1<<(MySqlParserOPTIMIZER_COSTS-430)))) != 0) || (((_la-462)&-(0x1f+1)) == 0 && ((1<<uint((_la-462)))&((1<<(MySqlParserOPTIONS-462))|(1<<(MySqlParserOWNER-462))|(1<<(MySqlParserPACK_KEYS-462))|(1<<(MySqlParserPAGE-462))|(1<<(MySqlParserPARSER-462))|(1<<(MySqlParserPARTIAL-462))|(1<<(MySqlParserPARTITIONING-462))|(1<<(MySqlParserPARTITIONS-462))|(1<<(MySqlParserPASSWORD-462))|(1<<(MySqlParserPHASE-462))|(1<<(MySqlParserPLUGIN-462))|(1<<(MySqlParserPLUGIN_DIR-462))|(1<<(MySqlParserPLUGINS-462))|(1<<(MySqlParserPORT-462))|(1<<(MySqlParserPRECEDES-462))|(1<<(MySqlParserPREPARE-462))|(1<<(MySqlParserPRESERVE-462))|(1<<(MySqlParserPREV-462))|(1<<(MySqlParserPROCESSLIST-462))|(1<<(MySqlParserPROFILE-462))|(1<<(MySqlParserPROFILES-462))|(1<<(MySqlParserPROXY-462))|(1<<(MySqlParserQUERY-462))|(1<<(MySqlParserQUICK-462))|(1<<(MySqlParserREBUILD-462))|(1<<(MySqlParserRECOVER-462))|(1<<(MySqlParserREDO_BUFFER_SIZE-462))|(1<<(MySqlParserREDUNDANT-462))|(1<<(MySqlParserRELAY-462))|(1<<(MySqlParserRELAY_LOG_FILE-462))|(1<<(MySqlParserRELAY_LOG_POS-462))|(1<<(MySqlParserRELAYLOG-462)))) != 0) || (((_la-494)&-(0x1f+1)) == 0 && ((1<<uint((_la-494)))&((1<<(MySqlParserREMOVE-494))|(1<<(MySqlParserREORGANIZE-494))|(1<<(MySqlParserREPAIR-494))|(1<<(MySqlParserREPLICATE_DO_DB-494))|(1<<(MySqlParserREPLICATE_DO_TABLE-494))|(1<<(MySqlParserREPLICATE_IGNORE_DB-494))|(1<<(MySqlParserREPLICATE_IGNORE_TABLE-494))|(1<<(MySqlParserREPLICATE_REWRITE_DB-494))|(1<<(MySqlParserREPLICATE_WILD_DO_TABLE-494))|(1<<(MySqlParserREPLICATE_WILD_IGNORE_TABLE-494))|(1<<(MySqlParserREPLICATION-494))|(1<<(MySqlParserRESET-494))|(1<<(MySqlParserRESUME-494))|(1<<(MySqlParserRETURNED_SQLSTATE-494))|(1<<(MySqlParserRETURNS-494))|(1<<(MySqlParserROLE-494))|(1<<(MySqlParserROLLBACK-494))|(1<<(MySqlParserROLLUP-494))|(1<<(MySqlParserROTATE-494))|(1<<(MySqlParserROW-494))|(1<<(MySqlParserROWS-494))|(1<<(MySqlParserROW_FORMAT-494))|(1<<(MySqlParserSAVEPOINT-494))|(1<<(MySqlParserSCHEDULE-494))|(1<<(MySqlParserSECURITY-494))|(1<<(MySqlParserSERVER-494))|(1<<(MySqlParserSESSION-494))|(1<<(MySqlParserSHARE-494))|(1<<(MySqlParserSHARED-494))|(1<<(MySqlParserSIGNED-494))|(1<<(MySqlParserSIMPLE-494))|(1<<(MySqlParserSLAVE-494)))) != 0) || (((_la-526)&-(0x1f+1)) == 0 && ((1<<uint((_la-526)))&((1<<(MySqlParserSLOW-526))|(1<<(MySqlParserSNAPSHOT-526))|(1<<(MySqlParserSOCKET-526))|(1<<(MySqlParserSOME-526))|(1<<(MySqlParserSONAME-526))|(1<<(MySqlParserSOUNDS-526))|(1<<(MySqlParserSOURCE-526))|(1<<(MySqlParserSQL_AFTER_GTIDS-526))|(1<<(MySqlParserSQL_AFTER_MTS_GAPS-526))|(1<<(MySqlParserSQL_BEFORE_GTIDS-526))|(1<<(MySqlParserSQL_BUFFER_RESULT-526))|(1<<(MySqlParserSQL_CACHE-526))|(1<<(MySqlParserSQL_NO_CACHE-526))|(1<<(MySqlParserSQL_THREAD-526))|(1<<(MySqlParserSTART-526))|(1<<(MySqlParserSTARTS-526))|(1<<(MySqlParserSTATS_AUTO_RECALC-526))|(1<<(MySqlParserSTATS_PERSISTENT-526))|(1<<(MySqlParserSTATS_SAMPLE_PAGES-526))|(1<<(MySqlParserSTATUS-526))|(1<<(MySqlParserSTOP-526))|(1<<(MySqlParserSTORAGE-526))|(1<<(MySqlParserSTRING-526))|(1<<(MySqlParserSUBCLASS_ORIGIN-526))|(1<<(MySqlParserSUBJECT-526))|(1<<(MySqlParserSUBPARTITION-526))|(1<<(MySqlParserSUBPARTITIONS-526))|(1<<(MySqlParserSUSPEND-526))|(1<<(MySqlParserSWAPS-526))|(1<<(MySqlParserSWITCHES-526))|(1<<(MySqlParserTABLE_NAME-526)))) != 0) || (((_la-558)&-(0x1f+1)) == 0 && ((1<<uint((_la-558)))&((1<<(MySqlParserTABLESPACE-558))|(1<<(MySqlParserTEMPORARY-558))|(1<<(MySqlParserTEMPTABLE-558))|(1<<(MySqlParserTHAN-558))|(1<<(MySqlParserTRADITIONAL-558))|(1<<(MySqlParserTRANSACTION-558))|(1<<(MySqlParserTRANSACTIONAL-558))|(1<<(MySqlParserTRIGGERS-558))|(1<<(MySqlParserTRUNCATE-558))|(1<<(MySqlParserUNDEFINED-558))|(1<<(MySqlParserUNDOFILE-558))|(1<<(MySqlParserUNDO_BUFFER_SIZE-558))|(1<<(MySqlParserUNINSTALL-558))|(1<<(MySqlParserUNKNOWN-558))|(1<<(MySqlParserUNTIL-558))|(1<<(MySqlParserUPGRADE-558))|(1<<(MySqlParserUSER-558))|(1<<(MySqlParserUSE_FRM-558))|(1<<(MySqlParserUSER_RESOURCES-558))|(1<<(MySqlParserVALIDATION-558))|(1<<(MySqlParserVALUE-558))|(1<<(MySqlParserVARIABLES-558))|(1<<(MySqlParserVIEW-558))|(1<<(MySqlParserWAIT-558))|(1<<(MySqlParserWARNINGS-558))|(1<<(MySqlParserWITHOUT-558))|(1<<(MySqlParserWORK-558))|(1<<(MySqlParserWRAPPER-558))|(1<<(MySqlParserX509-558))|(1<<(MySqlParserXA-558)))) != 0) || (((_la-590)&-(0x1f+1)) == 0 && ((1<<uint((_la-590)))&((1<<(MySqlParserXML-590))|(1<<(MySqlParserINTERNAL-590))|(1<<(MySqlParserAUDIT_ADMIN-590))|(1<<(MySqlParserBACKUP_ADMIN-590))|(1<<(MySqlParserBINLOG_ADMIN-590))|(1<<(MySqlParserBINLOG_ENCRYPTION_ADMIN-590))|(1<<(MySqlParserCLONE_ADMIN-590))|(1<<(MySqlParserCONNECTION_ADMIN-590))|(1<<(MySqlParserENCRYPTION_KEY_ADMIN-590))|(1<<(MySqlParserFIREWALL_ADMIN-590)))) != 0) || (((_la-622)&-(0x1f+1)) == 0 && ((1<<uint((_la-622)))&((1<<(MySqlParserFIREWALL_USER-622))|(1<<(MySqlParserGROUP_REPLICATION_ADMIN-622))|(1<<(MySqlParserINNODB_REDO_LOG_ARCHIVE-622))|(1<<(MySqlParserNDB_STORED_USER-622))|(1<<(MySqlParserPERSIST_RO_VARIABLES_ADMIN-622))|(1<<(MySqlParserREPLICATION_APPLIER-622))|(1<<(MySqlParserREPLICATION_SLAVE_ADMIN-622))|(1<<(MySqlParserRESOURCE_GROUP_ADMIN-622))|(1<<(MySqlParserRESOURCE_GROUP_USER-622))|(1<<(MySqlParserROLE_ADMIN-622))|(1<<(MySqlParserSESSION_VARIABLES_ADMIN-622))|(1<<(MySqlParserSET_USER_ID-622))|(1<<(MySqlParserSHOW_ROUTINE-622))|(1<<(MySqlParserSYSTEM_VARIABLES_ADMIN-622))|(1<<(MySqlParserTABLE_ENCRYPTION_ADMIN-622))|(1<<(MySqlParserVERSION_TOKEN_ADMIN-622))|(1<<(MySqlParserXA_RECOVER_ADMIN-622)))) != 0) || _la == MySqlParserMEMORY || _la == MySqlParserCATALOG_NAME || _la == MySqlParserSCHEMA_NAME) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IFunctionNameBaseContext is an interface to support dynamic dispatch.
type IFunctionNameBaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctionNameBaseContext differentiates from other interfaces.
	IsFunctionNameBaseContext()
}

type FunctionNameBaseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionNameBaseContext() *FunctionNameBaseContext {
	var p = new(FunctionNameBaseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = MySqlParserRULE_functionNameBase
	return p
}

func (*FunctionNameBaseContext) IsFunctionNameBaseContext() {}

func NewFunctionNameBaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionNameBaseContext {
	var p = new(FunctionNameBaseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySqlParserRULE_functionNameBase

	return p
}

func (s *FunctionNameBaseContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionNameBaseContext) ABS() antlr.TerminalNode {
	return s.GetToken(MySqlParserABS, 0)
}

func (s *FunctionNameBaseContext) ACOS() antlr.TerminalNode {
	return s.GetToken(MySqlParserACOS, 0)
}

func (s *FunctionNameBaseContext) ADDDATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserADDDATE, 0)
}

func (s *FunctionNameBaseContext) ADDTIME() antlr.TerminalNode {
	return s.GetToken(MySqlParserADDTIME, 0)
}

func (s *FunctionNameBaseContext) AES_DECRYPT() antlr.TerminalNode {
	return s.GetToken(MySqlParserAES_DECRYPT, 0)
}

func (s *FunctionNameBaseContext) AES_ENCRYPT() antlr.TerminalNode {
	return s.GetToken(MySqlParserAES_ENCRYPT, 0)
}

func (s *FunctionNameBaseContext) AREA() antlr.TerminalNode {
	return s.GetToken(MySqlParserAREA, 0)
}

func (s *FunctionNameBaseContext) ASBINARY() antlr.TerminalNode {
	return s.GetToken(MySqlParserASBINARY, 0)
}

func (s *FunctionNameBaseContext) ASIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserASIN, 0)
}

func (s *FunctionNameBaseContext) ASTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserASTEXT, 0)
}

func (s *FunctionNameBaseContext) ASWKB() antlr.TerminalNode {
	return s.GetToken(MySqlParserASWKB, 0)
}

func (s *FunctionNameBaseContext) ASWKT() antlr.TerminalNode {
	return s.GetToken(MySqlParserASWKT, 0)
}

func (s *FunctionNameBaseContext) ASYMMETRIC_DECRYPT() antlr.TerminalNode {
	return s.GetToken(MySqlParserASYMMETRIC_DECRYPT, 0)
}

func (s *FunctionNameBaseContext) ASYMMETRIC_DERIVE() antlr.TerminalNode {
	return s.GetToken(MySqlParserASYMMETRIC_DERIVE, 0)
}

func (s *FunctionNameBaseContext) ASYMMETRIC_ENCRYPT() antlr.TerminalNode {
	return s.GetToken(MySqlParserASYMMETRIC_ENCRYPT, 0)
}

func (s *FunctionNameBaseContext) ASYMMETRIC_SIGN() antlr.TerminalNode {
	return s.GetToken(MySqlParserASYMMETRIC_SIGN, 0)
}

func (s *FunctionNameBaseContext) ASYMMETRIC_VERIFY() antlr.TerminalNode {
	return s.GetToken(MySqlParserASYMMETRIC_VERIFY, 0)
}

func (s *FunctionNameBaseContext) ATAN() antlr.TerminalNode {
	return s.GetToken(MySqlParserATAN, 0)
}

func (s *FunctionNameBaseContext) ATAN2() antlr.TerminalNode {
	return s.GetToken(MySqlParserATAN2, 0)
}

func (s *FunctionNameBaseContext) BENCHMARK() antlr.TerminalNode {
	return s.GetToken(MySqlParserBENCHMARK, 0)
}

func (s *FunctionNameBaseContext) BIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserBIN, 0)
}

func (s *FunctionNameBaseContext) BIT_COUNT() antlr.TerminalNode {
	return s.GetToken(MySqlParserBIT_COUNT, 0)
}

func (s *FunctionNameBaseContext) BIT_LENGTH() antlr.TerminalNode {
	return s.GetToken(MySqlParserBIT_LENGTH, 0)
}

func (s *FunctionNameBaseContext) BUFFER() antlr.TerminalNode {
	return s.GetToken(MySqlParserBUFFER, 0)
}

func (s *FunctionNameBaseContext) CEIL() antlr.TerminalNode {
	return s.GetToken(MySqlParserCEIL, 0)
}

func (s *FunctionNameBaseContext) CEILING() antlr.TerminalNode {
	return s.GetToken(MySqlParserCEILING, 0)
}

func (s *FunctionNameBaseContext) CENTROID() antlr.TerminalNode {
	return s.GetToken(MySqlParserCENTROID, 0)
}

func (s *FunctionNameBaseContext) CHARACTER_LENGTH() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHARACTER_LENGTH, 0)
}

func (s *FunctionNameBaseContext) CHARSET() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHARSET, 0)
}

func (s *FunctionNameBaseContext) CHAR_LENGTH() antlr.TerminalNode {
	return s.GetToken(MySqlParserCHAR_LENGTH, 0)
}

func (s *FunctionNameBaseContext) COERCIBILITY() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOERCIBILITY, 0)
}

func (s *FunctionNameBaseContext) COLLATION() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOLLATION, 0)
}

func (s *FunctionNameBaseContext) COMPRESS() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOMPRESS, 0)
}

func (s *FunctionNameBaseContext) CONCAT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONCAT, 0)
}

func (s *FunctionNameBaseContext) CONCAT_WS() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONCAT_WS, 0)
}

func (s *FunctionNameBaseContext) CONNECTION_ID() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONNECTION_ID, 0)
}

func (s *FunctionNameBaseContext) CONV() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONV, 0)
}

func (s *FunctionNameBaseContext) CONVERT_TZ() antlr.TerminalNode {
	return s.GetToken(MySqlParserCONVERT_TZ, 0)
}

func (s *FunctionNameBaseContext) COS() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOS, 0)
}

func (s *FunctionNameBaseContext) COT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOT, 0)
}

func (s *FunctionNameBaseContext) COUNT() antlr.TerminalNode {
	return s.GetToken(MySqlParserCOUNT, 0)
}

func (s *FunctionNameBaseContext) CRC32() antlr.TerminalNode {
	return s.GetToken(MySqlParserCRC32, 0)
}

func (s *FunctionNameBaseContext) CREATE_ASYMMETRIC_PRIV_KEY() antlr.TerminalNode {
	return s.GetToken(MySqlParserCREATE_ASYMMETRIC_PRIV_KEY, 0)
}

func (s *FunctionNameBaseContext) CREATE_ASYMMETRIC_PUB_KEY() antlr.TerminalNode {
	return s.GetToken(MySqlParserCREATE_ASYMMETRIC_PUB_KEY, 0)
}

func (s *FunctionNameBaseContext) CREATE_DH_PARAMETERS() antlr.TerminalNode {
	return s.GetToken(MySqlParserCREATE_DH_PARAMETERS, 0)
}

func (s *FunctionNameBaseContext) CREATE_DIGEST() antlr.TerminalNode {
	return s.GetToken(MySqlParserCREATE_DIGEST, 0)
}

func (s *FunctionNameBaseContext) CROSSES() antlr.TerminalNode {
	return s.GetToken(MySqlParserCROSSES, 0)
}

func (s *FunctionNameBaseContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATABASE, 0)
}

func (s *FunctionNameBaseContext) DATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATE, 0)
}

func (s *FunctionNameBaseContext) DATEDIFF() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATEDIFF, 0)
}

func (s *FunctionNameBaseContext) DATE_FORMAT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDATE_FORMAT, 0)
}

func (s *FunctionNameBaseContext) DAY() antlr.TerminalNode {
	return s.GetToken(MySqlParserDAY, 0)
}

func (s *FunctionNameBaseContext) DAYNAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserDAYNAME, 0)
}

func (s *FunctionNameBaseContext) DAYOFMONTH() antlr.TerminalNode {
	return s.GetToken(MySqlParserDAYOFMONTH, 0)
}

func (s *FunctionNameBaseContext) DAYOFWEEK() antlr.TerminalNode {
	return s.GetToken(MySqlParserDAYOFWEEK, 0)
}

func (s *FunctionNameBaseContext) DAYOFYEAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserDAYOFYEAR, 0)
}

func (s *FunctionNameBaseContext) DECODE() antlr.TerminalNode {
	return s.GetToken(MySqlParserDECODE, 0)
}

func (s *FunctionNameBaseContext) DEGREES() antlr.TerminalNode {
	return s.GetToken(MySqlParserDEGREES, 0)
}

func (s *FunctionNameBaseContext) DES_DECRYPT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDES_DECRYPT, 0)
}

func (s *FunctionNameBaseContext) DES_ENCRYPT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDES_ENCRYPT, 0)
}

func (s *FunctionNameBaseContext) DIMENSION() antlr.TerminalNode {
	return s.GetToken(MySqlParserDIMENSION, 0)
}

func (s *FunctionNameBaseContext) DISJOINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserDISJOINT, 0)
}

func (s *FunctionNameBaseContext) ELT() antlr.TerminalNode {
	return s.GetToken(MySqlParserELT, 0)
}

func (s *FunctionNameBaseContext) ENCODE() antlr.TerminalNode {
	return s.GetToken(MySqlParserENCODE, 0)
}

func (s *FunctionNameBaseContext) ENCRYPT() antlr.TerminalNode {
	return s.GetToken(MySqlParserENCRYPT, 0)
}

func (s *FunctionNameBaseContext) ENDPOINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserENDPOINT, 0)
}

func (s *FunctionNameBaseContext) ENVELOPE() antlr.TerminalNode {
	return s.GetToken(MySqlParserENVELOPE, 0)
}

func (s *FunctionNameBaseContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(MySqlParserEQUALS, 0)
}

func (s *FunctionNameBaseContext) EXP() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXP, 0)
}

func (s *FunctionNameBaseContext) EXPORT_SET() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXPORT_SET, 0)
}

func (s *FunctionNameBaseContext) EXTERIORRING() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXTERIORRING, 0)
}

func (s *FunctionNameBaseContext) EXTRACTVALUE() antlr.TerminalNode {
	return s.GetToken(MySqlParserEXTRACTVALUE, 0)
}

func (s *FunctionNameBaseContext) FIELD() antlr.TerminalNode {
	return s.GetToken(MySqlParserFIELD, 0)
}

func (s *FunctionNameBaseContext) FIND_IN_SET() antlr.TerminalNode {
	return s.GetToken(MySqlParserFIND_IN_SET, 0)
}

func (s *FunctionNameBaseContext) FLOOR() antlr.TerminalNode {
	return s.GetToken(MySqlParserFLOOR, 0)
}

func (s *FunctionNameBaseContext) FORMAT() antlr.TerminalNode {
	return s.GetToken(MySqlParserFORMAT, 0)
}

func (s *FunctionNameBaseContext) FOUND_ROWS() antlr.TerminalNode {
	return s.GetToken(MySqlParserFOUND_ROWS, 0)
}

func (s *FunctionNameBaseContext) FROM_BASE64() antlr.TerminalNode {
	return s.GetToken(MySqlParserFROM_BASE64, 0)
}

func (s *FunctionNameBaseContext) FROM_DAYS() antlr.TerminalNode {
	return s.GetToken(MySqlParserFROM_DAYS, 0)
}

func (s *FunctionNameBaseContext) FROM_UNIXTIME() antlr.TerminalNode {
	return s.GetToken(MySqlParserFROM_UNIXTIME, 0)
}

func (s *FunctionNameBaseContext) GEOMCOLLFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserGEOMCOLLFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) GEOMCOLLFROMWKB() antlr.TerminalNode {
	return s.GetToken(MySqlParserGEOMCOLLFROMWKB, 0)
}

func (s *FunctionNameBaseContext) GEOMETRYCOLLECTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserGEOMETRYCOLLECTION, 0)
}

func (s *FunctionNameBaseContext) GEOMETRYCOLLECTIONFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserGEOMETRYCOLLECTIONFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) GEOMETRYCOLLECTIONFROMWKB() antlr.TerminalNode {
	return s.GetToken(MySqlParserGEOMETRYCOLLECTIONFROMWKB, 0)
}

func (s *FunctionNameBaseContext) GEOMETRYFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserGEOMETRYFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) GEOMETRYFROMWKB() antlr.TerminalNode {
	return s.GetToken(MySqlParserGEOMETRYFROMWKB, 0)
}

func (s *FunctionNameBaseContext) GEOMETRYN() antlr.TerminalNode {
	return s.GetToken(MySqlParserGEOMETRYN, 0)
}

func (s *FunctionNameBaseContext) GEOMETRYTYPE() antlr.TerminalNode {
	return s.GetToken(MySqlParserGEOMETRYTYPE, 0)
}

func (s *FunctionNameBaseContext) GEOMFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserGEOMFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) GEOMFROMWKB() antlr.TerminalNode {
	return s.GetToken(MySqlParserGEOMFROMWKB, 0)
}

func (s *FunctionNameBaseContext) GET_FORMAT() antlr.TerminalNode {
	return s.GetToken(MySqlParserGET_FORMAT, 0)
}

func (s *FunctionNameBaseContext) GET_LOCK() antlr.TerminalNode {
	return s.GetToken(MySqlParserGET_LOCK, 0)
}

func (s *FunctionNameBaseContext) GLENGTH() antlr.TerminalNode {
	return s.GetToken(MySqlParserGLENGTH, 0)
}

func (s *FunctionNameBaseContext) GREATEST() antlr.TerminalNode {
	return s.GetToken(MySqlParserGREATEST, 0)
}

func (s *FunctionNameBaseContext) GTID_SUBSET() antlr.TerminalNode {
	return s.GetToken(MySqlParserGTID_SUBSET, 0)
}

func (s *FunctionNameBaseContext) GTID_SUBTRACT() antlr.TerminalNode {
	return s.GetToken(MySqlParserGTID_SUBTRACT, 0)
}

func (s *FunctionNameBaseContext) HEX() antlr.TerminalNode {
	return s.GetToken(MySqlParserHEX, 0)
}

func (s *FunctionNameBaseContext) HOUR() antlr.TerminalNode {
	return s.GetToken(MySqlParserHOUR, 0)
}

func (s *FunctionNameBaseContext) IFNULL() antlr.TerminalNode {
	return s.GetToken(MySqlParserIFNULL, 0)
}

func (s *FunctionNameBaseContext) INET6_ATON() antlr.TerminalNode {
	return s.GetToken(MySqlParserINET6_ATON, 0)
}

func (s *FunctionNameBaseContext) INET6_NTOA() antlr.TerminalNode {
	return s.GetToken(MySqlParserINET6_NTOA, 0)
}

func (s *FunctionNameBaseContext) INET_ATON() antlr.TerminalNode {
	return s.GetToken(MySqlParserINET_ATON, 0)
}

func (s *FunctionNameBaseContext) INET_NTOA() antlr.TerminalNode {
	return s.GetToken(MySqlParserINET_NTOA, 0)
}

func (s *FunctionNameBaseContext) INSTR() antlr.TerminalNode {
	return s.GetToken(MySqlParserINSTR, 0)
}

func (s *FunctionNameBaseContext) INTERIORRINGN() antlr.TerminalNode {
	return s.GetToken(MySqlParserINTERIORRINGN, 0)
}

func (s *FunctionNameBaseContext) INTERSECTS() antlr.TerminalNode {
	return s.GetToken(MySqlParserINTERSECTS, 0)
}

func (s *FunctionNameBaseContext) INVISIBLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserINVISIBLE, 0)
}

func (s *FunctionNameBaseContext) ISCLOSED() antlr.TerminalNode {
	return s.GetToken(MySqlParserISCLOSED, 0)
}

func (s *FunctionNameBaseContext) ISEMPTY() antlr.TerminalNode {
	return s.GetToken(MySqlParserISEMPTY, 0)
}

func (s *FunctionNameBaseContext) ISNULL() antlr.TerminalNode {
	return s.GetToken(MySqlParserISNULL, 0)
}

func (s *FunctionNameBaseContext) ISSIMPLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserISSIMPLE, 0)
}

func (s *FunctionNameBaseContext) IS_FREE_LOCK() antlr.TerminalNode {
	return s.GetToken(MySqlParserIS_FREE_LOCK, 0)
}

func (s *FunctionNameBaseContext) IS_IPV4() antlr.TerminalNode {
	return s.GetToken(MySqlParserIS_IPV4, 0)
}

func (s *FunctionNameBaseContext) IS_IPV4_COMPAT() antlr.TerminalNode {
	return s.GetToken(MySqlParserIS_IPV4_COMPAT, 0)
}

func (s *FunctionNameBaseContext) IS_IPV4_MAPPED() antlr.TerminalNode {
	return s.GetToken(MySqlParserIS_IPV4_MAPPED, 0)
}

func (s *FunctionNameBaseContext) IS_IPV6() antlr.TerminalNode {
	return s.GetToken(MySqlParserIS_IPV6, 0)
}

func (s *FunctionNameBaseContext) IS_USED_LOCK() antlr.TerminalNode {
	return s.GetToken(MySqlParserIS_USED_LOCK, 0)
}

func (s *FunctionNameBaseContext) LAST_INSERT_ID() antlr.TerminalNode {
	return s.GetToken(MySqlParserLAST_INSERT_ID, 0)
}

func (s *FunctionNameBaseContext) LCASE() antlr.TerminalNode {
	return s.GetToken(MySqlParserLCASE, 0)
}

func (s *FunctionNameBaseContext) LEAST() antlr.TerminalNode {
	return s.GetToken(MySqlParserLEAST, 0)
}

func (s *FunctionNameBaseContext) LEFT() antlr.TerminalNode {
	return s.GetToken(MySqlParserLEFT, 0)
}

func (s *FunctionNameBaseContext) LENGTH() antlr.TerminalNode {
	return s.GetToken(MySqlParserLENGTH, 0)
}

func (s *FunctionNameBaseContext) LINEFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserLINEFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) LINEFROMWKB() antlr.TerminalNode {
	return s.GetToken(MySqlParserLINEFROMWKB, 0)
}

func (s *FunctionNameBaseContext) LINESTRING() antlr.TerminalNode {
	return s.GetToken(MySqlParserLINESTRING, 0)
}

func (s *FunctionNameBaseContext) LINESTRINGFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserLINESTRINGFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) LINESTRINGFROMWKB() antlr.TerminalNode {
	return s.GetToken(MySqlParserLINESTRINGFROMWKB, 0)
}

func (s *FunctionNameBaseContext) LN() antlr.TerminalNode {
	return s.GetToken(MySqlParserLN, 0)
}

func (s *FunctionNameBaseContext) LOAD_FILE() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOAD_FILE, 0)
}

func (s *FunctionNameBaseContext) LOCATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOCATE, 0)
}

func (s *FunctionNameBaseContext) LOG() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOG, 0)
}

func (s *FunctionNameBaseContext) LOG10() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOG10, 0)
}

func (s *FunctionNameBaseContext) LOG2() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOG2, 0)
}

func (s *FunctionNameBaseContext) LOWER() antlr.TerminalNode {
	return s.GetToken(MySqlParserLOWER, 0)
}

func (s *FunctionNameBaseContext) LPAD() antlr.TerminalNode {
	return s.GetToken(MySqlParserLPAD, 0)
}

func (s *FunctionNameBaseContext) LTRIM() antlr.TerminalNode {
	return s.GetToken(MySqlParserLTRIM, 0)
}

func (s *FunctionNameBaseContext) MAKEDATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserMAKEDATE, 0)
}

func (s *FunctionNameBaseContext) MAKETIME() antlr.TerminalNode {
	return s.GetToken(MySqlParserMAKETIME, 0)
}

func (s *FunctionNameBaseContext) MAKE_SET() antlr.TerminalNode {
	return s.GetToken(MySqlParserMAKE_SET, 0)
}

func (s *FunctionNameBaseContext) MASTER_POS_WAIT() antlr.TerminalNode {
	return s.GetToken(MySqlParserMASTER_POS_WAIT, 0)
}

func (s *FunctionNameBaseContext) MBRCONTAINS() antlr.TerminalNode {
	return s.GetToken(MySqlParserMBRCONTAINS, 0)
}

func (s *FunctionNameBaseContext) MBRDISJOINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserMBRDISJOINT, 0)
}

func (s *FunctionNameBaseContext) MBREQUAL() antlr.TerminalNode {
	return s.GetToken(MySqlParserMBREQUAL, 0)
}

func (s *FunctionNameBaseContext) MBRINTERSECTS() antlr.TerminalNode {
	return s.GetToken(MySqlParserMBRINTERSECTS, 0)
}

func (s *FunctionNameBaseContext) MBROVERLAPS() antlr.TerminalNode {
	return s.GetToken(MySqlParserMBROVERLAPS, 0)
}

func (s *FunctionNameBaseContext) MBRTOUCHES() antlr.TerminalNode {
	return s.GetToken(MySqlParserMBRTOUCHES, 0)
}

func (s *FunctionNameBaseContext) MBRWITHIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserMBRWITHIN, 0)
}

func (s *FunctionNameBaseContext) MD5() antlr.TerminalNode {
	return s.GetToken(MySqlParserMD5, 0)
}

func (s *FunctionNameBaseContext) MICROSECOND() antlr.TerminalNode {
	return s.GetToken(MySqlParserMICROSECOND, 0)
}

func (s *FunctionNameBaseContext) MINUTE() antlr.TerminalNode {
	return s.GetToken(MySqlParserMINUTE, 0)
}

func (s *FunctionNameBaseContext) MLINEFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserMLINEFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) MLINEFROMWKB() antlr.TerminalNode {
	return s.GetToken(MySqlParserMLINEFROMWKB, 0)
}

func (s *FunctionNameBaseContext) MONTH() antlr.TerminalNode {
	return s.GetToken(MySqlParserMONTH, 0)
}

func (s *FunctionNameBaseContext) MONTHNAME() antlr.TerminalNode {
	return s.GetToken(MySqlParserMONTHNAME, 0)
}

func (s *FunctionNameBaseContext) MPOINTFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserMPOINTFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) MPOINTFROMWKB() antlr.TerminalNode {
	return s.GetToken(MySqlParserMPOINTFROMWKB, 0)
}

func (s *FunctionNameBaseContext) MPOLYFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserMPOLYFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) MPOLYFROMWKB() antlr.TerminalNode {
	return s.GetToken(MySqlParserMPOLYFROMWKB, 0)
}

func (s *FunctionNameBaseContext) MULTILINESTRING() antlr.TerminalNode {
	return s.GetToken(MySqlParserMULTILINESTRING, 0)
}

func (s *FunctionNameBaseContext) MULTILINESTRINGFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserMULTILINESTRINGFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) MULTILINESTRINGFROMWKB() antlr.TerminalNode {
	return s.GetToken(MySqlParserMULTILINESTRINGFROMWKB, 0)
}

func (s *FunctionNameBaseContext) MULTIPOINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserMULTIPOINT, 0)
}

func (s *FunctionNameBaseContext) MULTIPOINTFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserMULTIPOINTFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) MULTIPOINTFROMWKB() antlr.TerminalNode {
	return s.GetToken(MySqlParserMULTIPOINTFROMWKB, 0)
}

func (s *FunctionNameBaseContext) MULTIPOLYGON() antlr.TerminalNode {
	return s.GetToken(MySqlParserMULTIPOLYGON, 0)
}

func (s *FunctionNameBaseContext) MULTIPOLYGONFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserMULTIPOLYGONFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) MULTIPOLYGONFROMWKB() antlr.TerminalNode {
	return s.GetToken(MySqlParserMULTIPOLYGONFROMWKB, 0)
}

func (s *FunctionNameBaseContext) NAME_CONST() antlr.TerminalNode {
	return s.GetToken(MySqlParserNAME_CONST, 0)
}

func (s *FunctionNameBaseContext) NULLIF() antlr.TerminalNode {
	return s.GetToken(MySqlParserNULLIF, 0)
}

func (s *FunctionNameBaseContext) NUMGEOMETRIES() antlr.TerminalNode {
	return s.GetToken(MySqlParserNUMGEOMETRIES, 0)
}

func (s *FunctionNameBaseContext) NUMINTERIORRINGS() antlr.TerminalNode {
	return s.GetToken(MySqlParserNUMINTERIORRINGS, 0)
}

func (s *FunctionNameBaseContext) NUMPOINTS() antlr.TerminalNode {
	return s.GetToken(MySqlParserNUMPOINTS, 0)
}

func (s *FunctionNameBaseContext) OCT() antlr.TerminalNode {
	return s.GetToken(MySqlParserOCT, 0)
}

func (s *FunctionNameBaseContext) OCTET_LENGTH() antlr.TerminalNode {
	return s.GetToken(MySqlParserOCTET_LENGTH, 0)
}

func (s *FunctionNameBaseContext) ORD() antlr.TerminalNode {
	return s.GetToken(MySqlParserORD, 0)
}

func (s *FunctionNameBaseContext) OVERLAPS() antlr.TerminalNode {
	return s.GetToken(MySqlParserOVERLAPS, 0)
}

func (s *FunctionNameBaseContext) PERIOD_ADD() antlr.TerminalNode {
	return s.GetToken(MySqlParserPERIOD_ADD, 0)
}

func (s *FunctionNameBaseContext) PERIOD_DIFF() antlr.TerminalNode {
	return s.GetToken(MySqlParserPERIOD_DIFF, 0)
}

func (s *FunctionNameBaseContext) PI() antlr.TerminalNode {
	return s.GetToken(MySqlParserPI, 0)
}

func (s *FunctionNameBaseContext) POINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserPOINT, 0)
}

func (s *FunctionNameBaseContext) POINTFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserPOINTFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) POINTFROMWKB() antlr.TerminalNode {
	return s.GetToken(MySqlParserPOINTFROMWKB, 0)
}

func (s *FunctionNameBaseContext) POINTN() antlr.TerminalNode {
	return s.GetToken(MySqlParserPOINTN, 0)
}

func (s *FunctionNameBaseContext) POLYFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserPOLYFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) POLYFROMWKB() antlr.TerminalNode {
	return s.GetToken(MySqlParserPOLYFROMWKB, 0)
}

func (s *FunctionNameBaseContext) POLYGON() antlr.TerminalNode {
	return s.GetToken(MySqlParserPOLYGON, 0)
}

func (s *FunctionNameBaseContext) POLYGONFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserPOLYGONFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) POLYGONFROMWKB() antlr.TerminalNode {
	return s.GetToken(MySqlParserPOLYGONFROMWKB, 0)
}

func (s *FunctionNameBaseContext) POSITION() antlr.TerminalNode {
	return s.GetToken(MySqlParserPOSITION, 0)
}

func (s *FunctionNameBaseContext) POW() antlr.TerminalNode {
	return s.GetToken(MySqlParserPOW, 0)
}

func (s *FunctionNameBaseContext) POWER() antlr.TerminalNode {
	return s.GetToken(MySqlParserPOWER, 0)
}

func (s *FunctionNameBaseContext) QUARTER() antlr.TerminalNode {
	return s.GetToken(MySqlParserQUARTER, 0)
}

func (s *FunctionNameBaseContext) QUOTE() antlr.TerminalNode {
	return s.GetToken(MySqlParserQUOTE, 0)
}

func (s *FunctionNameBaseContext) RADIANS() antlr.TerminalNode {
	return s.GetToken(MySqlParserRADIANS, 0)
}

func (s *FunctionNameBaseContext) RAND() antlr.TerminalNode {
	return s.GetToken(MySqlParserRAND, 0)
}

func (s *FunctionNameBaseContext) RANDOM_BYTES() antlr.TerminalNode {
	return s.GetToken(MySqlParserRANDOM_BYTES, 0)
}

func (s *FunctionNameBaseContext) RELEASE_LOCK() antlr.TerminalNode {
	return s.GetToken(MySqlParserRELEASE_LOCK, 0)
}

func (s *FunctionNameBaseContext) REVERSE() antlr.TerminalNode {
	return s.GetToken(MySqlParserREVERSE, 0)
}

func (s *FunctionNameBaseContext) RIGHT() antlr.TerminalNode {
	return s.GetToken(MySqlParserRIGHT, 0)
}

func (s *FunctionNameBaseContext) ROUND() antlr.TerminalNode {
	return s.GetToken(MySqlParserROUND, 0)
}

func (s *FunctionNameBaseContext) ROW_COUNT() antlr.TerminalNode {
	return s.GetToken(MySqlParserROW_COUNT, 0)
}

func (s *FunctionNameBaseContext) RPAD() antlr.TerminalNode {
	return s.GetToken(MySqlParserRPAD, 0)
}

func (s *FunctionNameBaseContext) RTRIM() antlr.TerminalNode {
	return s.GetToken(MySqlParserRTRIM, 0)
}

func (s *FunctionNameBaseContext) SECOND() antlr.TerminalNode {
	return s.GetToken(MySqlParserSECOND, 0)
}

func (s *FunctionNameBaseContext) SEC_TO_TIME() antlr.TerminalNode {
	return s.GetToken(MySqlParserSEC_TO_TIME, 0)
}

func (s *FunctionNameBaseContext) SESSION_USER() antlr.TerminalNode {
	return s.GetToken(MySqlParserSESSION_USER, 0)
}

func (s *FunctionNameBaseContext) SESSION_VARIABLES_ADMIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserSESSION_VARIABLES_ADMIN, 0)
}

func (s *FunctionNameBaseContext) SHA() antlr.TerminalNode {
	return s.GetToken(MySqlParserSHA, 0)
}

func (s *FunctionNameBaseContext) SHA1() antlr.TerminalNode {
	return s.GetToken(MySqlParserSHA1, 0)
}

func (s *FunctionNameBaseContext) SHA2() antlr.TerminalNode {
	return s.GetToken(MySqlParserSHA2, 0)
}

func (s *FunctionNameBaseContext) SIGN() antlr.TerminalNode {
	return s.GetToken(MySqlParserSIGN, 0)
}

func (s *FunctionNameBaseContext) SIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserSIN, 0)
}

func (s *FunctionNameBaseContext) SLEEP() antlr.TerminalNode {
	return s.GetToken(MySqlParserSLEEP, 0)
}

func (s *FunctionNameBaseContext) SOUNDEX() antlr.TerminalNode {
	return s.GetToken(MySqlParserSOUNDEX, 0)
}

func (s *FunctionNameBaseContext) SQL_THREAD_WAIT_AFTER_GTIDS() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQL_THREAD_WAIT_AFTER_GTIDS, 0)
}

func (s *FunctionNameBaseContext) SQRT() antlr.TerminalNode {
	return s.GetToken(MySqlParserSQRT, 0)
}

func (s *FunctionNameBaseContext) SRID() antlr.TerminalNode {
	return s.GetToken(MySqlParserSRID, 0)
}

func (s *FunctionNameBaseContext) STARTPOINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTARTPOINT, 0)
}

func (s *FunctionNameBaseContext) STRCMP() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTRCMP, 0)
}

func (s *FunctionNameBaseContext) STR_TO_DATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSTR_TO_DATE, 0)
}

func (s *FunctionNameBaseContext) ST_AREA() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_AREA, 0)
}

func (s *FunctionNameBaseContext) ST_ASBINARY() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_ASBINARY, 0)
}

func (s *FunctionNameBaseContext) ST_ASTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_ASTEXT, 0)
}

func (s *FunctionNameBaseContext) ST_ASWKB() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_ASWKB, 0)
}

func (s *FunctionNameBaseContext) ST_ASWKT() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_ASWKT, 0)
}

func (s *FunctionNameBaseContext) ST_BUFFER() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_BUFFER, 0)
}

func (s *FunctionNameBaseContext) ST_CENTROID() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_CENTROID, 0)
}

func (s *FunctionNameBaseContext) ST_CONTAINS() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_CONTAINS, 0)
}

func (s *FunctionNameBaseContext) ST_CROSSES() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_CROSSES, 0)
}

func (s *FunctionNameBaseContext) ST_DIFFERENCE() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_DIFFERENCE, 0)
}

func (s *FunctionNameBaseContext) ST_DIMENSION() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_DIMENSION, 0)
}

func (s *FunctionNameBaseContext) ST_DISJOINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_DISJOINT, 0)
}

func (s *FunctionNameBaseContext) ST_DISTANCE() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_DISTANCE, 0)
}

func (s *FunctionNameBaseContext) ST_ENDPOINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_ENDPOINT, 0)
}

func (s *FunctionNameBaseContext) ST_ENVELOPE() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_ENVELOPE, 0)
}

func (s *FunctionNameBaseContext) ST_EQUALS() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_EQUALS, 0)
}

func (s *FunctionNameBaseContext) ST_EXTERIORRING() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_EXTERIORRING, 0)
}

func (s *FunctionNameBaseContext) ST_GEOMCOLLFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_GEOMCOLLFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) ST_GEOMCOLLFROMTXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_GEOMCOLLFROMTXT, 0)
}

func (s *FunctionNameBaseContext) ST_GEOMCOLLFROMWKB() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_GEOMCOLLFROMWKB, 0)
}

func (s *FunctionNameBaseContext) ST_GEOMETRYCOLLECTIONFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_GEOMETRYCOLLECTIONFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) ST_GEOMETRYCOLLECTIONFROMWKB() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_GEOMETRYCOLLECTIONFROMWKB, 0)
}

func (s *FunctionNameBaseContext) ST_GEOMETRYFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_GEOMETRYFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) ST_GEOMETRYFROMWKB() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_GEOMETRYFROMWKB, 0)
}

func (s *FunctionNameBaseContext) ST_GEOMETRYN() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_GEOMETRYN, 0)
}

func (s *FunctionNameBaseContext) ST_GEOMETRYTYPE() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_GEOMETRYTYPE, 0)
}

func (s *FunctionNameBaseContext) ST_GEOMFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_GEOMFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) ST_GEOMFROMWKB() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_GEOMFROMWKB, 0)
}

func (s *FunctionNameBaseContext) ST_INTERIORRINGN() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_INTERIORRINGN, 0)
}

func (s *FunctionNameBaseContext) ST_INTERSECTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_INTERSECTION, 0)
}

func (s *FunctionNameBaseContext) ST_INTERSECTS() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_INTERSECTS, 0)
}

func (s *FunctionNameBaseContext) ST_ISCLOSED() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_ISCLOSED, 0)
}

func (s *FunctionNameBaseContext) ST_ISEMPTY() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_ISEMPTY, 0)
}

func (s *FunctionNameBaseContext) ST_ISSIMPLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_ISSIMPLE, 0)
}

func (s *FunctionNameBaseContext) ST_LINEFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_LINEFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) ST_LINEFROMWKB() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_LINEFROMWKB, 0)
}

func (s *FunctionNameBaseContext) ST_LINESTRINGFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_LINESTRINGFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) ST_LINESTRINGFROMWKB() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_LINESTRINGFROMWKB, 0)
}

func (s *FunctionNameBaseContext) ST_NUMGEOMETRIES() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_NUMGEOMETRIES, 0)
}

func (s *FunctionNameBaseContext) ST_NUMINTERIORRING() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_NUMINTERIORRING, 0)
}

func (s *FunctionNameBaseContext) ST_NUMINTERIORRINGS() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_NUMINTERIORRINGS, 0)
}

func (s *FunctionNameBaseContext) ST_NUMPOINTS() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_NUMPOINTS, 0)
}

func (s *FunctionNameBaseContext) ST_OVERLAPS() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_OVERLAPS, 0)
}

func (s *FunctionNameBaseContext) ST_POINTFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_POINTFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) ST_POINTFROMWKB() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_POINTFROMWKB, 0)
}

func (s *FunctionNameBaseContext) ST_POINTN() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_POINTN, 0)
}

func (s *FunctionNameBaseContext) ST_POLYFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_POLYFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) ST_POLYFROMWKB() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_POLYFROMWKB, 0)
}

func (s *FunctionNameBaseContext) ST_POLYGONFROMTEXT() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_POLYGONFROMTEXT, 0)
}

func (s *FunctionNameBaseContext) ST_POLYGONFROMWKB() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_POLYGONFROMWKB, 0)
}

func (s *FunctionNameBaseContext) ST_SRID() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_SRID, 0)
}

func (s *FunctionNameBaseContext) ST_STARTPOINT() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_STARTPOINT, 0)
}

func (s *FunctionNameBaseContext) ST_SYMDIFFERENCE() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_SYMDIFFERENCE, 0)
}

func (s *FunctionNameBaseContext) ST_TOUCHES() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_TOUCHES, 0)
}

func (s *FunctionNameBaseContext) ST_UNION() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_UNION, 0)
}

func (s *FunctionNameBaseContext) ST_WITHIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_WITHIN, 0)
}

func (s *FunctionNameBaseContext) ST_X() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_X, 0)
}

func (s *FunctionNameBaseContext) ST_Y() antlr.TerminalNode {
	return s.GetToken(MySqlParserST_Y, 0)
}

func (s *FunctionNameBaseContext) SUBDATE() antlr.TerminalNode {
	return s.GetToken(MySqlParserSUBDATE, 0)
}

func (s *FunctionNameBaseContext) SUBSTRING_INDEX() antlr.TerminalNode {
	return s.GetToken(MySqlParserSUBSTRING_INDEX, 0)
}

func (s *FunctionNameBaseContext) SUBTIME() antlr.TerminalNode {
	return s.GetToken(MySqlParserSUBTIME, 0)
}

func (s *FunctionNameBaseContext) SYSTEM_USER() antlr.TerminalNode {
	return s.GetToken(MySqlParserSYSTEM_USER, 0)
}

func (s *FunctionNameBaseContext) TAN() antlr.TerminalNode {
	return s.GetToken(MySqlParserTAN, 0)
}

func (s *FunctionNameBaseContext) TIME() antlr.TerminalNode {
	return s.GetToken(MySqlParserTIME, 0)
}

func (s *FunctionNameBaseContext) TIMEDIFF() antlr.TerminalNode {
	return s.GetToken(MySqlParserTIMEDIFF, 0)
}

func (s *FunctionNameBaseContext) TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(MySqlParserTIMESTAMP, 0)
}

func (s *FunctionNameBaseContext) TIMESTAMPADD() antlr.TerminalNode {
	return s.GetToken(MySqlParserTIMESTAMPADD, 0)
}

func (s *FunctionNameBaseContext) TIMESTAMPDIFF() antlr.TerminalNode {
	return s.GetToken(MySqlParserTIMESTAMPDIFF, 0)
}

func (s *FunctionNameBaseContext) TIME_FORMAT() antlr.TerminalNode {
	return s.GetToken(MySqlParserTIME_FORMAT, 0)
}

func (s *FunctionNameBaseContext) TIME_TO_SEC() antlr.TerminalNode {
	return s.GetToken(MySqlParserTIME_TO_SEC, 0)
}

func (s *FunctionNameBaseContext) TOUCHES() antlr.TerminalNode {
	return s.GetToken(MySqlParserTOUCHES, 0)
}

func (s *FunctionNameBaseContext) TO_BASE64() antlr.TerminalNode {
	return s.GetToken(MySqlParserTO_BASE64, 0)
}

func (s *FunctionNameBaseContext) TO_DAYS() antlr.TerminalNode {
	return s.GetToken(MySqlParserTO_DAYS, 0)
}

func (s *FunctionNameBaseContext) TO_SECONDS() antlr.TerminalNode {
	return s.GetToken(MySqlParserTO_SECONDS, 0)
}

func (s *FunctionNameBaseContext) UCASE() antlr.TerminalNode {
	return s.GetToken(MySqlParserUCASE, 0)
}

func (s *FunctionNameBaseContext) UNCOMPRESS() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNCOMPRESS, 0)
}

func (s *FunctionNameBaseContext) UNCOMPRESSED_LENGTH() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNCOMPRESSED_LENGTH, 0)
}

func (s *FunctionNameBaseContext) UNHEX() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNHEX, 0)
}

func (s *FunctionNameBaseContext) UNIX_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(MySqlParserUNIX_TIMESTAMP, 0)
}

func (s *FunctionNameBaseContext) UPDATEXML() antlr.TerminalNode {
	return s.GetToken(MySqlParserUPDATEXML, 0)
}

func (s *FunctionNameBaseContext) UPPER() antlr.TerminalNode {
	return s.GetToken(MySqlParserUPPER, 0)
}

func (s *FunctionNameBaseContext) UUID() antlr.TerminalNode {
	return s.GetToken(MySqlParserUUID, 0)
}

func (s *FunctionNameBaseContext) UUID_SHORT() antlr.TerminalNode {
	return s.GetToken(MySqlParserUUID_SHORT, 0)
}

func (s *FunctionNameBaseContext) VALIDATE_PASSWORD_STRENGTH() antlr.TerminalNode {
	return s.GetToken(MySqlParserVALIDATE_PASSWORD_STRENGTH, 0)
}

func (s *FunctionNameBaseContext) VERSION() antlr.TerminalNode {
	return s.GetToken(MySqlParserVERSION, 0)
}

func (s *FunctionNameBaseContext) VISIBLE() antlr.TerminalNode {
	return s.GetToken(MySqlParserVISIBLE, 0)
}

func (s *FunctionNameBaseContext) WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS() antlr.TerminalNode {
	return s.GetToken(MySqlParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS, 0)
}

func (s *FunctionNameBaseContext) WEEK() antlr.TerminalNode {
	return s.GetToken(MySqlParserWEEK, 0)
}

func (s *FunctionNameBaseContext) WEEKDAY() antlr.TerminalNode {
	return s.GetToken(MySqlParserWEEKDAY, 0)
}

func (s *FunctionNameBaseContext) WEEKOFYEAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserWEEKOFYEAR, 0)
}

func (s *FunctionNameBaseContext) WEIGHT_STRING() antlr.TerminalNode {
	return s.GetToken(MySqlParserWEIGHT_STRING, 0)
}

func (s *FunctionNameBaseContext) WITHIN() antlr.TerminalNode {
	return s.GetToken(MySqlParserWITHIN, 0)
}

func (s *FunctionNameBaseContext) YEAR() antlr.TerminalNode {
	return s.GetToken(MySqlParserYEAR, 0)
}

func (s *FunctionNameBaseContext) YEARWEEK() antlr.TerminalNode {
	return s.GetToken(MySqlParserYEARWEEK, 0)
}

func (s *FunctionNameBaseContext) Y_FUNCTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserY_FUNCTION, 0)
}

func (s *FunctionNameBaseContext) X_FUNCTION() antlr.TerminalNode {
	return s.GetToken(MySqlParserX_FUNCTION, 0)
}

func (s *FunctionNameBaseContext) JSON_VALID() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON_VALID, 0)
}

func (s *FunctionNameBaseContext) JSON_SCHEMA_VALID() antlr.TerminalNode {
	return s.GetToken(MySqlParserJSON_SCHEMA_VALID, 0)
}

func (s *FunctionNameBaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionNameBaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionNameBaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.EnterFunctionNameBase(s)
	}
}

func (s *FunctionNameBaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySqlParserListener); ok {
		listenerT.ExitFunctionNameBase(s)
	}
}

func (s *FunctionNameBaseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySqlParserVisitor:
		return t.VisitFunctionNameBase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySqlParser) FunctionNameBase() (localctx IFunctionNameBaseContext) {
	localctx = NewFunctionNameBaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, MySqlParserRULE_functionNameBase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1475)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySqlParserDATABASE || _la == MySqlParserLEFT || _la == MySqlParserRIGHT || (((_la-199)&-(0x1f+1)) == 0 && ((1<<uint((_la-199)))&((1<<(MySqlParserDATE-199))|(1<<(MySqlParserTIME-199))|(1<<(MySqlParserTIMESTAMP-199))|(1<<(MySqlParserYEAR-199)))) != 0) || (((_la-233)&-(0x1f+1)) == 0 && ((1<<uint((_la-233)))&((1<<(MySqlParserJSON_VALID-233))|(1<<(MySqlParserJSON_SCHEMA_VALID-233))|(1<<(MySqlParserCOUNT-233))|(1<<(MySqlParserPOSITION-233)))) != 0) || _la == MySqlParserINVISIBLE || (((_la-582)&-(0x1f+1)) == 0 && ((1<<uint((_la-582)))&((1<<(MySqlParserVISIBLE-582))|(1<<(MySqlParserQUARTER-582))|(1<<(MySqlParserMONTH-582))|(1<<(MySqlParserDAY-582))|(1<<(MySqlParserHOUR-582))|(1<<(MySqlParserMINUTE-582))|(1<<(MySqlParserWEEK-582))|(1<<(MySqlParserSECOND-582))|(1<<(MySqlParserMICROSECOND-582)))) != 0) || _la == MySqlParserSESSION_VARIABLES_ADMIN || (((_la-695)&-(0x1f+1)) == 0 && ((1<<uint((_la-695)))&((1<<(MySqlParserGEOMETRYCOLLECTION-695))|(1<<(MySqlParserLINESTRING-695))|(1<<(MySqlParserMULTILINESTRING-695))|(1<<(MySqlParserMULTIPOINT-695))|(1<<(MySqlParserMULTIPOLYGON-695))|(1<<(MySqlParserPOINT-695))|(1<<(MySqlParserPOLYGON-695))|(1<<(MySqlParserABS-695))|(1<<(MySqlParserACOS-695))|(1<<(MySqlParserADDDATE-695))|(1<<(MySqlParserADDTIME-695))|(1<<(MySqlParserAES_DECRYPT-695))|(1<<(MySqlParserAES_ENCRYPT-695))|(1<<(MySqlParserAREA-695))|(1<<(MySqlParserASBINARY-695))|(1<<(MySqlParserASIN-695))|(1<<(MySqlParserASTEXT-695))|(1<<(MySqlParserASWKB-695))|(1<<(MySqlParserASWKT-695))|(1<<(MySqlParserASYMMETRIC_DECRYPT-695))|(1<<(MySqlParserASYMMETRIC_DERIVE-695))|(1<<(MySqlParserASYMMETRIC_ENCRYPT-695))|(1<<(MySqlParserASYMMETRIC_SIGN-695))|(1<<(MySqlParserASYMMETRIC_VERIFY-695))|(1<<(MySqlParserATAN-695))|(1<<(MySqlParserATAN2-695))|(1<<(MySqlParserBENCHMARK-695))|(1<<(MySqlParserBIN-695))|(1<<(MySqlParserBIT_COUNT-695))|(1<<(MySqlParserBIT_LENGTH-695)))) != 0) || (((_la-727)&-(0x1f+1)) == 0 && ((1<<uint((_la-727)))&((1<<(MySqlParserBUFFER-727))|(1<<(MySqlParserCEIL-727))|(1<<(MySqlParserCEILING-727))|(1<<(MySqlParserCENTROID-727))|(1<<(MySqlParserCHARACTER_LENGTH-727))|(1<<(MySqlParserCHARSET-727))|(1<<(MySqlParserCHAR_LENGTH-727))|(1<<(MySqlParserCOERCIBILITY-727))|(1<<(MySqlParserCOLLATION-727))|(1<<(MySqlParserCOMPRESS-727))|(1<<(MySqlParserCONCAT-727))|(1<<(MySqlParserCONCAT_WS-727))|(1<<(MySqlParserCONNECTION_ID-727))|(1<<(MySqlParserCONV-727))|(1<<(MySqlParserCONVERT_TZ-727))|(1<<(MySqlParserCOS-727))|(1<<(MySqlParserCOT-727))|(1<<(MySqlParserCRC32-727))|(1<<(MySqlParserCREATE_ASYMMETRIC_PRIV_KEY-727))|(1<<(MySqlParserCREATE_ASYMMETRIC_PUB_KEY-727))|(1<<(MySqlParserCREATE_DH_PARAMETERS-727))|(1<<(MySqlParserCREATE_DIGEST-727))|(1<<(MySqlParserCROSSES-727))|(1<<(MySqlParserDATEDIFF-727))|(1<<(MySqlParserDATE_FORMAT-727))|(1<<(MySqlParserDAYNAME-727))|(1<<(MySqlParserDAYOFMONTH-727))|(1<<(MySqlParserDAYOFWEEK-727))|(1<<(MySqlParserDAYOFYEAR-727))|(1<<(MySqlParserDECODE-727))|(1<<(MySqlParserDEGREES-727)))) != 0) || (((_la-759)&-(0x1f+1)) == 0 && ((1<<uint((_la-759)))&((1<<(MySqlParserDES_DECRYPT-759))|(1<<(MySqlParserDES_ENCRYPT-759))|(1<<(MySqlParserDIMENSION-759))|(1<<(MySqlParserDISJOINT-759))|(1<<(MySqlParserELT-759))|(1<<(MySqlParserENCODE-759))|(1<<(MySqlParserENCRYPT-759))|(1<<(MySqlParserENDPOINT-759))|(1<<(MySqlParserENVELOPE-759))|(1<<(MySqlParserEQUALS-759))|(1<<(MySqlParserEXP-759))|(1<<(MySqlParserEXPORT_SET-759))|(1<<(MySqlParserEXTERIORRING-759))|(1<<(MySqlParserEXTRACTVALUE-759))|(1<<(MySqlParserFIELD-759))|(1<<(MySqlParserFIND_IN_SET-759))|(1<<(MySqlParserFLOOR-759))|(1<<(MySqlParserFORMAT-759))|(1<<(MySqlParserFOUND_ROWS-759))|(1<<(MySqlParserFROM_BASE64-759))|(1<<(MySqlParserFROM_DAYS-759))|(1<<(MySqlParserFROM_UNIXTIME-759))|(1<<(MySqlParserGEOMCOLLFROMTEXT-759))|(1<<(MySqlParserGEOMCOLLFROMWKB-759))|(1<<(MySqlParserGEOMETRYCOLLECTIONFROMTEXT-759))|(1<<(MySqlParserGEOMETRYCOLLECTIONFROMWKB-759))|(1<<(MySqlParserGEOMETRYFROMTEXT-759))|(1<<(MySqlParserGEOMETRYFROMWKB-759))|(1<<(MySqlParserGEOMETRYN-759))|(1<<(MySqlParserGEOMETRYTYPE-759))|(1<<(MySqlParserGEOMFROMTEXT-759))|(1<<(MySqlParserGEOMFROMWKB-759)))) != 0) || (((_la-791)&-(0x1f+1)) == 0 && ((1<<uint((_la-791)))&((1<<(MySqlParserGET_FORMAT-791))|(1<<(MySqlParserGET_LOCK-791))|(1<<(MySqlParserGLENGTH-791))|(1<<(MySqlParserGREATEST-791))|(1<<(MySqlParserGTID_SUBSET-791))|(1<<(MySqlParserGTID_SUBTRACT-791))|(1<<(MySqlParserHEX-791))|(1<<(MySqlParserIFNULL-791))|(1<<(MySqlParserINET6_ATON-791))|(1<<(MySqlParserINET6_NTOA-791))|(1<<(MySqlParserINET_ATON-791))|(1<<(MySqlParserINET_NTOA-791))|(1<<(MySqlParserINSTR-791))|(1<<(MySqlParserINTERIORRINGN-791))|(1<<(MySqlParserINTERSECTS-791))|(1<<(MySqlParserISCLOSED-791))|(1<<(MySqlParserISEMPTY-791))|(1<<(MySqlParserISNULL-791))|(1<<(MySqlParserISSIMPLE-791))|(1<<(MySqlParserIS_FREE_LOCK-791))|(1<<(MySqlParserIS_IPV4-791))|(1<<(MySqlParserIS_IPV4_COMPAT-791))|(1<<(MySqlParserIS_IPV4_MAPPED-791))|(1<<(MySqlParserIS_IPV6-791))|(1<<(MySqlParserIS_USED_LOCK-791))|(1<<(MySqlParserLAST_INSERT_ID-791))|(1<<(MySqlParserLCASE-791))|(1<<(MySqlParserLEAST-791))|(1<<(MySqlParserLENGTH-791))|(1<<(MySqlParserLINEFROMTEXT-791))|(1<<(MySqlParserLINEFROMWKB-791))|(1<<(MySqlParserLINESTRINGFROMTEXT-791)))) != 0) || (((_la-823)&-(0x1f+1)) == 0 && ((1<<uint((_la-823)))&((1<<(MySqlParserLINESTRINGFROMWKB-823))|(1<<(MySqlParserLN-823))|(1<<(MySqlParserLOAD_FILE-823))|(1<<(MySqlParserLOCATE-823))|(1<<(MySqlParserLOG-823))|(1<<(MySqlParserLOG10-823))|(1<<(MySqlParserLOG2-823))|(1<<(MySqlParserLOWER-823))|(1<<(MySqlParserLPAD-823))|(1<<(MySqlParserLTRIM-823))|(1<<(MySqlParserMAKEDATE-823))|(1<<(MySqlParserMAKETIME-823))|(1<<(MySqlParserMAKE_SET-823))|(1<<(MySqlParserMASTER_POS_WAIT-823))|(1<<(MySqlParserMBRCONTAINS-823))|(1<<(MySqlParserMBRDISJOINT-823))|(1<<(MySqlParserMBREQUAL-823))|(1<<(MySqlParserMBRINTERSECTS-823))|(1<<(MySqlParserMBROVERLAPS-823))|(1<<(MySqlParserMBRTOUCHES-823))|(1<<(MySqlParserMBRWITHIN-823))|(1<<(MySqlParserMD5-823))|(1<<(MySqlParserMLINEFROMTEXT-823))|(1<<(MySqlParserMLINEFROMWKB-823))|(1<<(MySqlParserMONTHNAME-823))|(1<<(MySqlParserMPOINTFROMTEXT-823))|(1<<(MySqlParserMPOINTFROMWKB-823))|(1<<(MySqlParserMPOLYFROMTEXT-823))|(1<<(MySqlParserMPOLYFROMWKB-823))|(1<<(MySqlParserMULTILINESTRINGFROMTEXT-823))|(1<<(MySqlParserMULTILINESTRINGFROMWKB-823))|(1<<(MySqlParserMULTIPOINTFROMTEXT-823)))) != 0) || (((_la-855)&-(0x1f+1)) == 0 && ((1<<uint((_la-855)))&((1<<(MySqlParserMULTIPOINTFROMWKB-855))|(1<<(MySqlParserMULTIPOLYGONFROMTEXT-855))|(1<<(MySqlParserMULTIPOLYGONFROMWKB-855))|(1<<(MySqlParserNAME_CONST-855))|(1<<(MySqlParserNULLIF-855))|(1<<(MySqlParserNUMGEOMETRIES-855))|(1<<(MySqlParserNUMINTERIORRINGS-855))|(1<<(MySqlParserNUMPOINTS-855))|(1<<(MySqlParserOCT-855))|(1<<(MySqlParserOCTET_LENGTH-855))|(1<<(MySqlParserORD-855))|(1<<(MySqlParserOVERLAPS-855))|(1<<(MySqlParserPERIOD_ADD-855))|(1<<(MySqlParserPERIOD_DIFF-855))|(1<<(MySqlParserPI-855))|(1<<(MySqlParserPOINTFROMTEXT-855))|(1<<(MySqlParserPOINTFROMWKB-855))|(1<<(MySqlParserPOINTN-855))|(1<<(MySqlParserPOLYFROMTEXT-855))|(1<<(MySqlParserPOLYFROMWKB-855))|(1<<(MySqlParserPOLYGONFROMTEXT-855))|(1<<(MySqlParserPOLYGONFROMWKB-855))|(1<<(MySqlParserPOW-855))|(1<<(MySqlParserPOWER-855))|(1<<(MySqlParserQUOTE-855))|(1<<(MySqlParserRADIANS-855))|(1<<(MySqlParserRAND-855))|(1<<(MySqlParserRANDOM_BYTES-855))|(1<<(MySqlParserRELEASE_LOCK-855))|(1<<(MySqlParserREVERSE-855))|(1<<(MySqlParserROUND-855))|(1<<(MySqlParserROW_COUNT-855)))) != 0) || (((_la-887)&-(0x1f+1)) == 0 && ((1<<uint((_la-887)))&((1<<(MySqlParserRPAD-887))|(1<<(MySqlParserRTRIM-887))|(1<<(MySqlParserSEC_TO_TIME-887))|(1<<(MySqlParserSESSION_USER-887))|(1<<(MySqlParserSHA-887))|(1<<(MySqlParserSHA1-887))|(1<<(MySqlParserSHA2-887))|(1<<(MySqlParserSIGN-887))|(1<<(MySqlParserSIN-887))|(1<<(MySqlParserSLEEP-887))|(1<<(MySqlParserSOUNDEX-887))|(1<<(MySqlParserSQL_THREAD_WAIT_AFTER_GTIDS-887))|(1<<(MySqlParserSQRT-887))|(1<<(MySqlParserSRID-887))|(1<<(MySqlParserSTARTPOINT-887))|(1<<(MySqlParserSTRCMP-887))|(1<<(MySqlParserSTR_TO_DATE-887))|(1<<(MySqlParserST_AREA-887))|(1<<(MySqlParserST_ASBINARY-887))|(1<<(MySqlParserST_ASTEXT-887))|(1<<(MySqlParserST_ASWKB-887))|(1<<(MySqlParserST_ASWKT-887))|(1<<(MySqlParserST_BUFFER-887))|(1<<(MySqlParserST_CENTROID-887))|(1<<(MySqlParserST_CONTAINS-887))|(1<<(MySqlParserST_CROSSES-887))|(1<<(MySqlParserST_DIFFERENCE-887))|(1<<(MySqlParserST_DIMENSION-887))|(1<<(MySqlParserST_DISJOINT-887))|(1<<(MySqlParserST_DISTANCE-887))|(1<<(MySqlParserST_ENDPOINT-887)))) != 0) || (((_la-919)&-(0x1f+1)) == 0 && ((1<<uint((_la-919)))&((1<<(MySqlParserST_ENVELOPE-919))|(1<<(MySqlParserST_EQUALS-919))|(1<<(MySqlParserST_EXTERIORRING-919))|(1<<(MySqlParserST_GEOMCOLLFROMTEXT-919))|(1<<(MySqlParserST_GEOMCOLLFROMTXT-919))|(1<<(MySqlParserST_GEOMCOLLFROMWKB-919))|(1<<(MySqlParserST_GEOMETRYCOLLECTIONFROMTEXT-919))|(1<<(MySqlParserST_GEOMETRYCOLLECTIONFROMWKB-919))|(1<<(MySqlParserST_GEOMETRYFROMTEXT-919))|(1<<(MySqlParserST_GEOMETRYFROMWKB-919))|(1<<(MySqlParserST_GEOMETRYN-919))|(1<<(MySqlParserST_GEOMETRYTYPE-919))|(1<<(MySqlParserST_GEOMFROMTEXT-919))|(1<<(MySqlParserST_GEOMFROMWKB-919))|(1<<(MySqlParserST_INTERIORRINGN-919))|(1<<(MySqlParserST_INTERSECTION-919))|(1<<(MySqlParserST_INTERSECTS-919))|(1<<(MySqlParserST_ISCLOSED-919))|(1<<(MySqlParserST_ISEMPTY-919))|(1<<(MySqlParserST_ISSIMPLE-919))|(1<<(MySqlParserST_LINEFROMTEXT-919))|(1<<(MySqlParserST_LINEFROMWKB-919))|(1<<(MySqlParserST_LINESTRINGFROMTEXT-919))|(1<<(MySqlParserST_LINESTRINGFROMWKB-919))|(1<<(MySqlParserST_NUMGEOMETRIES-919))|(1<<(MySqlParserST_NUMINTERIORRING-919))|(1<<(MySqlParserST_NUMINTERIORRINGS-919))|(1<<(MySqlParserST_NUMPOINTS-919))|(1<<(MySqlParserST_OVERLAPS-919))|(1<<(MySqlParserST_POINTFROMTEXT-919))|(1<<(MySqlParserST_POINTFROMWKB-919))|(1<<(MySqlParserST_POINTN-919)))) != 0) || (((_la-951)&-(0x1f+1)) == 0 && ((1<<uint((_la-951)))&((1<<(MySqlParserST_POLYFROMTEXT-951))|(1<<(MySqlParserST_POLYFROMWKB-951))|(1<<(MySqlParserST_POLYGONFROMTEXT-951))|(1<<(MySqlParserST_POLYGONFROMWKB-951))|(1<<(MySqlParserST_SRID-951))|(1<<(MySqlParserST_STARTPOINT-951))|(1<<(MySqlParserST_SYMDIFFERENCE-951))|(1<<(MySqlParserST_TOUCHES-951))|(1<<(MySqlParserST_UNION-951))|(1<<(MySqlParserST_WITHIN-951))|(1<<(MySqlParserST_X-951))|(1<<(MySqlParserST_Y-951))|(1<<(MySqlParserSUBDATE-951))|(1<<(MySqlParserSUBSTRING_INDEX-951))|(1<<(MySqlParserSUBTIME-951))|(1<<(MySqlParserSYSTEM_USER-951))|(1<<(MySqlParserTAN-951))|(1<<(MySqlParserTIMEDIFF-951))|(1<<(MySqlParserTIMESTAMPADD-951))|(1<<(MySqlParserTIMESTAMPDIFF-951))|(1<<(MySqlParserTIME_FORMAT-951))|(1<<(MySqlParserTIME_TO_SEC-951))|(1<<(MySqlParserTOUCHES-951))|(1<<(MySqlParserTO_BASE64-951))|(1<<(MySqlParserTO_DAYS-951))|(1<<(MySqlParserTO_SECONDS-951))|(1<<(MySqlParserUCASE-951))|(1<<(MySqlParserUNCOMPRESS-951))|(1<<(MySqlParserUNCOMPRESSED_LENGTH-951))|(1<<(MySqlParserUNHEX-951))|(1<<(MySqlParserUNIX_TIMESTAMP-951))|(1<<(MySqlParserUPDATEXML-951)))) != 0) || (((_la-983)&-(0x1f+1)) == 0 && ((1<<uint((_la-983)))&((1<<(MySqlParserUPPER-983))|(1<<(MySqlParserUUID-983))|(1<<(MySqlParserUUID_SHORT-983))|(1<<(MySqlParserVALIDATE_PASSWORD_STRENGTH-983))|(1<<(MySqlParserVERSION-983))|(1<<(MySqlParserWAIT_UNTIL_SQL_THREAD_AFTER_GTIDS-983))|(1<<(MySqlParserWEEKDAY-983))|(1<<(MySqlParserWEEKOFYEAR-983))|(1<<(MySqlParserWEIGHT_STRING-983))|(1<<(MySqlParserWITHIN-983))|(1<<(MySqlParserYEARWEEK-983))|(1<<(MySqlParserY_FUNCTION-983))|(1<<(MySqlParserX_FUNCTION-983)))) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

func (p *MySqlParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 65:
		var t *ExpressionContext = nil
		if localctx != nil {
			t = localctx.(*ExpressionContext)
		}
		return p.Expression_Sempred(t, predIndex)

	case 66:
		var t *PredicateContext = nil
		if localctx != nil {
			t = localctx.(*PredicateContext)
		}
		return p.Predicate_Sempred(t, predIndex)

	case 67:
		var t *ExpressionAtomContext = nil
		if localctx != nil {
			t = localctx.(*ExpressionAtomContext)
		}
		return p.ExpressionAtom_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *MySqlParser) Expression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
		return p.Precpred(p.GetParserRuleContext(), 3)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySqlParser) Predicate_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 1:
		return p.Precpred(p.GetParserRuleContext(), 8)

	case 2:
		return p.Precpred(p.GetParserRuleContext(), 6)

	case 3:
		return p.Precpred(p.GetParserRuleContext(), 5)

	case 4:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 5:
		return p.Precpred(p.GetParserRuleContext(), 10)

	case 6:
		return p.Precpred(p.GetParserRuleContext(), 9)

	case 7:
		return p.Precpred(p.GetParserRuleContext(), 7)

	case 8:
		return p.Precpred(p.GetParserRuleContext(), 4)

	case 9:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySqlParser) ExpressionAtom_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 10:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 11:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 12:
		return p.Precpred(p.GetParserRuleContext(), 1)

	case 13:
		return p.Precpred(p.GetParserRuleContext(), 12)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
